<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="en">
  <siteinfo>
    <sitename>Wikibooks</sitename>
    <dbname>enwikibooks</dbname>
    <base>https://en.wikibooks.org/wiki/Main_Page</base>
    <generator>MediaWiki 1.33.0-wmf.23</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">Wikibooks</namespace>
      <namespace key="5" case="first-letter">Wikibooks talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="102" case="first-letter">Cookbook</namespace>
      <namespace key="103" case="first-letter">Cookbook talk</namespace>
      <namespace key="108" case="first-letter">Transwiki</namespace>
      <namespace key="109" case="first-letter">Transwiki talk</namespace>
      <namespace key="110" case="first-letter">Wikijunior</namespace>
      <namespace key="111" case="first-letter">Wikijunior talk</namespace>
      <namespace key="112" case="first-letter">Subject</namespace>
      <namespace key="113" case="first-letter">Subject talk</namespace>
      <namespace key="828" case="first-letter">Module</namespace>
      <namespace key="829" case="first-letter">Module talk</namespace>
      <namespace key="2300" case="first-letter">Gadget</namespace>
      <namespace key="2301" case="first-letter">Gadget talk</namespace>
      <namespace key="2302" case="case-sensitive">Gadget definition</namespace>
      <namespace key="2303" case="case-sensitive">Gadget definition talk</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Java Programming/Language Fundamentals</title>
    <ns>0</ns>
    <id>58119</id>
    <revision>
      <id>3295224</id>
      <parentid>3241589</parentid>
      <timestamp>2017-09-17T14:42:22Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4498">&lt;noinclude&gt;{{Displaytitle|title=Language fundamentals}}
{{Programming/Navigation}}
{{Java Programming/LanguageFundamentalsTopic/Nav}}
{{Java Programming/BeginnersTopics/Nav}}&lt;/noinclude&gt;
The previous chapter ''"[[../Getting started|Getting started]]"'' was a primer course in the basics of understanding how Java programming works. Throughout the chapter, we tackled a variety of concepts that included:
* Objects and class definitions;
* Abstract and data types;
* Properties;
* Methods;
* Class-level and method-level scopes;
* Keywords; and,
* Access modifiers, etc.

From this point on, we will be looking into the above mentioned concepts and many more in finer detail with a deeper and richer understanding of how each one of them works. This chapter on '''Language fundamentals''' introduces the fundamental elements of the Java programming language in detail. The discussions in this chapter will use the concepts we have already gathered from our previous discussions and build upon them in a progressive manner.

==The Java programming syntax==
In [[w:Linguistics|linguistics]], the word '''syntax''' (which comes from [[w:Ancient Greek|Ancient Greek]] ''[[wikt:σύνταξις|σύνταξις]]'' where ''σύν'' [syn] means "together", and ''τάξις'' [táxis] means "an ordering") refers to "the process of arranging things". It defines the principles and rules for constructing phrases and [[w:Sentence (linguistics)|sentences]] in [[w:Natural language|natural languages]].

When learning a new language, the first step one must take is to learn its '''programming syntax'''. ''Programming syntax'' is to programming languages what ''grammar'' is to spoken languages. Therefore, in order to create effective code in the Java programming language, we need to learn its syntax — its principles and rules for constructing valid code statements and expressions.

Java uses a syntax similar to the [[C Programming|C programming language]] and therefore if one learns the Java programming syntax, they automatically would be able to read and write programs in similar languages — C, [[C++ Programming|C++]] and [[C Sharp Programming|C#]]

The next step one must take when learning a new language is to learn its keywords; by combining the knowledge of [[Java Programming/Keywords|keywords]] with an understanding of [[Java Programming/Syntax|syntax]] rules, one can create [[Java Programming/Statements|statements]], Programming Blocks, Classes, Interfaces, et al.

Use [[Java Programming/Packages|packages]] to avoid name collisions. To hide as much information as possible use the [[Java Programming/Access Modifiers|access modifiers]] properly.

Create [[Java Programming/Methods|methods]] that do one and if possible only one thing/task. If possible have separate method that changes the object state.

In an object oriented language, programs are run with objects; however, for ease of use and for historic reasons, Java has [[Java Programming/Primitive Types|primitive types]]. Primitive Data Types only store values and have no methods. Primitive Types may be thought of as Raw Data and are usually embedded attributes inside objects or used as local variables in methods. Because primitive types are not subclasses of the object superclass, each type has a Wrapper Class which is a subclass of Object, and can thus be stored in a collection or returned as an object.

Java is a strong [[Java Programming/Classes, Objects and Types|type]] checking language. There are two concepts regarding types and objects. One is the object type and the other the template/class the object was created from. When an object is created, the template/class is assigned to that object which can not be changed. Types of an object however can be changed by type casting. Types of an object is associated with the object reference that referencing the object and determines what operation can be performed on the object through that object reference. Assigning the value of one object reference to a different type of object reference is called type casting.

The most often used data structure in any language is a character string. For this reason java defines a special object that is [[Java Programming/API/java.lang.String|String]].

To aggregate same type java objects to an array, java has a special [[Java Programming/Arrays|array]] object for that. Both java objects and primitive types can be aggregated to arrays.

&lt;noinclude&gt;{{Programming/Navigation}}
{{Status|100%}}
&lt;/noinclude&gt;</text>
      <sha1>qskpscipk6w2refgy7bd73ujehoqqv0</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Statements</title>
    <ns>0</ns>
    <id>48211</id>
    <revision>
      <id>3295253</id>
      <parentid>3223222</parentid>
      <timestamp>2017-09-17T14:43:18Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="23285">&lt;noinclude&gt;{{Displaytitle|title=Statements}}
{{Programming/Navigation}}
{{Java Programming/LanguageFundamentalsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

Now that we have the Java platform on our systems and have run the first program successfully, we are geared towards understanding how programs are actually made. As we have already discussed, a program is a set of instructions, which are tasks provided to a computer. These instructions are called '''statements''' in Java. Statements can be anything from a single line of code to a complex mathematical equation. Consider the following line:
{{XExample|1='''Code section 3.1: A simple assignment statement.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int age = 24;
&lt;/syntaxhighlight&gt;}}

This line is a simple instruction that tells the system to initialize a variable and set its value as 24. If the above statement was the only one in the program, it would look similar to this:

{{XCode|1=&lt;span id="code-listing-1"&gt;'''Code listing 3.1: A statement in a simple class.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java" line start="1" highlight="3"&gt;
public class MyProgram {
    public static void main(String[] args) {
        int age = 24;
    }
}
&lt;/syntaxhighlight&gt;}}

Java places its statements within a class declaration and, in the class declaration, the statements are usually placed in a method declaration, as above.

== Variable declaration statement ==
The simplest statement is a variable declaration:
{{XExample|1='''Code section 3.2: A simple declaration statement.'''
&lt;syntaxhighlight lang="Java" line start="1"&gt;
int age;
&lt;/syntaxhighlight&gt;}}

It defines a variable that can be used to store values for later use. The first token is the [[Java Programming/Primitive Types|data type]] of the variable (which type of values this variable can store). The second token is the name of the variable, by which you will be referring to it. Then each declaration statement is ended by a semicolon (&lt;code&gt;;&lt;/code&gt;).

==Assignment statements==
Up until now, we've assumed the creation of variables as a single statement. In essence, we assign a value to those variables, and that's just what it is called. When you assign a value to a variable in a statement, that statement is called an '''assignment statement''' (also called an [[w:Initialization (programming)|initialization statement]]). Did you notice one more thing? It's the semicolon (&lt;code&gt;;&lt;/code&gt;), which is at the end of each statement. A clear indicator that a line of code is a statement is its termination with an ending semicolon. If one was to write multiple statements, it is usually done with each statement on a separate line ending with a semicolon. Consider the example below:

{{XExample|1=&lt;span id="section-3"&gt;'''Code section 3.3: Multiple assignment statements.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java" line start="1"&gt;
int a = 10;
int b = 20;
int c = 30;
&lt;/syntaxhighlight&gt;}}

You do not necessarily have to use a new line to write each statement. Just like English, you can begin writing the next statement where you ended the first one as depicted below:

{{XExample|1='''Code section 3.4: Multiple assignment statements on the same line.'''
&lt;syntaxhighlight lang="Java" line start="1"&gt;
int a = 10; int b = 20; int c = 30;
&lt;/syntaxhighlight&gt;}}

However, the only problem with putting multiple statements on one line is, it's very difficult to read it. It doesn't look that intimidating at first, but once you've got a significant amount of code, it's usually better to organize it in a way that makes sense. It would look more complex and incomprehensible written as it is in Listing 3.4.

Now that we have looked into the anatomy of a simple assignment statement, we can look back at what we've achieved. We know that...
* A statement is a unit of code in programming.
* If we are assigning a variable a value, the statement is called an assignment statement.
* An assignment statement includes three parts: a data type, the variable name (also called the identifier) and the value of a variable. We will look more into the nature of identifiers and values in the section ''[[Java Programming/Variables|Variables]]'' later.

Now, before we move on to the next topic, you need to try and understand what the code below does.

{{XExample|1='''Code section 3.5: Multiple assignment statements with expressions.'''
&lt;syntaxhighlight lang="Java" line start="1"&gt;
int firstNumber = 10;
int secondNumber = 20;
int result = firstNumber + secondNumber;
System.out.println(result);
secondNumber = 30;
System.out.println(result);
&lt;/syntaxhighlight&gt;}}

The first two statements are pretty much similar to those in [[#section-3|Section 3.3]] but with different variable names. The third however is a bit interesting. We've already talked of variables as being similar to gift boxes. Think of your computer's memory as a shelf where you put all those boxes. Whenever you need a box (or variable), you call its identifier (that's the name of the variable). So calling the variable identifier &lt;code&gt;firstNumber&lt;/code&gt; gives you the number &lt;code&gt;10&lt;/code&gt;, calling &lt;code&gt;secondNumber&lt;/code&gt; would give you &lt;code&gt;20&lt;/code&gt; hence when you add the two up, the answer should be &lt;code&gt;30&lt;/code&gt;. That's what the value of the last variable &lt;code&gt;result&lt;/code&gt; would be. The part of the third statement where you add the numbers, i.e., &lt;code&gt;firstNumber + secondNumber&lt;/code&gt; is called an '''expression''' and the expression is what decides what the value is to be. If it's just a plain value, like in the first two statements, then it's called a '''literal''' (the value is ''literally'' the value, hence the name ''literal'').

Note that after the assignment to &lt;code&gt;result&lt;/code&gt; its value will not be changed if we assign different values to &lt;code&gt;firstNumber&lt;/code&gt; or &lt;code&gt;secondNumber&lt;/code&gt;, like in line 5.

With the information you have just attained, you can actually write a decent Java program that can sum up values.

== Assertion ==
An assertion checks if a condition is true:
{{XExample|1='''Code section 3.6: A return statement.'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2"&gt;
    public int getAge() {
        assert age &gt;= 0;
        return age;
    }
&lt;/syntaxhighlight&gt;}}

Each &lt;code&gt;assert&lt;/code&gt; statement is ended by a semi-colon (&lt;code&gt;;&lt;/code&gt;). However, assertions are disabled by default, so you must run the program with the ''-ea'' argument in order for assertions to be enabled (&lt;code&gt;java -ea [name of compiled program]&lt;/code&gt;).

== Program Control Flow ==
Statements are evaluated in the order as they occur. The execution of flow begins at the top most statement and proceed downwards till the last statement is encountered. A statement can be substituted by a statement block. There are special statements that can redirect the execution flow based on a condition, those statements are called ''branching'' statements, described in detail in a later section.

== Statement Blocks ==
A bunch of statements can be placed in braces to be executed as a single block. Such a block of statements can be named
or be provided with a condition for execution. Below is how you'd place a series of statements in a block.

{{XExample|1='''Code section 3.7: A statement block.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
{
    int a = 10;
    int b = 20;
    int result = a + b;
}
&lt;/syntaxhighlight&gt;}}

== Branching Statements ==
Program flow can be affected using function/method calls, loops and iterations. Of various types of branching constructs,
we can easily pick out two generic branching methods.

* Unconditional Branching
* Conditional Branching

=== Unconditional Branching Statements ===
If you look closely at a method, you'll see that a method is a named statement block that is executed by calling that particular name. An unconditional branch is created either by invoking the method or by calling &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt; or &lt;code&gt;throw&lt;/code&gt;, all of which are described below.

When a name of a method is encountered in a flow, it stops execution in the current method and branches to the newly called method. After returning a value from the called method, execution picks up at the original method on the line below the method call.

{| style="width: 100%;"
|valign="top"|{{XCode|1=&lt;span id="code-listing-8"&gt;'''Code listing 3.8: UnconditionalBranching.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="4"&gt;
public class UnconditionalBranching {
    public static void main(String[] args) {
        System.out.println("Inside main method! Invoking aMethod!");
        aMethod();
        System.out.println("Back in main method!");
    }

    public static void aMethod() {
        System.out.println("Inside aMethod!");
    }
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output provided with the screen of information running the above code.
&lt;pre style="background-color:#000; color:#fff;"&gt;
Inside main method! Invoking aMethod!
Inside aMethod!
Back in main method!
&lt;/pre&gt;}}
|}

The program flow begins in the &lt;code&gt;main&lt;/code&gt; method. Just as &lt;code&gt;aMethod&lt;/code&gt; is invoked, the flow travels to
the called method. At this very point, the flow branches to the other method. Once the method is completed, the flow
is returned to the point it left off and resumes at the next statement after the call to the method.

== Return statement ==
A &lt;code&gt;return&lt;/code&gt; statement exits from a block, so it is often the last statement of a method:
{{XExample|1='''Code section 3.9: A return statement.'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3"&gt;
    public int getAge() {
        int age = 24;
        return age;
    }
&lt;/syntaxhighlight&gt;}}

A return statement can return the content of a variable or nothing. Beware not to write statements after a return statement which would not be executed! Each &lt;code&gt;return&lt;/code&gt; statement is ended by a semi-colon (&lt;code&gt;;&lt;/code&gt;).

=== Conditional Branching Statements ===
Conditional branching is attained with the help of the &lt;code&gt;if...else&lt;/code&gt; and &lt;code&gt;switch&lt;/code&gt; statements. A
conditional branch occurs only if a certain condition expression evaluates to true.

====Conditional Statements====

Also referred to as ''{{java:if}} statements'', these allow a program to perform a test and then take action based on the result of that test.

The form of the {{java:if}} statement:

 {{java:if}} (''condition'') {
   ''do statements here if condition is true''
 } {{java:else}} {
   ''do statements here if condition is false''
 }

The ''condition'' is a boolean expression which can be either {{java:true}} or {{java:false}}. The actions performed will depend on the value of the condition.

Example:

{{XExample|1='''Code section 3.10: An if statement.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
if (i &gt; 0) {
   System.out.println("value stored in i is greater than zero");
} else {
   System.out.println("value stored is not greater than zero");
}
&lt;/syntaxhighlight&gt;}}

If statements can also be made more complex using the else if combination:

 {{java:if}} (''condition 1'') {
    ''do statements here if condition 1 is true''
 } {{java:else}} {{java:if}} (''condition 2'') {
    ''do statements here if condition 1 is false and condition 2 is true''
 } {{java:else}} {
   ''do statements here if neither condition 1 nor condition 2 is true''
 }

Example:

{{XExample|1='''Code section 3.11: An if/else if/else statement.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
if (i &gt; 0) {
   System.out.println("value stored in i is greater than zero");
} else if (i &lt; 0) {
   System.out.println("value stored in i is less than zero");
} else {
   System.out.println("value stored is equal to 0");
}
&lt;/syntaxhighlight&gt;}}

If there is only one statement to be executed after the condition, as in the above example, it is possible to omit the curly braces, however Oracle's [http://www.oracle.com/technetwork/java/index.html#449 Java Code Conventions] explicitly state that the braces should always be used.

There is no looping involved in an if statement so once the condition has been evaluated the program will continue with the next instruction after the statement.

==== If...else statements ====

The {{Java:if}} ... {{Java:else}} statement is used to conditionally execute one of two blocks of
statements, depending on the result of a boolean condition.

Example:

{{XExample|1='''Code section 3.12: An if/else statement.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
if (list == null) {
  // This block of statements executes if the condition is true.
} else {
  // This block of statements executes if the condition is false.
}
&lt;/syntaxhighlight&gt;}}

Oracle's [http://www.oracle.com/technetwork/java/index.html#449 Java Code Conventions] recommend that the braces should always be used.

An {{Java:if}} statement has two forms:

 {{Java:if}} (boolean-condition)
    {{Java:statement1}}

and

 {{Java:if}} (boolean-condition)
    {{Java:statement1}}
 {{Java:else}}
    {{Java:statement2}}

Use the second form if you have different statements to execute if the {{Java:boolean-condition}} is true or if it is false. Use the first if you only wish to execute {{Java:statement1}} if the condition is true and you do not wish to execute alternate statements if the condition is false.

The [[#code-section-13|code section 3.13]] calls two {{Java:int}} methods, &lt;code&gt;f()&lt;/code&gt; and &lt;code&gt;y()&lt;/code&gt;, stores the results, then uses an {{Java:if}} statement to test if &lt;code&gt;x&lt;/code&gt; is less than y and if it is, the {{Java:statement1}} body will swap the values. The end result is x always contains the larger result and y always contains the smaller result.

{{XExample|1=&lt;span id="code-section-13"&gt;'''Code section 3.13: Value swap.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int x = f();
int y = y();
if (x &lt; y) {
  int z = x;
  x = y;
  y = z;
}
&lt;/syntaxhighlight&gt;}}

{{Java:if}}...{{Java:else}} statements also allow for the use of another statement, {{Java:else}} {{Java:if}}.  This statement is used to provide another {{Java:if}} statement to the conditional that can only be executed if the others are not true.  For example:

{{XExample|1='''Code section 3.14: Multiple branching.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
if (x == 2)
  x = 4;
else if (x == 3)
  x = 6;
else
  x = -1;
&lt;/syntaxhighlight&gt;}}

The {{Java:else}} {{Java:if}} statement is useful in this case because if one of the conditionals is true, the other must be false.  Keep in mind that if one is true, the other ''will not'' execute.  For example, if the statement at line 2 contained in the first conditional were changed to &lt;code&gt;x = 3;&lt;/code&gt;, the second conditional, the {{Java:else}} {{Java:if}}, would still not execute.  However, when dealing with primitive types in conditional statements, it is more desirable to use &lt;code&gt;[[Java_Programming/Statements#Switch_statements|switch statements]]&lt;/code&gt; rather than multiple {{Java:else}} {{Java:if}} statements.

==== Switch statements ====
The {{Java:switch}} conditional statement is basically a shorthand version of writing many {{Java:if}}...{{Java:else}} statements.  The syntax for {{Java:switch}} statements is as follows:
 {{Java:switch}}(&lt;variable&gt;) {
   case &lt;result&gt;: &lt;statements&gt;; break;
   case &lt;result&gt;: &lt;statements&gt;; break;
   default: &lt;statements&gt;; break;
 }
This means that if the variable included equals one of the case results, the statements following that case, until the word &lt;code&gt;break&lt;/code&gt; will run.  The &lt;code&gt;default&lt;/code&gt; case executes if none of the others are true.  '''Note:''' the only types that can be analysed through {{Java:switch}} statements are {{java:char}}, {{java:byte}}, {{java:short}}, or {{java:int}} primitive types.  This means that {{Java:Object}} variables can not by analyzed through {{Java:switch}} statements. However, as of the JDK 7 release, you can use a String object in the expression of a switch statement.

{{XExample|1='''Code section 3.15: A switch.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int n = 2, x;
switch (n) {
  case 1: x = 2;
    break;
  case 2: x = 4;
    break;
  case 3: x = 6;
    break;
  case 4: x = 8;
    break;
}
return x;
&lt;/syntaxhighlight&gt;}}
In this example, since the integer variable &lt;code&gt;n&lt;/code&gt; is equal to 2, &lt;code&gt;case 2&lt;/code&gt; will execute, make &lt;code&gt;x&lt;/code&gt; equal to 4.  Thus, 4 is returned by the method.

== Iteration Statements ==
Iteration Statements are statements that are used to iterate a block of statements. Such statements are often referred
to as loops. Java offers four kinds of iterative statements.

* The &lt;code&gt;while&lt;/code&gt; loop
* The &lt;code&gt;do...while&lt;/code&gt; loop
* The &lt;code&gt;for&lt;/code&gt; loop
* The &lt;code&gt;foreach&lt;/code&gt; loop

=== The while loop ===
{{main|Java Programming/Keywords/while}}
The &lt;code&gt;while&lt;/code&gt; loop iterates a block of code while the condition it specifies is &lt;code&gt;true&lt;/code&gt;.

The syntax for the loop is:

 {{java:while}} (condition) {
    statement;
  }

Here the condition is an expression.
An expression as discussed earlier is any statement that returns a value. &lt;code&gt;While&lt;/code&gt; condition statements
evaluate to a boolean value, that is, either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. As long as the condition is
&lt;code&gt;true&lt;/code&gt;, the loop will iterate the block of code over and over and again. Once the condition evaluates
to &lt;code&gt;false&lt;/code&gt;, the loop exits to the next statement outside the loop.

=== The do...while loop ===
The do-while loop is functionally similar to the while loop, except the condition is evaluated AFTER the statement executes
 {{java:do}} {
    statement;
  } {{java:while}} (condition);

=== The for loop ===
{{Main|Java Programming/Keywords/for}}
The for loop is a specialized while loop whose syntax is designed for easy iteration through a sequence of numbers. Example:
{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-listing-16"&gt;'''Code section 3.16: A for loop.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
for (int i = 0; i &lt; 100; i++) {
  System.out.println(i + "\t" + i * i);
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for [[#code-listing-16|code listing 3.16]] if you compile and run the statement above.'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
 0      0
 1      1
 2      4
 3      9
 ...
 99     9801
&lt;/pre&gt;}}
|}
The program prints the numbers 0 to 99 and their squares.

The same statement in a while loop:
{{XExample|1='''Code section 3.17: An alternative version.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int i = 0;
while (i &lt; 100) {
   System.out.println(i + "\t" + i * i);
   i++;
}
&lt;/syntaxhighlight&gt;}}

=== The foreach loop ===
The foreach statement allows you to iterate through all the items in a collection,
examining each item in turn while still preserving its type. The syntax for the foreach statement is:

 {{java:for}} (''type'' item : collection) statement;

For an example, we'll take an array of &lt;code&gt;String&lt;/code&gt;s denoting days in a week and traverse through the
collection, examining one item at a time.

{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-listing-18"&gt;'''Code section 3.18: A foreach loop.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
String[] days = {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};

for (String day : days) {
  System.out.println(day);
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for [[#code-listing-18|code listing 3.18]]'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
Monday
Tuesday
Wednesday
Thursday
Friday
Saturday
Sunday
&lt;/pre&gt;}}
|}

Notice that the loop automatically exits after the last item in the collection has been examined in the statement
block.

Although the enhanced for loop can make code much clearer, it can't be used in some common situations.

* '''Only access.''' Elements can not be assigned to, eg, not to increment each element in a collection.
* '''Only single structure.''' It's not possible to traverse two structures at once, eg, to compare two arrays.
* '''Only single element.''' Use only for single element access, eg, not to compare successive elements.
* '''Only forward.''' It's possible to iterate only forward by single steps.
* '''At least Java 5.''' Don't use it if you need compatibility with versions before Java 5.

== The continue and break statements ==
At times, you would like to re-iterate a loop without executing the remaining statement within the loop. The
&lt;code&gt;{{java:continue}}&lt;/code&gt; statement causes the loop to re-iterate and start over from the top most statement inside
the loop.

Where there is an ability to re-iterate the loop, there is an ability to exit the loop when required. At any given
moment, if you'd like to exit a loop and end all further work within the loop, the &lt;code&gt;{{java:break}}&lt;/code&gt; ought to be
used.

The &lt;code&gt;{{java:continue}}&lt;/code&gt; and &lt;code&gt;{{java:break}}&lt;/code&gt; statements can be used with a label like follows:

{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-listing-19"&gt;'''Code section 3.19: Using a label.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2"&gt;
String s = "A test string for the switch!\nLine two of test string...";
outer: for (int i = 0; i &lt; s.length(); i++) {
  switch (s.charAt(i)) {
    case '\n': break outer;
    case ' ': break;
    default: System.out.print(s.charAt(i));
  }
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for [[#code-listing-19|code listing 3.19]]'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
 Ateststringfortheswitch!
&lt;/pre&gt;}}
|}

== Throw statement ==
A &lt;code&gt;throw&lt;/code&gt; statement exits from a method and so on and so on or it is caught by a &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; block. It does not return a variable but an exception:
{{XExample|1='''Code section 3.20: A return statement.'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2"&gt;
    public int getAge() {
        throw new NullPointerException();
    }
&lt;/syntaxhighlight&gt;}}

Beware not to write statements after a &lt;code&gt;throw&lt;/code&gt; statement which would not be executed too! Each &lt;code&gt;throw&lt;/code&gt; statement is ended by a semi-colon (&lt;code&gt;;&lt;/code&gt;).

== try/catch ==
A &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; must at least contain the &lt;code&gt;try&lt;/code&gt; block and the &lt;code&gt;catch&lt;/code&gt; block:
{{XExample|1='''Code section 3.21: try/catch block.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
try {
  // Some code
} catch (Exception e) {
  // Optional exception handling
} finally {
  // This code is executed no matter what
}
&lt;/syntaxhighlight&gt;}}

{{Java/Hidden begin|title=Test your knowledge}}
'''Question 3.1: How many statements are there in this class?'''
{{XCode|1='''Code listing 3.2: AProgram.java'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public class AProgram {

    private int age = 24;

    public static void main(String[] args) {
        int daysInAYear = 365;int ageInDay = 100000;
        int localAge = ageInDay / daysInAYear;
    }

    public int getAge() {
        return age;
    }
}
&lt;/syntaxhighlight&gt;}}
{{Java/Hidden begin|title=Answer}}
5&lt;br/&gt;One statement at line 3, two statements at line 6, one statement at line 7 and one statement at line 11.
{{Hidden end}}
{{Hidden end}}

&lt;noinclude&gt;{{Programming/Navigation}}
{{Status|100%}}&lt;/noinclude&gt;</text>
      <sha1>qlykt32lda192ongau3wofeaep3tc7u</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Conditional blocks</title>
    <ns>0</ns>
    <id>276576</id>
    <revision>
      <id>3295193</id>
      <parentid>2961212</parentid>
      <timestamp>2017-09-17T14:41:25Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11102">&lt;noinclude&gt;{{Displaytitle|title=Conditional blocks}}
{{Programming/Navigation}}
{{Java Programming/LanguageFundamentalsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

Conditional blocks allow a program to take a different path depending on some condition(s). These allow a program to perform a test and then take action based on the result of that test. In the code sections, the actually executed code lines will be highlighted.

=== If ===

The {{java:if}} block executes only if the boolean expression associated with it is true. The structure of an &lt;code&gt;if&lt;/code&gt; block is as follows:
{| style="margin: auto;"
|if ('''''boolean expression&lt;sub&gt;1&lt;/sub&gt;''''') {
:'''''statement&lt;sub&gt;1&lt;/sub&gt;'''''
:'''''statement&lt;sub&gt;2&lt;/sub&gt;'''''
:...
:'''''statement&lt;sub&gt;n&lt;/sub&gt;'''''
}
|}

Here is a double example to illustrate what happens if the condition is true and if the condition is false:
{| style="width: 100%;"
|valign="top"|{{XExample|1='''Code section 3.22: Two &lt;code&gt;if&lt;/code&gt; blocks.'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1-2, 4-5, 8, 12"&gt;
int age = 6;
System.out.println("Hello!");

if (age &lt; 13) {
  System.out.println("I'm a child.");
}

if (age &gt; 20) {
  System.out.println("I'm an adult.");
}

System.out.println("Bye!");
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XCode|1='''Output for Code section 3.22'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
Hello!
I'm a child
Bye!
&lt;/pre&gt;}}
|}

{{XNote|1=If only one statement is to be executed after an &lt;code&gt;if&lt;/code&gt; block, it does not have to be enclosed in curly braces.  For example, &lt;code&gt;if (i == 0) i = 1;&lt;/code&gt; is a perfectly valid portion of Java code. This works for most control structures, such as &lt;code&gt;else&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt;. However Oracle's [http://www.oracle.com/technetwork/java/index.html#449 Java Code Conventions] explicitly state that the braces should always be used.}}

=== If/else ===

The &lt;code&gt;if&lt;/code&gt; block may optionally be followed by an {{java:else}} block which will execute if that boolean expression is false. The structure of an &lt;code&gt;if&lt;/code&gt; block is as follows:
{| style="margin: auto"
|if ('''''boolean expression&lt;sub&gt;1&lt;/sub&gt;''''') {
:'''''statement&lt;sub&gt;1&lt;/sub&gt;'''''
:'''''statement&lt;sub&gt;2&lt;/sub&gt;'''''
:...
:'''''statement&lt;sub&gt;n&lt;/sub&gt;'''''
} else {
:'''''statement&lt;sub&gt;1bis&lt;/sub&gt;'''''
:'''''statement&lt;sub&gt;2bis&lt;/sub&gt;'''''
:...
:'''''statement&lt;sub&gt;nbis&lt;/sub&gt;'''''
}
|}


=== If/else-if/else ===

An &lt;code&gt;else-if&lt;/code&gt; block may be used when multiple conditions need to be checked. &lt;code&gt;else-if&lt;/code&gt; statements come after the &lt;code&gt;if&lt;/code&gt; block, but before the &lt;code&gt;else&lt;/code&gt; block. The structure of an &lt;code&gt;if&lt;/code&gt; block is as follows:
{| style="margin: auto;"
|if ('''''boolean expression&lt;sub&gt;1&lt;/sub&gt;''''') {
:'''''statement&lt;sub&gt;1.1&lt;/sub&gt;'''''
:'''''statement&lt;sub&gt;1.2&lt;/sub&gt;'''''
:...
:'''''statement&lt;sub&gt;n&lt;/sub&gt;'''''
} else if ('''''boolean expression&lt;sub&gt;2&lt;/sub&gt;''''') {
:'''''statement&lt;sub&gt;2.1&lt;/sub&gt;'''''
:'''''statement&lt;sub&gt;2.2&lt;/sub&gt;'''''
:...
:'''''statement&lt;sub&gt;2.n&lt;/sub&gt;'''''
} else {
:'''''statement&lt;sub&gt;3.1&lt;/sub&gt;'''''
:'''''statement&lt;sub&gt;3.2&lt;/sub&gt;'''''
:...
:'''''statement&lt;sub&gt;3.n&lt;/sub&gt;'''''
}
|}

Here is an example to illustrate:
{| style="width: 100%;"
|valign="top"|{{XCode|1='''Code listing 3.3: MyConditionalProgram.java'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3-4, 6"&gt;
public class MyConditionalProgram {
    public static void main (String[] args) {
      int a = 5;
      if (a &gt; 0) {
          // a is greater than 0, so this statement will execute
          System.out.println("a is positive");
      } else if (a &gt;= 0) {
          // a case has already executed, so this statement will NOT execute
          System.out.println("a is positive or zero");
      } else {
          // a case has already executed, so this statement will NOT execute
          System.out.println("a is negative");
      }
    }
}&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XCode|1='''Output for code listing 3.3'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
a is positive
&lt;/pre&gt;}}
|}

Keep in mind that ''only a single block'' will execute, and it will be the first true condition.

All the conditions are evaluated when &lt;code&gt;if&lt;/code&gt; is reached, no matter what the result of the condition is, after the execution of the &lt;code&gt;if&lt;/code&gt; block:
{| style="width: 100%;"
|valign="top"|{{XExample|1='''Code section 3.23: A new value for the variable a.'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1-2, 4-5"&gt;
int a = 5;
if (a &gt; 0) {
    // a is greater than 0, so this statement will execute
    System.out.println("a is positive");
    a = -5;
} else if (a &lt; 0) {
    // a WAS greater than 0, so this statement will not execute
    System.out.println("a is negative");
} else {
    // a does not equal 0, so this statement will not execute
    System.out.println("a is zero");
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XCode|1='''Output for code section 3.23'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
a is positive
&lt;/pre&gt;}}
|}

=== Conditional expressions ===
Conditional expressions use the compound &lt;code&gt;?:&lt;/code&gt; operator. Syntax:
{| style="margin: auto"
|'''''boolean expression&lt;sub&gt;1&lt;/sub&gt;''''' ? '''''expression&lt;sub&gt;1&lt;/sub&gt;''''' : '''''expression&lt;sub&gt;2&lt;/sub&gt;'''''
|}

This evaluates &lt;code&gt;boolean expression&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;, and if it is &lt;code&gt;true&lt;/code&gt; then the conditional expression has the value of &lt;code&gt;expression&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;; otherwise the conditional expression has the value of &lt;code&gt;expression&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;.

Example:
{{XExample|1='''Code section 3.24: Conditional expressions.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
String answer = (p &lt; 0.05)? "reject" : "keep";
&lt;/syntaxhighlight&gt;}}

This is equivalent to the following code fragment:
{{XExample|1='''Code section 3.25: Equivalent code.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
String answer;
if (p &lt; 0.05) {
    answer = "reject";
} else {
    answer = "keep";
}
&lt;/syntaxhighlight&gt;}}

=== Switch ===

The {{Java:switch}} conditional statement is basically a shorthand version of writing many {{Java:if}}...{{Java:else}} statements. The {{java:switch}} block evaluates a {{java:char}}, {{java:byte}}, {{java:short}}, or {{java:int}} (or {{java:enum}}, starting in J2SE 5.0; or {{java:String}}, starting in J2SE 7.0), and, based on the value provided, jumps to a specific {{java:case}} within the switch block and executes code until the {{java:break}} command is encountered or the end of the block.  If the switch value does not match any of the case values, execution will jump to the optional {{java:default}} case.

The structure of a &lt;code&gt;switch&lt;/code&gt; statement is as follows:
{| style="margin: auto"
|switch ('''''int&lt;sub&gt;1&lt;/sub&gt; or char&lt;sub&gt;1&lt;/sub&gt; or short&lt;sub&gt;1&lt;/sub&gt; or byte&lt;sub&gt;1&lt;/sub&gt; or enum&lt;sub&gt;1&lt;/sub&gt; or String value&lt;sub&gt;1&lt;/sub&gt;''''') {
:case '''''case value&lt;sub&gt;1&lt;/sub&gt;''''':
::'''''statement&lt;sub&gt;1.1&lt;/sub&gt;'''''
::...
::'''''statement&lt;sub&gt;1.n&lt;/sub&gt;'''''
::break;
:case '''''case value&lt;sub&gt;2&lt;/sub&gt;''''':
::'''''statement&lt;sub&gt;2.1&lt;/sub&gt;'''''
::...
::'''''statement&lt;sub&gt;2.n&lt;/sub&gt;'''''
::break;
:default:
::'''''statement&lt;sub&gt;n.1&lt;/sub&gt;'''''
::...
::'''''statement&lt;sub&gt;n.n&lt;/sub&gt;'''''
}
|}

Here is an example to illustrate:
{| style="width: 100%;"
|valign="top"|{{XExample|1='''Code section 3.26: A switch block.'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1-3, 7, 11, 13"&gt;
int i = 3;
switch(i) {
    case 1:
        // i doesn't equal 1, so this code won't execute
        System.out.println("i equals 1");
        break;
    case 2:
        // i doesn't equal 2, so this code won't execute
        System.out.println("i equals 2");
        break;
    default:
        // i has not been handled so far, so this code will execute
        System.out.println("i equals something other than 1 or 2");
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XCode|1='''Output for code section 3.26'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
i equals something other than 1 or 2
&lt;/pre&gt;}}
|}

If a case does not end with the &lt;code&gt;break&lt;/code&gt; statement, then the next case will be checked, otherwise the execution will jump to the end of the &lt;code&gt;switch&lt;/code&gt; statement.

Look at this example to see how it's done:
{| style="width: 100%;"
|valign="top"|{{XExample|1='''Code section 3.27: A switch block containing a case without break.'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1-4, 6-7"&gt;
int i = -1;
switch(i) {
    case -1:
    case 1:
        // i is -1, so it will fall through to this case and execute this code
        System.out.println("i is 1 or -1");
        break;
    case 0:
        // The break command is used before this case, so if i is 1 or -1, this will not execute
        System.out.println("i is 0");
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XCode|1='''Output for code section 3.27'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
i is 1 or -1
&lt;/pre&gt;}}
|}

Starting in J2SE 5.0, the &lt;code&gt;switch&lt;/code&gt; statement can also be used with an {{java:enum}} value instead of an integer.

Though &lt;code&gt;enums&lt;/code&gt; have not been covered yet, here is an example so you can see how it's done (note that the enum constants in the cases do not need to be qualified with the type:
{| style="width: 100%;"
|valign="top"|{{XExample|1='''Code section 3.28: A switch block with an enum type.'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1-3, 5-6"&gt;
Day day = Day.MONDAY; // Day is a fictional enum type containing the days of the week
switch(day) {
    case MONDAY:
        // Since day == Day.MONDAY, this statement will execute
        System.out.println("Mondays are the worst!");
        break;
    case TUESDAY:
    case WEDNESDAY:
    case THURSDAY:
        System.out.println("Weekdays are so-so.");
        break;
    case FRIDAY:
    case SATURDAY:
    case SUNDAY:
        System.out.println("Weekends are the best!");
        break;
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XCode|1='''Output for code section 3.28'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
Mondays are the worst!
&lt;/pre&gt;}}
|}

Starting in J2SE 7.0, the &lt;code&gt;switch&lt;/code&gt; statement can also be used with an {{java:String}} value instead of an integer.
{| style="width: 100%;"
|valign="top"|{{XExample|1='''Code section 3.29: A switch block with a String type.'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1-3, 5-6"&gt;
String day = "Monday";
switch(day) {
    case "Monday":
        // Since day == "Monday", this statement will execute
        System.out.println("Mondays are the worst!");
        break;
    case "Tuesday":
    case "Wednesday":
    case "Thursday":
        System.out.println("Weekdays are so-so.");
        break;
    case "Friday":
    case "Saturday":
    case "Sunday":
        System.out.println("Weekends are the best!");
        break;
    default:
        throw new IllegalArgumentException("Invalid day of the week: " + day);
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XCode|1='''Output for code section 3.29'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
Mondays are the worst!
&lt;/pre&gt;}}
|}

&lt;noinclude&gt;{{Programming/Navigation}}
{{Status|100%}}&lt;/noinclude&gt;</text>
      <sha1>ckwag2c1fulgq1kzztzqz0jk35av4yb</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Loop blocks</title>
    <ns>0</ns>
    <id>276548</id>
    <revision>
      <id>3501386</id>
      <parentid>3425064</parentid>
      <timestamp>2018-12-11T18:21:53Z</timestamp>
      <contributor>
        <username>Jellysandwich0</username>
        <id>3168881</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="24155">&lt;noinclude&gt;{{Displaytitle|title=Loop blocks}}
{{Programming/Navigation}}
{{Java Programming/LanguageFundamentalsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

Loops are a handy tool that enables programmers to do repetitive tasks with minimal effort. Say we want a program that can count from 1 to 10, we could write the [[#code-listing-4|following program]].
{| style="width: 100%;"
|valign="top"|{{XCode|1=&lt;span id="code-listing-4"&gt;'''Code listing 3.4: Count.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
class Count {
    public static void main(String[] args) {
        System.out.println("1 ");
        System.out.println("2 ");
        System.out.println("3 ");
        System.out.println("4 ");
        System.out.println("5 ");
        System.out.println("6 ");
        System.out.println("7 ");
        System.out.println("8 ");
        System.out.println("9 ");
        System.out.println("10 ");
    }
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for code listing 3.4'''
&lt;pre style="background-color:black; color:white;"&gt;
1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;}}
|}


The task will be completed just fine, the numbers 1 to 10 will be printed in the output, but there are a few problems with this solution:
* '''Flexibility''':  what if we wanted to change the start number or end number? We would have to go through and change them, adding extra lines of code where they're needed.
* '''Scalability''': 10 repeats are trivial, but what if we wanted 100 or even 1000 repeats? The number of lines of code needed would be overwhelming for a large number of iterations.
* '''Maintenance''': where there is a large amount of code, one is more likely to make a mistake.
* '''Feature''': the number of tasks is fixed and doesn't change at each execution.

Using loops we can solve all these problems. Once you get you head around them they will be invaluable to solving many problems in programming.

Open up your editing program and create a new file saved as &lt;code&gt;Loop.java&lt;/code&gt;. Now type or copy the [[#code-listing-5|following code]]:
{| style="width: 100%;"
|valign="top"|{{XCode|1=&lt;span id="code-listing-5"&gt;'''Code listing 3.5: Loop.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="5"&gt;
class Loop {
    public static void main(String[] args) {
        int i;
        for (i = 1; i &lt;= 10; i++) {
            System.out.println(i + " ");
        }
    }
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for code listing 3.5'''
&lt;pre style="background-color:black; color:white;"&gt;
1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;}}
|}

If we run the program, the same result is produced, but looking at the code, we immediately see the advantages of loops. Instead of executing ten different lines of code, line 5 executes ten times. Ten lines of code have been reduced to just four. Furthermore, we may change the number 10 to any number we like. Try it yourself, replace the 10 with your own number.

=== While ===

{{Java:while}} loops are the simplest form of loop. The &lt;code&gt;while&lt;/code&gt; loop repeats a block of code while the specified condition is true. Here is the structure of a &lt;code&gt;while&lt;/code&gt; loop:
{| style="margin: auto;"
|while ('''''boolean expression&lt;sub&gt;1&lt;/sub&gt;''''') {
:'''''statement&lt;sub&gt;1&lt;/sub&gt;'''''
:'''''statement&lt;sub&gt;2&lt;/sub&gt;'''''
:...
:'''''statement&lt;sub&gt;n&lt;/sub&gt;'''''
}
|}

The loop's condition is checked before each iteration of the loop. If the condition is false at the start of the loop, the loop will not be executed at all. The [[#code-section-28|code section 3.28]] sets in &lt;code&gt;squareHigherThan200&lt;/code&gt; the smallest integer whose square exceeds 200.
{{XExample|1=&lt;span id="code-section-28"&gt;'''Code section 3.28: The smallest integer whose square exceeds 200.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int squareHigherThan200 = 0;

while (squareHigherThan200 * squareHigherThan200 &lt; 200) {
  squareHigherThan200 = squareHigherThan200 + 1;
}
&lt;/syntaxhighlight&gt;}}

{{XNote|1=If a loop's condition will never become false, such as if the {{java:true}} constant is used for the condition, said loop is known as an ''infinite loop''. Such a loop will repeat indefinitely unless it is [[Java Programming/Keywords/break|broken]] out of. Infinite loops can be used to perform tasks that need to be repeated over and over again without a definite stopping point, such as updating a graphics display.}}

==== Do... while ====

The {{java:do}}-{{java:while}} loop is functionally similar to the &lt;code&gt;while&lt;/code&gt; loop, except the condition is evaluated AFTER the statement executes It is useful when we try to find a data that does the job by randomly browsing an amount of data.
{| style="margin: auto;"
|do {
:'''''statement&lt;sub&gt;1&lt;/sub&gt;'''''
:'''''statement&lt;sub&gt;2&lt;/sub&gt;'''''
:...
:'''''statement&lt;sub&gt;n&lt;/sub&gt;'''''
} while ('''''boolean expression&lt;sub&gt;1&lt;/sub&gt;''''');
|}

=== For ===

The {{java:for}} loop is a specialized &lt;code&gt;while&lt;/code&gt; loop whose syntax is designed for easy iteration through a sequence of numbers. It consists of the keyword &lt;code&gt;for&lt;/code&gt; followed by three extra statements enclosed in parentheses. The first statement is the variable declaration statement, which allows you to declare one or more integer variables. The second is the condition, which is checked the same way as the &lt;code&gt;while&lt;/code&gt; loop. Last is the iteration statement, which is used to increment or decrement variables, though any statement is allowed.

This is the structure of a &lt;code&gt;for&lt;/code&gt; loop:
{| style="margin: auto;"
|for ('''''variable declarations'''''; '''''condition'''''; '''''iteration statement''''') {
:'''''statement&lt;sub&gt;1&lt;/sub&gt;'''''
:'''''statement&lt;sub&gt;2&lt;/sub&gt;'''''
:...
:'''''statement&lt;sub&gt;n&lt;/sub&gt;'''''
}
|}

To clarify how a for loop is used, here is an example:
{| style="width: 100%;"
|valign="top"|{{XExample|1='''Code section 3.29: A &lt;code&gt;for&lt;/code&gt; loop.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
for (int i = 1; i &lt;= 10; i++) {
    System.out.println(i);
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for code listing 3.29'''
&lt;pre style="background-color:black; color:white;"&gt;
1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;}}
|}

The &lt;code&gt;for&lt;/code&gt; loop is like a template version of the &lt;code&gt;while&lt;/code&gt; loop. The alternative code using a &lt;code&gt;while&lt;/code&gt; loop would be as follows:
{{XExample|1='''Code section 3.30: An iteration using a &lt;code&gt;while&lt;/code&gt; loop.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int i = 1;
while (i &lt;= 10) {
  System.out.println(i);
  i++;
}
&lt;/syntaxhighlight&gt;}}

The [[#code-section-31|code section 3.31]] shows how to iterate with the &lt;code&gt;for&lt;/code&gt; loop using multiple variables and the [[#code-section-32|code section 3.32]] shows how any of the parameters of a &lt;code&gt;for&lt;/code&gt; loop can be skipped. Skip them all, and you have an infinitely repeating loop.
{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-31"&gt;'''Code section 3.31: The &lt;code&gt;for&lt;/code&gt; loop using multiple variables.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
for (int i = 1, j = 10; i &lt;= 10; i++, j--) {
  System.out.print(i + " ");
  System.out.println(j);
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XExample|1=&lt;span id="code-section-32"&gt;'''Code section 3.32: The &lt;code&gt;for&lt;/code&gt; loop without parameter.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
for (;;) {
  // Some code
}
&lt;/syntaxhighlight&gt;}}
|}

==== For-each ====

[[Java Programming/Arrays|Arrays]] haven't been covered yet, but you'll want to know how to use the enhanced for loop, called the &lt;code&gt;for-each&lt;/code&gt; loop. The &lt;code&gt;for-each&lt;/code&gt; loop automatically iterates through a list or array and assigns the value of each index to a variable.

To understand the structure of a &lt;code&gt;for-each&lt;/code&gt; loop, look at the following example:
{| style="width: 100%;"
|valign="top"|{{XExample|1='''Code section 3.33: A &lt;code&gt;for-each&lt;/code&gt; loop.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
String[] sentence = {"I", "am", "a", "Java", "program."};
for (String word : sentence) {
    System.out.print(word + " ");
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for code section 3.33'''
&lt;pre style="background-color:black; color:white;"&gt;
I am a Java program.
&lt;/pre&gt;}}
|}

The example iterates through an array of words and prints them out like a sentence. What the loop does is iterate through &lt;code&gt;sentence&lt;/code&gt; and assign the value of each index to &lt;code&gt;word&lt;/code&gt;, then execute the code block.

Here is the general contract of the &lt;code&gt;for-each&lt;/code&gt; loop:
{| style="margin: auto;"
|for ('''''variable declaration''''' : '''''array or list''''') {
:'''''statement&lt;sub&gt;1&lt;/sub&gt;'''''
:'''''statement&lt;sub&gt;2&lt;/sub&gt;'''''
:...
:'''''statement&lt;sub&gt;n&lt;/sub&gt;'''''
}
|}

Make sure that the type of the array or list is assignable to the declared variable, or you will get a compilation error. Notice that the loop automatically exits after the last item in the collection has been examined in the statement
block.

Although the enhanced for loop can make code much clearer, it can't be used in some common situations.

* '''Only access.''' Elements can not be assigned to, eg, not to increment each element in a collection.
* '''Only single structure.''' It's not possible to traverse two structures at once, eg, to compare two arrays.
* '''Only single element.''' Use only for single element access, eg, not to compare successive elements.
* '''Only forward.''' It's possible to iterate only forward by single steps.
* '''At least Java 5.''' Don't use it if you need compatibility with versions before Java 5.

== Break and continue keywords ==

The {{Java:break}} keyword exits a flow control loop, such as a for loop. It basically ''breaks'' the loop.

In the [[#code-section-34|code section 3.34]], the loop would print out all the numbers from 1 to 10, but we have a check for when &lt;code&gt;i&lt;/code&gt; equals 5. When the loop reaches its fifth iteration, it will be cut short by the &lt;code&gt;break&lt;/code&gt; statement, at which point it will exit the loop.
{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-34"&gt;'''Code section 3.34: An interrupted &lt;code&gt;for&lt;/code&gt; loop.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
for (int i = 1; i &lt;= 10; i++) {
    System.out.println(i);
    if (i == 5) {
       System.out.println("STOP!");
       break;
    }
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for code section 3.34'''
&lt;pre style="background-color:black; color:white;"&gt;
1
2
3
4
5
STOP!
&lt;/pre&gt;}}
|}

The {{java:continue}} keyword jumps straight to the next iteration of a loop and evaluates the boolean expression controlling the loop. The [[#code-section-35|code section 3.35]] is an example of the &lt;code&gt;continue&lt;/code&gt; statement in action:
{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-35"&gt;'''Code section 3.35: A &lt;code&gt;for&lt;/code&gt; loop with a skipped iteration.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
for (int i = 1; i &lt;= 10; i++) {
    if (i == 5) {
        System.out.println("Caught i == 5");
        continue;
    }
    System.out.println(i);
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for code section 3.35'''
&lt;pre style="background-color:black; color:white;"&gt;
1
2
3
4
Caught i == 5
6
7
8
9
10
&lt;/pre&gt;}}
|}

As the &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; statements reduce the readability of the code, it is recommended to reduce their use or replace them with the use of &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt; blocks. Some IDE refactoring operations will fail because of such statements.

{{Java/Hidden begin|title=Test your knowledge}}
'''Question 3.2''': Consider the following code:

{{XExample|1=&lt;span id="question-2"&gt;'''Question 3.2: Loops and conditions.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int numberOfItems = 5;
int currentItems = 0;
int currentCandidate = 1;

while (currentItems &lt; numberOfItems) {
  currentCandidate = currentCandidate + 1;
  System.out.println("Test with integer: " + currentCandidate);
 
  boolean found = true;
  for (int i = currentCandidate - 1; i &gt; 1; i--) {
   
    // Test if i is a divisor of currentCandidate
    if ((currentCandidate % i) == 0) {
      System.out.println("Not matching...");
      found = false;
      break;
    }
   
  }
 
  if (found) {
    System.out.println("Matching!");
    currentItems = currentItems + 1;
  }
}

System.out.println("Find the value: " + currentCandidate);
&lt;/syntaxhighlight&gt;}}

What will be printed in the standard output?
{{Java/Hidden begin|title=Answer}}
{{XConsole|1='''Output for Question 3.2'''
&lt;pre style="background-color:black; color:white;"&gt;
Test with integer: 2
Matching!
Test with integer: 3
Matching!
Test with integer: 4
Not matching...
Test with integer: 5
Matching!
Test with integer: 6
Not matching...
Test with integer: 7
Matching!
Test with integer: 8
Not matching...
Test with integer: 9
Not matching...
Test with integer: 10
Not matching...
Test with integer: 11
Matching!
Find the value: 11
&lt;/pre&gt;}}

The snippet is searching the 5&lt;sup&gt;th&lt;/sup&gt; [[w:Prime number|prime number]], that is to say: 11. It iterates on each positive integer from 2 (2, 3, 4, 5, 6, 7, 8, 9, 10, 11...), among them, it counts the prime numbers (2, 3, 5, 7, 11) and it stops at the 5&lt;sup&gt;th&lt;/sup&gt; one.

So the snippet first iterates on each positive integer from 2 using the &lt;code&gt;while&lt;/code&gt; loop:
{{XExample|1=&lt;span id="answer-2-1"&gt;'''Answer 3.2.1: &lt;code&gt;while&lt;/code&gt; loop.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="6-24"&gt;
int numberOfItems = 5;
int currentItems = 0;
int currentCandidate = 1;

while (currentItems &lt; numberOfItems) {
  currentCandidate = currentCandidate + 1;
  System.out.println("Test with integer: " + currentCandidate);
 
  boolean found = true;
  for (int i = currentCandidate - 1; i &gt; 1; i--) {
   
    // Test if i is a divisor of currentCandidate
    if ((currentCandidate % i) == 0) {
      System.out.println("Not matching...");
      found = false;
      break;
    }
   
  }
 
  if (found) {
    System.out.println("Matching!");
    currentItems = currentItems + 1;
  }
}

System.out.println("Find the value: " + currentCandidate);

&lt;/syntaxhighlight&gt;}}

For each iteration, the current number is either a prime number or not. If it is a prime number, the code at the left will be executed. If it is not a prime number, the code at the right will be executed.
{| style="width: 100%;"
|
{{XExample|1=&lt;span id="answer-2-2"&gt;'''Answer 3.2.2: A prime number.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="6-13, 18-24"&gt;
int numberOfItems = 5;
int currentItems = 0;
int currentCandidate = 1;

while (currentItems &lt; numberOfItems) {
  currentCandidate = currentCandidate + 1;
  System.out.println("Test with integer: " + currentCandidate);
 
  boolean found = true;
  for (int i = currentCandidate - 1; i &gt; 1; i--) {
   
    // Test if i is a divisor of currentCandidate
    if ((currentCandidate % i) == 0) {
      System.out.println("Not matching...");
      found = false;
      break;
    }
   
  }
 
  if (found) {
    System.out.println("Matching!");
    currentItems = currentItems + 1;
  }
}

System.out.println("Find the value: " + currentCandidate);
&lt;/syntaxhighlight&gt;}}

|
{{XExample|1=&lt;span id="answer-2-3"&gt;'''Answer 3.2.3: Not a prime number.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="6-21"&gt;
int numberOfItems = 5;
int currentItems = 0;
int currentCandidate = 1;

while (currentItems &lt; numberOfItems) {
  currentCandidate = currentCandidate + 1;
  System.out.println("Test with integer: " + currentCandidate);
 
  boolean found = true;
  for (int i = currentCandidate - 1; i &gt; 1; i--) {
   
    // Test if i is a divisor of currentCandidate
    if ((currentCandidate % i) == 0) {
      System.out.println("Not matching...");
      found = false;
      break;
    }
   
  }
 
  if (found) {
    System.out.println("Matching!");
    currentItems = currentItems + 1;
  }
}

System.out.println("Find the value: " + currentCandidate);
&lt;/syntaxhighlight&gt;}}
|}

The prime numbers are counted using &lt;code&gt;currentItems&lt;/code&gt;. When &lt;code&gt;currentItems&lt;/code&gt; is equal to &lt;code&gt;numberOfItems&lt;/code&gt; (5), the program go out of the &lt;code&gt;while&lt;/code&gt; loop. &lt;code&gt;currentCandidate&lt;/code&gt; contains the last number, that is to say the 5&lt;sup&gt;th&lt;/sup&gt; prime number:

{{XExample|1=&lt;span id="answer-2-4"&gt;'''Answer 3.2.4: End of the program.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="5, 26-27"&gt;
int numberOfItems = 5;
int currentItems = 0;
int currentCandidate = 1;

while (currentItems &lt; numberOfItems) {
  currentCandidate = currentCandidate + 1;
  System.out.println("Test with integer: " + currentCandidate);
 
  boolean found = true;
  for (int i = currentCandidate - 1; i &gt; 1; i--) {
   
    // Test if i is a divisor of currentCandidate
    if ((currentCandidate % i) == 0) {
      System.out.println("Not matching...");
      found = false;
      break;
    }
   
  }
 
  if (found) {
    System.out.println("Matching!");
    currentItems = currentItems + 1;
  }
}

System.out.println("Find the value: " + currentCandidate);
&lt;/syntaxhighlight&gt;}}

{{Hidden end}}
{{Hidden end}}

== Labels ==

Labels can be used to give a name to a loop. The reason to do this is so we can break out of or continue with upper-level loops from a nested loop.

Here is how to label a loop:
{| style="margin: auto;"
|'''''label name''''':'''''loop'''''
|}

To break out of or continue with a loop, use the &lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt; keyword followed by the name of the loop.

For example:
{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-36"&gt;'''Code section 3.36: A double &lt;code&gt;for&lt;/code&gt; loop.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="8"&gt;
int i, j;
int[][] nums = {
    {1, 2, 5},
    {6, 9, 7},
    {8, 3, 4}
};

Outer:
for (i = 0; i &lt; nums.length; i++) {
    for (j = 0; j &lt; nums[i].length; j++) {
        if (nums[i][j] == 9) {
            System.out.println("Found number 9 at (" + i + ", " + j + ")");
            break Outer;
        }
    }
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for code section 3.36'''
&lt;pre style="background-color:black; color:white;"&gt;
Found number 9 at (1, 1)
&lt;/pre&gt;}}
|}

You needn't worry if you don't understand all the code, but look at how the label is used to break out of the outer loop from the inner loop. However, as such a code is hard to read and maintain, it is highly recommended not to use labels.

== Try... catch blocks ==
:''See also [[Java Programming/Throwing and Catching Exceptions|Throwing and Catching Exceptions]].''

The {{java:try}}-{{java:catch}} blocks are used to catch any exceptions or other throwable objects within the code.

Here's what &lt;code&gt;try-catch&lt;/code&gt; blocks looks like:
{| style="margin: auto;"
|try {
:'''''statement&lt;sub&gt;1.1&lt;/sub&gt;'''''
:'''''statement&lt;sub&gt;1.2&lt;/sub&gt;'''''
:...
:'''''statement&lt;sub&gt;1.n&lt;/sub&gt;'''''
} catch ('''''exception&lt;sub&gt;1&lt;/sub&gt;''''') {
:'''''statement&lt;sub&gt;2.1&lt;/sub&gt;'''''
:...
:'''''statement&lt;sub&gt;2.n&lt;/sub&gt;'''''
}
|}

The [[#code-listing-6|code listing 3.6]] tries to print all the arguments that have been passed to the program. However, if there not enough arguments, it will throw an exception.

{{XCode|1=&lt;span id="code-listing-6"&gt;'''Code listing 3.6: Attempt.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public class Attempt {
  public static void main(String[] args) {
    try {
      System.out.println(args[0]);
      System.out.println(args[1]);
      System.out.println(args[2]);
      System.out.println(args[3]);
    } catch (ArrayIndexOutOfBoundsException e) {
      System.out.println("Not enough arguments");
    }
  }
}
&lt;/syntaxhighlight&gt;}}

In addition to the try and catch blocks, a {{Java:finally}} block may be present. The finally block is always executed, even if an exception is thrown. It may appear with or without a catch block, but always with a try block.

Here is what a finally block looks like:
{| style="margin: auto;"
|try {
:'''''statement&lt;sub&gt;1.1&lt;/sub&gt;'''''
:'''''statement&lt;sub&gt;1.2&lt;/sub&gt;'''''
:...
:'''''statement&lt;sub&gt;1.n&lt;/sub&gt;'''''
} catch ('''''exception&lt;sub&gt;1&lt;/sub&gt;''''') {
:'''''statement&lt;sub&gt;2.1&lt;/sub&gt;'''''
:...
:'''''statement&lt;sub&gt;2.n&lt;/sub&gt;'''''
} finally {
:'''''statement&lt;sub&gt;3.1&lt;/sub&gt;'''''
:...
:'''''statement&lt;sub&gt;3.n&lt;/sub&gt;'''''
}
|}

== Examples ==
The [[#code-listing-7|code listing 3.7]] receives a number as parameter and print its binary representation.
{{XCode|1=&lt;span id="code-listing-7"&gt;'''Code listing 3.7: GetBinary.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public class GetBinary {
    public static void main(String[] args) {
        if (args.length == 0) {
            // Print usage
            System.out.println("Usage: java GetBinary &lt;decimal integer&gt;");
            System.exit(0);
        } else {
            // Print arguments
            System.out.println("Received " + args.length + " arguments.");
            System.out.println("The arguments are:");
            for (String arg : args) {
                System.out.println("\t" + arg);
            }
        }

        int number = 0;
        String binary = "";

        // Get the input number
        try {
            number = Integer.parseInt(args[0]);
        } catch (NumberFormatException ex) {
            System.out.println("Error: argument must be a base-10 integer.");
            System.exit(0);
        }

        // Convert to a binary string
        do {
            switch (number % 2) {
                case 0: binary = '0' + binary; break;
                case 1: binary = '1' + binary; break;
            }
            number &gt;&gt;= 1;
        } while (number &gt; 0);

        System.out.println("The binary representation of " + args[0] + " is " + binary);
    }
}
&lt;/syntaxhighlight&gt;}}

The [[#code-listing-8|code listing 3.8]] is a simulation of playing a game called Lucky Sevens. It is a dice game where the player rolls two dice. If the numbers on the dice add up to seven, he wins $4. If they do not, he loses $1. The game shows how to use control flow in a program as well as the fruitlessness of gambling.

{{XCode|1=&lt;span id="code-listing-8"&gt;'''Code listing 3.8: LuckySevens.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
import java.util.*;

public class LuckySevens {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        Random random = new Random();
        String input;
        int startingCash, cash, maxCash, rolls, roll;

        // Loop until "quit" is input
        while (true) {
            System.out.print("Enter the amount of cash to start with (or \"quit\" to quit): ");

            input = in.nextLine();

            // Check if user wants to exit
            if (input.toLowerCase().equals("quit")) {
                System.out.println("\tGoodbye.");
                System.exit(0);
            }

            // Get number
            try {
                startingCash = Integer.parseInt(input);
            } catch (NumberFormatException ex) {
                System.out.println("\tPlease enter a positive integer greater than 0.");
                continue;
            }

            // You have to start with some money!
            if (startingCash &lt;= 0) {
                System.out.println("\tPlease enter a positive integer greater than 0.");
                continue;
            }

            cash = startingCash;
            maxCash = cash;
            rolls = 0;
            roll = 0;

            // Here is the game loop
            for (; cash &gt; 0; rolls++) {
               roll = random.nextInt(6) + 1;
               roll += random.nextInt(6) + 1;

                if (roll == 7)
                    cash += 4;
                else
                    cash -= 1;

                if (cash &gt; maxCash)
                    maxCash = cash;
            }

            System.out.println("\tYou start with $" + startingCash + ".\n"
                    + "\tYou peak at $" + maxCash + ".\n"
      + "\tAfter " + rolls + " rolls, you run out of cash.");
        }
    }
}
&lt;/syntaxhighlight&gt;}}

&lt;noinclude&gt;{{Programming/Navigation}}
{{Status|100%}}&lt;/noinclude&gt;</text>
      <sha1>aqrnkfpri4e8zkhwj4k6ipyeezyce6d</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Boolean expressions</title>
    <ns>0</ns>
    <id>29112</id>
    <revision>
      <id>3482101</id>
      <parentid>3295180</parentid>
      <timestamp>2018-10-30T18:42:13Z</timestamp>
      <contributor>
        <ip>192.139.27.23</ip>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6871">&lt;noinclude&gt;{{Displaytitle|title=Boolean expressions}}
{{Programming/Navigation}}
{{Java Programming/LanguageFundamentalsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

Boolean values are values that evaluate to either {{java:true}} or {{java:false}}, and are represented by the {{java:boolean}} data type.  Boolean expressions are very similar to mathematical expressions, but instead of using mathematical operators such as "+" or "-", you use comparative or boolean operators such as "==" or "!".

== Comparative operators ==

Java has several operators that can be used to compare variables.  For example, how would you tell if one variable has a greater value than another?  The answer: use the "greater-than" operator.

Here is a list of the comparative operators in Java:

* &lt;code&gt;&gt;&lt;/code&gt; : Greater than
* &lt;code&gt;&lt;&lt;/code&gt; : Less than
* &lt;code&gt;&gt;=&lt;/code&gt; : Greater than or equal to
* &lt;code&gt;&lt;=&lt;/code&gt; : Less than or equal to
* &lt;code&gt;==&lt;/code&gt; : Equal to
* &lt;code&gt;!=&lt;/code&gt; : Not equal to

To see how these operators are used, look at this example:
{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-37"&gt;'''Code section 3.37: Comparisons.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int a = 5, b = 3;
System.out.println(a &gt; b); // Value is true because a is greater than b
System.out.println(a == b); // Value is false because a does not equal b
System.out.println(a != b); // Value is true because a does not equal b
System.out.println(b &lt;= a); // Value is true because b is less than a
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XCode|1='''Output for code section 3.37'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
true
false
true
true
&lt;/pre&gt;}}
|}

Comparative operators can be used on any primitive types (except &lt;code&gt;boolean&lt;/code&gt;), but only the "equals" and "does not equal" operators work on objects.  This is because the less-than/greater-than operators cannot be applied to objects, but the equivalency operators can.

{{XNote|1=Specifically, the &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; operators test whether both variables point to the same object.  Objects will be covered later in the tutorial, in the "[[Java Programming/Classes,_Objects_and_Types|Classes, Objects, and Types]]" module.}}

== Boolean operators ==

The Java boolean operators are based on the operations of the [[Wikipedia:Boolean algebra|boolean algebra]]. The boolean operators operate directly on boolean values.

Here is a list of four common boolean operators in Java:

* &lt;code&gt;!&lt;/code&gt; : Boolean NOT
* &lt;code&gt;&amp;&amp;&lt;/code&gt; : Boolean AND
* &lt;code&gt;||&lt;/code&gt; : Boolean inclusive OR
* &lt;code&gt;^&lt;/code&gt; : Boolean exclusive XOR

The boolean NOT operator ("!") inverts the value of a boolean expression.  The boolean AND operator ("&amp;&amp;") will result in true if and only if the values on both sides of the operator are true.  The boolean inclusive OR operator ("||") will result in true if either or both of the values on the sides of the operator is true.  The boolean exclusive XOR operator ("^") will result in true if one and only one of the values on the sides of the operator is true.

To show how these operators are used, here is an example:
{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-38"&gt;'''Code section 3.38: Operands.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
boolean iMTrue = true;
boolean iMTrueToo = true;
boolean iMFalse = false;
boolean iMFalseToo = false;

System.out.println("NOT operand:");
System.out.println(!iMTrue);
System.out.println(!iMFalse);
System.out.println(!(4 &lt; 5));
System.out.println("AND operand:");
System.out.println(iMTrue &amp;&amp; iMTrueToo);
System.out.println(iMFalse &amp;&amp; iMFalseToo);
System.out.println(iMTrue &amp;&amp; iMFalse);
System.out.println(iMTrue &amp;&amp; !iMFalse);
System.out.println("OR operand:");
System.out.println(iMTrue || iMTrueToo);
System.out.println(iMFalse || iMFalseToo);
System.out.println(iMTrue || iMFalse);
System.out.println(iMFalse || !iMTrue);
System.out.println("XOR operand:");
System.out.println(iMTrue ^ iMTrueToo);
System.out.println(iMFalse ^ iMFalseToo);
System.out.println(iMTrue ^ iMFalse);
System.out.println(iMFalse ^ !iMTrue);
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XCode|1='''Output for code section 3.38'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
NOT operand:
false
true
false
AND operand:
true
false
false
true
OR operand:
true
false
true
false
XOR operand:
false
false
true
false
&lt;/pre&gt;}}
|}

Here are the truth tables for the boolean operators:

{| class="wikitable"
|-
!a !! &lt;nowiki&gt;!&lt;/nowiki&gt;a
|-
| &lt;span style="color: green;"&gt;true&lt;/span&gt; || &lt;span style="color: red;"&gt;false&lt;/span&gt;
|-
| &lt;span style="color: red;"&gt;false&lt;/span&gt; || &lt;span style="color: green;"&gt;true&lt;/span&gt;
|}

{| class="wikitable"
|-
!a !! b !! a &amp;&amp; b !! a &lt;nowiki&gt;||&lt;/nowiki&gt; b !! a &lt;nowiki&gt;^&lt;/nowiki&gt; b
|-
| &lt;span style="color: green;"&gt;true&lt;/span&gt; || &lt;span style="color: green;"&gt;true&lt;/span&gt; || &lt;span style="color: green;"&gt;true&lt;/span&gt; || &lt;span style="color: green;"&gt;true&lt;/span&gt; || &lt;span style="color: red;"&gt;false&lt;/span&gt;
|-
| &lt;span style="color: green;"&gt;true&lt;/span&gt; || &lt;span style="color: red;"&gt;false&lt;/span&gt; || &lt;span style="color: red;"&gt;false&lt;/span&gt; || &lt;span style="color: green;"&gt;true&lt;/span&gt; || &lt;span style="color: green;"&gt;true&lt;/span&gt;
|-
| &lt;span style="color: red;"&gt;false&lt;/span&gt; || &lt;span style="color: green;"&gt;true&lt;/span&gt; || &lt;span style="color: red;"&gt;false&lt;/span&gt; || &lt;span style="color: green;"&gt;true&lt;/span&gt; || &lt;span style="color: green;"&gt;true&lt;/span&gt;
|-
| &lt;span style="color: red;"&gt;false&lt;/span&gt; || &lt;span style="color: red;"&gt;false&lt;/span&gt; || &lt;span style="color: red;"&gt;false&lt;/span&gt; || &lt;span style="color: red;"&gt;false&lt;/span&gt; || &lt;span style="color: red;"&gt;false&lt;/span&gt;
|}

:''For help on simplifying complex logic, see [[Wikipedia:De Morgan's laws|De Morgan's laws]].''

In Java, boolean logic has a useful property called ''short circuiting''.  This means that expressions will only be evaluated as far as necessary.  In the expression &lt;code&gt;(a &amp;&amp; b)&lt;/code&gt;, if a is false, then b will not be evaluated because the expression will be false no matter what. Here is an example that shows that the second expression is not automatically checked:
{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-39"&gt;'''Code section 3.39: Short circuiting.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
System.out.println((4 &lt; 5) || ((10 / 0) == 2));
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XCode|1='''Output for code section 3.39'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
true
&lt;/pre&gt;}}
|}

To disable this property, you can use &lt;code&gt;&amp;&lt;/code&gt; instead of &lt;code&gt;&amp;&amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt; instead of &lt;code&gt;||&lt;/code&gt; but it's not recommended.

:''For the bitwise operations on &lt;code&gt;&amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;, see [[Java Programming/Basic arithmetic#Using bitwise operators within Java|Arithmetic expressions]].''

&lt;noinclude&gt;{{Programming/Navigation}}
{{Status|100%}}&lt;/noinclude&gt;</text>
      <sha1>tglpfnw2fuoblwrv53sscadx9nsczy7</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Variables</title>
    <ns>0</ns>
    <id>198129</id>
    <revision>
      <id>3295262</id>
      <parentid>2757025</parentid>
      <timestamp>2017-09-17T14:43:36Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="14693">&lt;noinclude&gt;{{displaytitle|title=Variables}}
{{Programming/Navigation}}
{{Java Programming/LanguageFundamentalsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;
In the Java programming language, the words '''field''' and '''variable''' are both one and the same thing. Variables are devices that are used to store data, such as a number, or a string of character data.

== Variables in Java programming ==
Java is considered as a '''strongly typed''' programming language. Thus all variables in the Java programming language ought to have a particular '''data type'''. This is either declared or inferred and the Java language only allows programs to run if they adhere to type constraints.

If you present a numeric type with data that is not numeric, say textual content, then such declarations would violate Java&amp;rsquo;s type system. This gives Java the ability of '''type safety'''. Java checks if an expression or data is encountered with an incorrect type or none at all. It then automatically flags this occurrence as an error at compile time. Most type-related errors are caught by the Java compiler, hence making a program more secure and safe once compiled completely and successfully. Some languages (such as C) define an interpretation of such a statement and use that interpretation without any warning; others (such as PL/I) define a conversion for almost all such statements and perform the conversion to complete the assignment. Some type errors can still occur at runtime because Java supports a cast operation which is a way of changing the type of one expression to another. However, Java performs run time type checking when doing such casts, so an incorrect type cast will cause a runtime exception rather than succeeding silently and allowing data corruption.

On the other hand, Java is also known as a '''hybrid language'''. While supporting [[Object Oriented Programming|object oriented programming]] (OOP), Java is not a pure OO language like [[Programming:Smalltalk|Smalltalk]] or [[Ruby Programming|Ruby]]. Instead, Java offers both object types and [[Java Programming/Primitive Types|primitive types]]. Primitive types are used for boolean, character, and numeric values and operations. This allows relatively good performance when manipulating numeric data, at the expense of flexibility. For example, you cannot subclass the primitive types and add new operations to them.

== Kinds of variables ==
In the Java programming language, there are four kinds of variables.

{{XCode|1=&lt;span id="code-listing-9"&gt;'''Code listing 3.9: ClassWithVariables.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2, 3, 5, 6"&gt;
public class ClassWithVariables {
    public int id = 0;
    public static boolean isClassUsed;

    public void processData(String parameter) {
      Object currentValue = null;
    }
}
&lt;/syntaxhighlight&gt;}}

In the [[#code-listing-9|code listing 3.9]], are examples of all four kinds of variables.
* '''Instance variables''': These are variables that are used to store the state of an object (for example, &lt;code&gt;id&lt;/code&gt;). Every object created from a class definition would have its own copy of the variable. It is valid for and occupies storage for as long as the corresponding object is in memory.
* '''Class variables''': These variables are explicitly defined within the class-level scope with a {{Java:static}} modifier (for example, &lt;code&gt;isClassUsed&lt;/code&gt;). No other variables can have a &lt;code&gt;static&lt;/code&gt; modifier attached to them. Because these variables are defined with the &lt;code&gt;static&lt;/code&gt; modifier, there would always be a single copy of these variables no matter how many times the class has been instantiated. They live as long as the class is loaded in memory.
* '''Parameters''' or '''Arguments''': These are variables passed into a method signature (for example, &lt;code&gt;parameter&lt;/code&gt;). Recall the usage of the &lt;code&gt;args&lt;/code&gt; variable in the main method. They are not attached to modifiers (i.e. &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;) and they can be used everywhere in the method. They are in memory during the execution of the method and can't be used after the method returns.
* '''Local variables''': These variables are defined and used specifically within the method-level scope (for example, &lt;code&gt;currentValue&lt;/code&gt;) but not in the method signature. They do not have any modifiers attached to it. They no longer exist after the method has returned.
{{Java/Hidden begin|title=Test your knowledge}}
'''Question 3.5''': Consider the following code:

{{XCode|1=&lt;span id="question-5"&gt;'''Question 3.5: SomeClass.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public class SomeClass {
  public static int c = 1;
  public int a = c;
  private int b;

  public void someMethod(int d) {
    d = c;
    int e;
  }
}
&lt;/syntaxhighlight&gt;}}

In the example above, we created five variables: &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt;. All these variables have the same data type &lt;code&gt;int&lt;/code&gt; (integer). However, can you tell what kind of variable each one is?
{{Java/Hidden begin|title=Answer}}
* &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are '''instance variables''';
* &lt;code&gt;c&lt;/code&gt; is a '''class variable''';
* &lt;code&gt;d&lt;/code&gt; is a '''parameter''' or '''argument'''; and,
* &lt;code&gt;e&lt;/code&gt; is a '''local variable'''.
{{Hidden end}}
{{Hidden end}}

==Creating variables==
[[Image:Java Numeric Types Memory.png|thumb|300px|A graphical representation of computer memory]]
Variables and all the information they store are kept in the computer's memory for access. Think of a computer's memory as a table of data &amp;mdash; where each cell corresponds to a variable.

Upon creating a variable, we basically create a new address space and give it a unique name. Java goes one step further and lets you define what you can place within the variable &amp;mdash; in Java parlance you call this a ''data type''. So, you essentially have to do two things in order to create a variable:
* Create a variable by giving it a unique name; and,
* Define a data type for the variable.

The following code demonstrates how a simple variable can be created. This process is known as ''variable declaration''.

{{XExample|1=&lt;span id="code-section-40"&gt;'''Code section 3.40: A simple variable declaration.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int a;
&lt;/syntaxhighlight&gt;}}

==Assigning values to variables==
Because we have provided a data type for the variable, we have a hint as to what the variable can and cannot hold. We know that &lt;code&gt;int&lt;/code&gt; (integer) data type supports numbers that are either positive or negative integers. Therefore once a variable is created, we can provide it with any integer value using the following syntax. This process is called an ''assignment operation''.

{{XExample|1=&lt;span id="code-section-41"&gt;'''Code section 3.41: Variable declaration and assignment operation (on different lines).'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int a;
a = 10;
&lt;/syntaxhighlight&gt;}}

Java provides programmers with a simpler way of combining both variable declaration and assignment operation in one line. Consider the following code:

{{XExample|1=&lt;span id="code-section-42"&gt;'''Code section 3.42: Variable declaration and assignment operation (on the same line).'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int a = 10;
&lt;/syntaxhighlight&gt;}}

== Grouping variable declarations and assignment operations ==
Consider the following code:
{{XExample|1=&lt;span id="code-section-43"&gt;'''Code section 3.43: Ungrouped declarations.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int a;
int b;
String c;
a = 10;
b = 20;
c = "some text";
&lt;/syntaxhighlight&gt;}}

There are various ways by which you can streamline the writing of this code. You can group the declarations of similar data types in one statement, for instance:
{{XExample|1=&lt;span id="code-section-44"&gt;'''Code section 3.44: Grouped declarations.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int a, b;
String c;
a = 10;
b = 20;
c = "some text";
&lt;/syntaxhighlight&gt;}}

Alternatively, you can further reduce the syntax by doing group declarations and assignments together, as such:
{{XExample|1=&lt;span id="code-section-45"&gt;'''Code section 3.45: Grouped declarations and assignments.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int a = 10, b = 20;
String c = "some text";
&lt;/syntaxhighlight&gt;}}

==Identifiers==
Although [[w:Address space|memory spaces]] have their own addresses &amp;mdash; usually a hash number such as &lt;code&gt;0xCAD3&lt;/code&gt;, etc. &amp;mdash; it is much easier to remember a variable's location in the memory if we can give it a recognizable name. '''Identifiers''' are the names we give to our variables. You can name your variable anything like &lt;code&gt;aVariable&lt;/code&gt;, &lt;code&gt;someVariable&lt;/code&gt;, &lt;code&gt;age&lt;/code&gt;, &lt;code&gt;someonesImportantData&lt;/code&gt;, etcetera. But notice: none of the names we described here has a space within it. Hence, it is pretty obvious that spaces aren't allowed in variable names. In fact, there are a lot of other things that are not allowed in variable names. The things that ''are'' allowed are:
* Characters &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;Z&lt;/code&gt; and their lower-case counterparts &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt;.
* Numbers &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt;. However, numbers should not come at the beginning of a variable's name.
* And finally, special characters that include only &lt;code&gt;$&lt;/code&gt; (dollar sign) and &lt;code&gt;_&lt;/code&gt; (underscore).

{{Java/Hidden begin|title=Test your knowledge}}
'''Question 3.6''': Which of the ones below are proper variable identifiers?
# &lt;code&gt;f_name&lt;/code&gt;
# &lt;code&gt;lastname&lt;/code&gt;
# &lt;code&gt;someones name&lt;/code&gt;
# &lt;code&gt;$SomeoneElsesName&lt;/code&gt;
# &lt;code&gt;7days&lt;/code&gt;
# &lt;code&gt;TheAnswerIs42&lt;/code&gt;
{{Java/Hidden begin|title=Answer}}
I can tell you that 3 and 5 are not the right way to do things around here, the rest are proper identifiers.
{{Hidden end}}
{{Hidden end}}

Any valid variable names might be correct but they are not always what you should be naming your variables for a few reasons as listed below:
* The name of the variable should reflect the value within them.
* The identifier should be named following the naming guidelines or conventions for doing so. We will explain that in a bit.
* The identifier shouldn't be a nonsense name like &lt;code&gt;lname&lt;/code&gt;, you should always name it properly: &lt;code&gt;lastName&lt;/code&gt; is the best way of naming a variable.

==Naming conventions for identifiers==
When naming identifiers, you need to use the following guidelines which ensure that your variables are named accurately. As we discussed earlier, we should always name our variables in a way that tells us what they hold. Consider this example:
{{XExample|1=&lt;span id="code-section-46"&gt;'''Code section 3.46: Unknown process.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int a = 24;
int b = 365;
int c = a * b;
&lt;/syntaxhighlight&gt;}}

Do you know what this program does? Well, it multiplies two values. That much you guessed right. But, do you know what those values are? Exactly, you don't. Now consider this code:
{{XExample|1=&lt;span id="code-section-47"&gt;'''Code section 3.47: Time conversion.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int age = 24;
int daysInYear = 365;
int ageInDays = age * daysInYear;
&lt;/syntaxhighlight&gt;}}

Now you can tell what's happening, can't you? However, before we continue, notice the ''case'' of the variables. If a word contains CAPITAL LETTERS, it is in '''UPPER CASE'''. If a word has small letters, it is in '''lower case'''. Both cases in a word renders it as '''mIxEd CaSe'''.

The variables we studied so far had a mixed case. When there are two or more words making up the names of a variable, you need to use a special case called the ''camel-case''. Just like the humps of a camel, your words need to stand out. Using this technique, the words &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; could be written as either &lt;code&gt;firstName&lt;/code&gt; or &lt;code&gt;FirstName&lt;/code&gt;.

The first instance, &lt;code&gt;firstName&lt;/code&gt; is what we use as the names of variables. Remember though, &lt;code&gt;firstName&lt;/code&gt; is not the same as &lt;code&gt;FirstName&lt;/code&gt; because Java is '''case-sensitive'''. Case-sensitive basically implies that the case in which you wrote one word is the case you have to call that word in when using them later on. Anything other than that is not the same as you intended. You'll know more as you progress. You can hopefully tell now why the variables you were asked to identify weren't proper.

==Literals (values)==
Now that we know how variables should be named, let us look at the values of those variables. Simple values like numbers are called ''literals''. This section shows you what literals are and how to use them. Consider the following code:
{{XExample|1=&lt;span id="code-section-48"&gt;'''Code section 3.48: Literals.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int age = 24;
long bankBalance = 20000005L;
&lt;/syntaxhighlight&gt;}}

By now, we've only seen how numbers work in assignment statements. Let's look at data types other than numbers. Characters are basically letters of the English alphabet. When writing a single character, we use single quotes to encapsulate them. Take a look at the code below:
{{XExample|1=&lt;span id="code-section-49"&gt;'''Code section 3.49: Character.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
char c = 'a';
&lt;/syntaxhighlight&gt;}}

Why, you ask? Well, the explanation is simple. If written without quotes, the system would think it's a variable identifier. That's the very distinction you have to make when differentiating between variables and their literal values. Character data types are a bit unusual. First, they can only hold a single character. What if you had to store a complete name within them, say ''John'', would you write something like:
{{XExample|1=&lt;span id="code-section-50"&gt;'''Code section 3.50: Character list.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
char firstChar = 'J';
char secondChar = 'o';
char thirdChar = 'h';
char fourthChar = 'n';
&lt;/syntaxhighlight&gt;}}

Now, that's pathetic. Thankfully, there's a data type that handles large number of characters, it's called a &lt;code&gt;String&lt;/code&gt;. A string can be initialized as follows:
{{XExample|1=&lt;span id="code-section-51"&gt;'''Code section 3.51: String.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
String name = "John";
&lt;/syntaxhighlight&gt;}}
Notice, the use of double quotation marks instead of single quotation marks. That's the only thing you need to worry about.

&lt;noinclude&gt;{{Programming/Navigation}}
{{Status|100%}}&lt;/noinclude&gt;</text>
      <sha1>8xfzcdbl3383q15e9dwoa2qlpz3ymy7</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Primitive Types</title>
    <ns>0</ns>
    <id>58021</id>
    <revision>
      <id>3491137</id>
      <parentid>3439918</parentid>
      <timestamp>2018-11-27T23:18:24Z</timestamp>
      <contributor>
        <username>Leaderboard</username>
        <id>1176064</id>
      </contributor>
      <comment>per URL requests</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="27656">&lt;noinclude&gt;{{displaytitle|title=Primitive Types}}
{{Programming/Navigation}}
{{Java Programming/LanguageFundamentalsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

Primitive types are the most basic data types available within the Java language. There are 8: {{java:boolean}}, {{java:byte}}, {{java:char}}, {{java:short}}, {{java:int}}, {{java:long}}, {{java:float}} and {{java:double}}. These types serve as the building blocks of data manipulation in Java. Such types serve only one purpose &amp;mdash; containing pure, simple values of a kind. Because these data types are defined into the Java type system by default, they come with a number of operations predefined. You can not define a new operation for such primitive types. In the Java type system, there are three further categories of primitives:
* Numeric primitives: {{java:short}}, {{java:int}}, {{java:long}}, {{java:float}} and {{java:double}}. These primitive data types hold only numeric data. Operations associated with such data types are those of [[Java Programming/Basic arithmetic|simple arithmetic]] (addition, subtraction, etc.) or of [[Java Programming/Boolean expressions|comparisons]] (is greater than, is equal to, etc.)
* Textual primitives: {{java:byte}} and {{java:char}}. These primitive data types hold characters (that can be [[Unicode]] alphabets or even numbers). Operations associated with such types are those of textual manipulation (comparing two words, joining characters to make words, etc.). However, {{java:byte}} and {{java:char}} can also support arithmetic operations.
* Boolean and null primitives: {{java:boolean}} and {{java:null}}.

All the primitive types have a fixed size. Thus, the primitive types are limited to a range of values. A smaller primitive type ({{java:byte}}) can contain less values than a bigger one ({{java:long}}).

{| class="wikitable" style="margin: auto;"
|-
! Category
! Types
! Size (bits)
! Minimum Value
! Maximum Value
! Precision
! Example
|-
!rowspan=5| Integer
|{{java:byte}}
| 8
| -128
| 127
| From +127 to -128
| &lt;code&gt;byte b = 65;&lt;/code&gt;
|-
|{{java:char}}
| 16
| 0
| 2&lt;sup&gt;16&lt;/sup&gt;-1
| All Unicode characters&lt;ref name="CITEREFSEIRuleSTR01J"&gt;According to {{cite web
|url = https://wiki.sei.cmu.edu/confluence/display/java/STR01-J.+Do+not+assume+that+a+Java+char+fully+represents+a+Unicode+code+point
|title = STR01-J. Do not assume that a Java char fully represents a Unicode code point
|publisher = Carnegie Mellon University - Software Engineering Institute
|accessdate = 27 Nov 2018}}, not all Unicode characters fit into a 16 bit representation&lt;/ref&gt;
| &lt;code&gt;char c = 'A'; &lt;br /&gt;char c = 65;&lt;/code&gt;
|-
|{{java:short}}
| 16
| -2&lt;sup&gt;15&lt;/sup&gt;
| 2&lt;sup&gt;15&lt;/sup&gt;-1
| From +32,767 to -32,768
| &lt;code&gt;short s = 65;&lt;/code&gt;
|-
|{{java:int}}
| 32
| -2&lt;sup&gt;31&lt;/sup&gt;
| 2&lt;sup&gt;31&lt;/sup&gt;-1
| From +2,147,483,647 to -2,147,483,648
| &lt;code&gt;int i = 65;&lt;/code&gt;
|-
|{{java:long}}
| 64
| -2&lt;sup&gt;63&lt;/sup&gt;
| 2&lt;sup&gt;63&lt;/sup&gt;-1
| From +9,223,372,036,854,775,807 to -9,223,372,036,854,775,808
| &lt;code&gt;long l = 65L;&lt;/code&gt;
|-
!rowspan=2| Floating-point
|{{java:float}}
| 32
| 2&lt;sup&gt;-149&lt;/sup&gt;
| (2-2&lt;sup&gt;-23&lt;/sup&gt;)·2&lt;sup&gt;127&lt;/sup&gt;
| From 3.402,823,5&amp;nbsp;E+38 to 1.4&amp;nbsp;E-45
| &lt;code&gt;float f = 65f;&lt;/code&gt;
|-
|{{java:double}}
| 64
| 2&lt;sup&gt;-1074&lt;/sup&gt;
| (2-2&lt;sup&gt;-52&lt;/sup&gt;)·2&lt;sup&gt;1023&lt;/sup&gt;
| From 1.797,693,134,862,315,7&amp;nbsp;E+308 to 4.9&amp;nbsp;E-324
| &lt;code&gt;double d = 65.55;&lt;/code&gt;
|-
!rowspan=2| Other
|{{java:boolean}}
| --
| --
| --
| false, true
| &lt;code&gt;boolean b = true;&lt;/code&gt;
|-
|{{java:void}}
| --
| --
| --
| --
| --
|-
|}

Integer primitive types silently overflow:

{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-52"&gt;'''Code section 3.52: Several operators.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3"&gt;
int i = Integer.MAX_VALUE;
System.out.println(i);
i = i + 1;
System.out.println(i);
System.out.println(Integer.MIN_VALUE);
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XCode|1='''Console for Code section 3.52'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
2147483647
-2147483648
-2147483648
&lt;/pre&gt;}}
|}

As Java is strongly typed, you can't assign a floating point number (a number with a decimal point) to an integer variable:
{{XWarning|1=&lt;span id="code-section-53" style="color: red;"&gt;'''Code section 3.53: Setting a floating point number as a value to an &lt;code&gt;int&lt;/code&gt; (integer) type.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int age;
age = 10.5;
&lt;/syntaxhighlight&gt;}}

A primitive type should be set by an appropriate value. The primitive types can be initialized with a literal. Most of the literals are primitive type values, except [[Java Programming/Literals/String Literals|String Literals]], which are instance of the {{java:String}} class.

== Numbers in computer science ==
Programming may not be as trivial or boring as just crunching huge numbers any more. However, huge chunks of code written in any programming language today, let alone Java, obsessively deal with numbers, be it churning out huge prime numbers,&lt;ref name="note-1"&gt;As of edit (11 December 2013), the [[w:Great Internet Mersenne Prime Search|Great Internet Mersenne Prime Search]] project has so far identified the largest prime number as being 17,425,170 digits long. Prime numbers are valuable to cryptologists as the bigger the number, the securer they can make their data encryption logic using that particular number.&lt;/ref&gt; or just calculating a cost of emission from your scooter. In 1965, [[w:Gemini 5|Gemini V]] space mission escaped a near-fatal accident caused by a programming error.&lt;ref name="note-2"&gt;Gemini 5 landed 130 kilometers short of its planned Pacific Ocean landing point due to a software error. The Earth's rotation rate had been programmed as one revolution per [[w:solar time|solar day]] instead of the correct value, one revolution per [[w:sidereal time|sidereal day]].&lt;/ref&gt; Again in 1979, a computer program overestimated the ability of five nuclear reactors to withstand earthquakes; the plants shut down temporarily.&lt;ref name="note-3"&gt;A program used in their design used an arithmetic sum of variables when it should have used the sum of their absolute values. (Evars Witt, "''The Little Computer and the Big Problem''", AP Newswire, 16 March 1979. See also Peter Neumann, "''An Editorial on Software Correctness and the Social Process''" Software Engineering Notes, Volume 4(2), April 1979, page 3)&lt;/ref&gt; There is one thing common to both these programming errors: the subject data, being computed at the time the errors occurred, was numeric. Out of past experience, Java came bundled with revised type checking for numeric data and put significant emphasis on correctly identifying different types of it. You must recognise the importance of numeric data when it comes to programming.

Numbers are stored in memory using a binary system. The memory is like a grid of cells:
{| class="wikitable" style="margin: auto;"
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
|}

Each cell can contain a ''binary digit'' (shortened to ''bit''), that is to say, zero or one:

{| class="wikitable" style="margin: auto;"
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
|}

Actually, each cell '''does''' contain a binary digit, as one bit is roughly equivalent to &lt;code&gt;1&lt;/code&gt; and an empty cell in the memory signifies &lt;code&gt;0&lt;/code&gt;. A single binary digit can only hold two possible values: a zero or a one.

{| class="wikitable" style="margin: auto; border: 0px;"
| colspan="8" style="border: 0px; background-color: white; text-align: center;"| ''Memory state''
| style="border: 0px; background-color: white;"|
| style="border: 0px; background-color: white; text-align: center;"| ''Gives''
|-
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white; text-align: center;"| &amp;rarr;
| style="border: 0px; background-color: white; text-align: center;"| 0
|-
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
| &amp;nbsp;&amp;nbsp;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white; text-align: center;"| &amp;rarr;
| style="border: 0px; background-color: white; text-align: center;"| 1
|}

Multiple bits held together can hold multiple permutations &amp;mdash; 2 bits can hold 4 possible values, 3 can hold 8, and so on. For instance, the maximum number 8 bits can hold (&lt;code&gt;11111111&lt;/code&gt; in binary) is &lt;code&gt;255&lt;/code&gt; in the decimal system. So, the numbers from 0 to 255 can fit within 8 bits.
{| class="wikitable" style="margin: auto; border: 0px;"
| colspan="8" style="border: 0px; background-color: white; text-align: center;"| ''Memory state''
| style="border: 0px; background-color: white;"|
| style="border: 0px; background-color: white; text-align: center;"| ''Gives''
|-
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white; text-align: center;"| &amp;rarr;
| style="border: 0px; background-color: white; text-align: center;"| 0
|-
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white; text-align: center;"| &amp;rarr;
| style="border: 0px; background-color: white; text-align: center;"| 1
|-
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white; text-align: center;"| &amp;rarr;
| style="border: 0px; background-color: white; text-align: center;"| 2
|-
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white; text-align: center;"| &amp;rarr;
| style="border: 0px; background-color: white; text-align: center;"| 3
|-
| colspan="8" style="text-align: center;" | &lt;br/&gt;...&lt;br/&gt;
| style="border: 0px; background-color: white; text-align: center;"| ...
|-
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white; text-align: center;"| &amp;rarr;
| style="border: 0px; background-color: white; text-align: center;"| 255
|}

It is all good, but this way, we can only host positive numbers (or unsigned integers). They are called ''unsigned integers''. Unsigned integers are whole number values that are all positive and do not attribute to negative values. For this very reason, we would ask one of the 8 bits to hold information about the sign of the number (positive or negative). This leaves us with just 7 bits to actually count out a number. The maximum number that these 7 bits can hold (&lt;code&gt;1111111&lt;/code&gt;) is &lt;code&gt;127&lt;/code&gt; in the decimal system.

{| style="width: 100%;"
| style="border: 0px; background-color: white; text-align: center; font-size:200%;"| ''Positive numbers''
| style="border: 0px; background-color: white; text-align: center; font-size:200%;"| ''Negative numbers''
|-
|
{| class="wikitable" style="margin: auto; border: 0px;"
| colspan="9" style="border: 0px; background-color: white; text-align: center;"| ''Memory state''
| style="border: 0px; background-color: white;"|
| style="border: 0px; background-color: white; text-align: center;"| ''Gives''
|-
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white;"|
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white; text-align: center;"| &amp;rarr;
| style="border: 0px; background-color: white; text-align: center;"| 0
|-
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white;"|
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white; text-align: center;"| &amp;rarr;
| style="border: 0px; background-color: white; text-align: center;"| 1
|-
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white;"|
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white; text-align: center;"| &amp;rarr;
| style="border: 0px; background-color: white; text-align: center;"| 2
|-
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white;"|
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white; text-align: center;"| &amp;rarr;
| style="border: 0px; background-color: white; text-align: center;"| 3
|-
| style="text-align: center;" | &lt;br/&gt;...&lt;br/&gt;
| style="border: 0px; background-color: white;"|
| colspan="7" style="text-align: center;" | &lt;br/&gt;...&lt;br/&gt;
| style="border: 0px; background-color: white; text-align: center;"| ...
|-
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white;"|
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white; text-align: center;"| &amp;rarr;
| style="border: 0px; background-color: white; text-align: center;"| 127
|}

|
{| class="wikitable" style="margin: auto; border: 0px;"
| colspan="9" style="border: 0px; background-color: white; text-align: center;"| ''Memory state''
| style="border: 0px; background-color: white;"|
| style="border: 0px; background-color: white; text-align: center;"| ''Gives''
|-
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white;"|
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white; text-align: center;"| &amp;rarr;
| style="border: 0px; background-color: white; text-align: center;"| -128
|-
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white;"|
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white; text-align: center;"| &amp;rarr;
| style="border: 0px; background-color: white; text-align: center;"| -127
|-
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white;"|
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white; text-align: center;"| &amp;rarr;
| style="border: 0px; background-color: white; text-align: center;"| -126
|-
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white;"|
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white; text-align: center;"| &amp;rarr;
| style="border: 0px; background-color: white; text-align: center;"| -125
|-
| style="text-align: center;" | &lt;br/&gt;...&lt;br/&gt;
| style="border: 0px; background-color: white;"|
| colspan="7" style="text-align: center;" | &lt;br/&gt;...&lt;br/&gt;
| style="border: 0px; background-color: white; text-align: center;"| ...
|-
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white;"|
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| &amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;
| style="border: 0px; background-color: white; text-align: center;"| &amp;rarr;
| style="border: 0px; background-color: white; text-align: center;"| -1
|}
|}

Altogether, using this method, 8 bits can hold numbers ranging from &lt;code&gt;-128&lt;/code&gt; to &lt;code&gt;127&lt;/code&gt; (including zero) &amp;mdash; a total of 256 numbers. Not a bad pay-off one might presume. The opposite to an unsigned integer is a ''signed integer'' that have the capability of holding both positive and negative values.

But, what about larger numbers. You would need significantly more bits to hold larger numbers. That's where Java's numeric types come into play. Java has multiple numeric types &amp;mdash; their size dependent on the number of bits that are at play.

In Java, numbers are dealt with using data types specially formulated to host numeric data. But before we dive into these types, we must first set some concepts in stone. Just like you did in high school (or even primary school), numbers in Java are placed in clearly distinct groups and systems. As you'd already know by now, number systems includes groups like the ''integer'' numbers (0, 1, 2 ... ∞); ''negative integers'' (0, -1, -2 ... -∞) or even ''real'' and ''rational'' numbers ([[w:Pi|value of Pi]], ¾, 0.333~, etcetera). Java simply tends to place these numbers in two distinct groups, '''integers''' (-∞ ... 0 ... ∞) and '''floating point''' numbers (any number with decimal points or fractional representation). For the moment, we would only look into integer values as they are easier to understand and work with.

== Integer types in Java ==
With what we have learned so far, we will identify the different types of signed integer values that can be created and manipulated in Java. Following is a table of the most basic numeric types: integers. As we have discussed earlier, the data types in Java for integers caters to both positive and negative values and hence are '''signed numeric types'''. The size in bits for a numeric type determines what its minimum and maximum value would be. If in doubt, one can always calculate these values.

Lets see how this new found knowledge of the basic integer types in Java fits into the picture. Say, you want to numerically manipulate the days in a year &amp;mdash; all 365 days. What type would you use? Since the data type &lt;code&gt;byte&lt;/code&gt; only goes up to 127, would you risk giving it a value greater than its allowed maximum. Such decisions might save you from dreaded errors that might occur out of the programmed code. A much more sensible choice for such a numeric operation might be a &lt;code&gt;short&lt;/code&gt;. Oh, why couldn't they make just one data type to hold all kinds of numbers? Wouldn't you ask that question? Well, let's explore why.

When you tell a program you need to use an integer, say even a &lt;code&gt;byte&lt;/code&gt;, the Java program allocates a space in the memory. It allocates whole 8 bits of memory. Where it wouldn't seem to matter for today's memory modules that have place for almost a dozen trillion such bits, it matters in other cases. Once allocated that part of the memory gets used and can only be claimed back after the operation is finished. Consider a complicated Java program where the only data type you'd be using would be &lt;code&gt;long&lt;/code&gt; integers. What happens when there's no space for more memory allocation jobs? Ever heard of the [[w:Stack overflow|Stack Overflow error]]s. That's exactly what happens &amp;mdash; your memory gets completely used up and fast. So, choose your data types with extreme caution.

Enough talk, let's see how you can create a numeric type. A numeric type begins with the type's name (&lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, etc.) and then provides with a name for the allocated space in the memory. Following is how it's done. Say, we need to create a variable to hold the number of days in a year.

{{XExample|1=&lt;span id="code-section-54"&gt;'''Code section 3.54: Days in a year.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
short daysInYear = 365;
&lt;/syntaxhighlight&gt;}}

Here, &lt;code&gt;daysInYear&lt;/code&gt; is the name of the variable that holds &lt;code&gt;365&lt;/code&gt; as its value, while &lt;code&gt;short&lt;/code&gt; is the data type for that particular value. Other uses of integer data types in Java might see you write code such as this given below:
{{XExample|1=&lt;span id="code-section-55"&gt;'''Code section 3.55: Integer data types in Java.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
byte maxByte = 127;
short maxShort = 32767;
int maxInt = 2147483647;
long maxLong = 9223372036854775807L;
&lt;/syntaxhighlight&gt;}}

== Integer numbers and floating point numbers ==
The data types that one can use for integer numbers are &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt; but when it comes to floating point numbers, we use &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt;. Now that we know that, we can modify the code in the [[#code-section-53|code section 3.53]] as:

{{XExample|1=&lt;span id="code-section-56"&gt;'''Code section 3.56: Correct floating point declaration and assignment.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
double age = 10.5;
&lt;/syntaxhighlight&gt;}}
Why not &lt;code&gt;float&lt;/code&gt;, you say? If we'd used a &lt;code&gt;float&lt;/code&gt;, we would have to append the number with a &lt;code&gt;f&lt;/code&gt; as a suffix, so &lt;code&gt;10.5&lt;/code&gt; should be &lt;code&gt;10.5f&lt;/code&gt; as in:

{{XExample|1=&lt;span id="code-section-57"&gt;'''Code section 3.57: The correct way to define floating point numbers of type &lt;code&gt;float&lt;/code&gt;.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
float age = 10.5f;
&lt;/syntaxhighlight&gt;}}

Floating-point math never throws exceptions. Dividing a non-zero value by &lt;code&gt;0&lt;/code&gt; equals &lt;code&gt;infinity&lt;/code&gt;. Dividing a non-infinite value by &lt;code&gt;infinity&lt;/code&gt; equals &lt;code&gt;0&lt;/code&gt;.

{{Java/Hidden begin|title=Test your knowledge}}
'''Question 3.7''': Consider the following code:

{{XExample|1=&lt;span id="question-7"&gt;'''Question 3.7: Primitive type assignments.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="5"&gt;
...

a = false;
b = 3.2;
c = 35;
d = -93485L;
e = 'q';
&lt;/syntaxhighlight&gt;}}

These are five variables. There are a &lt;code&gt;long&lt;/code&gt;, a &lt;code&gt;byte&lt;/code&gt;, a &lt;code&gt;char&lt;/code&gt;, a &lt;code&gt;double&lt;/code&gt; and a &lt;code&gt;boolean&lt;/code&gt;. Retrieve the type of each one.
{{Java/Hidden begin|title=Answer}}
{{XExample|1=&lt;span id="answer-7"&gt;'''Answer 3.7: Primitive type assignments and declarations.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1-5"&gt;
boolean a;
double b;
byte c;
long d;
char e;

a = false;
b = 3.2;
c = 35;
d = -93485L;
e = 'q';
&lt;/syntaxhighlight&gt;}}
* &lt;code&gt;a&lt;/code&gt; can only be the &lt;code&gt;boolean&lt;/code&gt; because only a boolean can handle boolean values.
* &lt;code&gt;e&lt;/code&gt; can only be the &lt;code&gt;char&lt;/code&gt; because only a char can contain a character.
* &lt;code&gt;b&lt;/code&gt; can only be the &lt;code&gt;double&lt;/code&gt; because only a double can contain a decimal number here.
* &lt;code&gt;d&lt;/code&gt; is the &lt;code&gt;long&lt;/code&gt; because a &lt;code&gt;byte&lt;/code&gt; can not contain such a low value.
* &lt;code&gt;c&lt;/code&gt; is the remaining one so it is the &lt;code&gt;byte&lt;/code&gt;.

{{Hidden end}}
{{Hidden end}}

== Data conversion (casting) ==
Data conversion (casting) can happen between two primitive types. There are two kinds of casting:
* Implicit: casting operation is not required; the magnitude of the numeric value is always preserved. However, ''precision'' may be lost when converting from integer to floating point types
* Explicit: casting operation required; the magnitude of the numeric value may not be preserved

{{XExample|1=&lt;span id="code-section-58"&gt;'''Code section 3.58: Implicit casting (int is converted to long, '''casting''' is not needed).'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1 highlight="2"&gt;
int  i = 65;
long l = i;
&lt;/syntaxhighlight&gt;}}

{{XExample|1=&lt;span id="code-section-59"&gt;'''Code section 3.59: Explicit casting (long is converted to int, '''casting''' is needed).'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2"&gt;
long l = 656666L;
int  i = (int) l;
&lt;/syntaxhighlight&gt;}}

The following table shows the conversions between primitive types, it shows the casting operation for explicit conversions:
{| class="wikitable" style="margin: auto;"
|-
!
! from {{java:byte}}
! from {{java:char}}
! from {{java:short}}
! from {{java:int}}
! from {{java:long}}
! from {{java:float}}
! from {{java:double}}
! from {{java:boolean}}
|-
! to {{java:byte}}
| -
| (byte)
| (byte)
| (byte)
| (byte)
| (byte)
| (byte)
| style="background-color: #aaa;" | N/A
|-
! to {{java:char}}
|
| -
| (char)
| (char)
| (char)
| (char)
| (char)
| style="background-color: #aaa;" | N/A
|-
! to {{java:short}}
|
| (short)
| -
| (short)
| (short)
| (short)
| (short)
| style="background-color: #aaa;" | N/A
|-
! to {{java:int}}
|
|
|
| -
| (int)
| (int)
| (int)
| style="background-color: #aaa;" | N/A
|-
! to {{java:long}}
|
|
|
|
| -
| (long)
| (long)
| style="background-color: #aaa;" | N/A
|-
! to {{java:float}}
|
|
|
|
|
| -
| (float)
| style="background-color: #aaa;" | N/A
|-
! to {{java:double}}
|
|
|
|
|
|
| -
| style="background-color: #aaa;" | N/A
|-
! to {{java:boolean}}
| style="background-color: #aaa;" | N/A
| style="background-color: #aaa;" | N/A
| style="background-color: #aaa;" | N/A
| style="background-color: #aaa;" | N/A
| style="background-color: #aaa;" | N/A
| style="background-color: #aaa;" | N/A
| style="background-color: #aaa;" | N/A
| -
|-
|}

Unlike C, C++ and similar languages, Java can't represent &lt;code&gt;false&lt;/code&gt; as &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; and can't represent &lt;code&gt;true&lt;/code&gt; as non-zero. Java can't cast from boolean to a non-boolean primitive data type, or vice versa.


For non primitive types:

{| class="wikitable sortable"
!  !! to Integer !! to Float !! to Double !! to String !! to Array
|-
! Integer
! -
| (float)x
| (double)x &lt;br&gt; x.doubleValue()
| x.toString() &lt;br&gt; Float.toString(x)
| new int[] {x}
|-
! Float
| &lt;small&gt;java.text.DecimalFormat("#").format(x)&lt;/small&gt;
! -
| (double)x
| x.toString()
| new float[] {x}
|-
! Double
| &lt;small&gt;java.text.DecimalFormat("#").format(x)&lt;/small&gt;
| &lt;small&gt;java.text.DecimalFormat("#").format(x)&lt;/small&gt;
! -
| x.toString()
| new double[] {x}
|-
! String
| Integer.parseInt(x)
| Float.parseFloat(x)
| Double.parseDouble(x)
! -
| new String[] {x}
|-
! Array
| x[0]
| x[0]
| x[0]
| Arrays.toString(x)
! -
|}

==Notes==
&lt;small&gt;{{Reflist|3}}&lt;/small&gt;

&lt;noinclude&gt;{{Status|100%}}</text>
      <sha1>kuu4tp64zsnz4bm5kr7aos7zpdlbg7k</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Arithmetic expressions</title>
    <ns>0</ns>
    <id>137889</id>
    <revision>
      <id>3295175</id>
      <parentid>3223241</parentid>
      <timestamp>2017-09-17T14:40:49Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="10631">&lt;noinclude&gt;{{displaytitle|title=Arithmetic expressions}}
{{Programming/Navigation}}
{{Java Programming/LanguageFundamentalsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;
In order to do arithmetic in Java, one must first declare at least one variable. Typically one declares a variable and assigns it a value before any arithmetic is done. Here's an example of declaring an integer variable:

{{XExample|1=&lt;span id="code-section-59"&gt;'''Code section 3.59: Variable assignation.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int x = 5;
&lt;/syntaxhighlight&gt;}}

After creating a variable, one can manipulate its value by using Java's operators: &lt;code&gt;+&lt;/code&gt; (addition), &lt;code&gt;-&lt;/code&gt; (subtraction), &lt;code&gt;*&lt;/code&gt; (multiplication), &lt;code&gt;/&lt;/code&gt; (integer division), &lt;code&gt;%&lt;/code&gt; ([[w:Modulo operation|modulo or remainder]]), &lt;code&gt;++&lt;/code&gt; (pre- &amp; postincrement by one), &lt;code&gt;--&lt;/code&gt; (pre- &amp; postdecrement by one).
{| style="width: 100%;"
|valign="top"|{{XCode|1=&lt;span id="code-listing-10"&gt;'''Code listing 3.10: Operators.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="9, 15, 21, 27, 33, 39, 45, 51, 57"&gt;
public class Operators {
  public static void main(String[] args) {
    int x = 5;
    System.out.println("x = " + x);
    System.out.println();
   
    System.out.println("--- Addition             ---");
    x = 5;
    System.out.println("x + 2 = " + (x + 2));
    System.out.println("x = " + x);
    System.out.println();
   
    System.out.println("--- Subtraction          ---");
    x = 5;
    System.out.println("x - 4 = " + (x - 4));
    System.out.println("x = " + x);
    System.out.println();
   
    System.out.println("--- Multiplication       ---");
    x = 5;
    System.out.println("x * 3 = " + (x * 3));
    System.out.println("x = " + x);
    System.out.println();
   
    System.out.println("--- (Integer) Division   ---");
    x = 5;
    System.out.println("x / 2 = " + (x / 2));
    System.out.println("x = " + x);
    System.out.println();
   
    System.out.println("--- Modulo (Remainder)   ---");
    x = 5;
    System.out.println("x % 2 = " + (x % 2));
    System.out.println("x = " + x);
    System.out.println();
   
    System.out.println("--- Preincrement by one  ---");
    x = 5;
    System.out.println("++x   = " + (++x  ));
    System.out.println("x = " + x);
    System.out.println();
   
    System.out.println("--- Predecrement by one  ---");
    x = 5;
    System.out.println("--x   = " + (--x  ));
    System.out.println("x = " + x);
    System.out.println();
   
    System.out.println("--- Postincrement by one ---");
    x = 5;
    System.out.println("x++   = " + (x++  ));
    System.out.println("x = " + x);
    System.out.println();
   
    System.out.println("--- Postdecrement by one ---");
    x = 5;
    System.out.println("x--   = " + (x--  ));
    System.out.println("x = " + x);
    System.out.println();
  }
}&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Console for Code listing 3.10'''
&lt;pre style="background-color:#000; color:#fff;"&gt;

x = 5

--- Addition             ---
x + 2 = 7
x = 5

--- Subtraction          ---
x - 4 = 1
x = 5

--- Multiplication       ---
x * 3 = 15
x = 5

--- (Integer) Division   ---
x / 2 = 2
x = 5

--- Modulo (Remainder)   ---
x % 2 = 1
x = 5

--- Preincrement by one  ---
++x   = 6
x = 6

--- Predecrement by one  ---
--x   = 4
x = 4

--- Postincrement by one ---
x++   = 5
x = 6

--- Postdecrement by one ---
x--   = 5
x = 4
&lt;/pre&gt;}}
|}

The division operator rounds towards zero: &lt;code&gt;5/2&lt;/code&gt; is 2, and &lt;code&gt;-5/2&lt;/code&gt; is -2.
The remainder operator has the same sign as the left operand; it is defined such that &lt;code&gt;((a/b)*b) + (a%b)&lt;/code&gt; is always equal to a.
The preincrement, predecrement, postincrement, and postdecrement operators are special: they also change the value of the variable, by adding or subtracting one. The only difference is that preincrement/decrement returns the new value of the variable; postincrement returns the original value of the variable.

{{Java/Hidden begin|title=Test your knowledge}}
'''Question 3.8''': Consider the following code:

{{XCode|1=&lt;span id="question-8"&gt;'''Question 3.8: Question8.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public class Question8 {
  public static void main(String[] args) {
    int x = 10;
    x = x + 10;
    x = 2 * x;
    x = x - 19;
    x = x / 3;
    System.out.println(x);
  }
}
&lt;/syntaxhighlight&gt;}}

What will be printed in the standard output?
{{Java/Hidden begin|title=Answer}}
{{XConsole|1='''Output for Question 3.8'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
7
&lt;/pre&gt;}}
&lt;code&gt;int x = 10;&lt;/code&gt; =&gt; 10&lt;br/&gt;
&lt;code&gt;x = x + 10;&lt;/code&gt; =&gt; 20&lt;br/&gt;
&lt;code&gt;x = 2 * x;&lt;/code&gt; =&gt; 40&lt;br/&gt;
&lt;code&gt;x = x - 19;&lt;/code&gt; =&gt; 21&lt;br/&gt;
&lt;code&gt;x = x / 3;&lt;/code&gt; =&gt; 7&lt;br/&gt;
{{Hidden end}}
{{Hidden end}}

When using several operators in the same expression, one must consider Java's order of precedence. Java uses the standard PEMDAS (Parenthesis, Exponents, Multiplication and Division, Addition and Subtraction) order. When there are multiple instances of the same precedence, Java reads from left to right. Consider what the output of the following code would be:

{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-60"&gt;'''Code section 3.60: Several operators.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
System.out.println(10*5 + 100/10 - 5 + 7%2);
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Console for Code section 3.60'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
56
&lt;/pre&gt;}}
|}

The following chart shows how Java would compute this expression:

{{Java/Illustration
|number=3.1
|caption=Computation of an arithmetic expression in the Java programming language
|image=[[File:Java Computation of Arithmetic Expression.svg|center]]
}}

Besides performing mathematical functions, there are also operators to assign numbers to variables (each example again uses the variable initialized as &lt;code&gt;x = 5&lt;/code&gt;):

{| style="width: 100%;"
|valign="top"|{{XCode|1=&lt;span id="code-listing-11"&gt;'''Code listing 3.11: Assignments.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="4, 8, 12, 16, 20"&gt;
public class Assignments {
  public static void main(String[] args) {
    int x = 5;
    x = 3;
    System.out.println("Assignment                                       (x = 3) : " + x);

    x = 5;
    x += 5;
    System.out.println("Assign x plus another integer to itself          (x += 5): " + x);

    x = 5;
    x -= 4;
    System.out.println("Assign x minus another integer to itself         (x -= 4): " + x);

    x = 5;
    x *= 6;
    System.out.println("Assign x multiplied by another integer to itself (x *= 6): " + x);

    x = 5;
    x /= 5;
    System.out.println("Assign x divided by another integer to itself    (x /= 5): " + x);
  }
}&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Console for Code listing 3.11'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
Assignment                                       (x = 3) : 3
Assign x plus another integer to itself          (x += 5): 10
Assign x minus another integer to itself         (x -= 4): 1
Assign x multiplied by another integer to itself (x *= 6): 30
Assign x divided by another integer to itself    (x /= 5): 1
&lt;/pre&gt;}}
|}

== Using bitwise operators within Java ==

Java has besides arithmetic operators a set of bit operators to manipulate the bits in a number, and a set of logical operators. The bitwise logical operators are

{| class="wikitable"
|-
! Operator
! Function
! Value of&lt;br/&gt;x before
! Example&lt;br/&gt;input
! Example&lt;br/&gt;output
! Value of&lt;br/&gt;x after
|-
| style="text-align:center;" | &lt;code&gt;&amp;&lt;/code&gt;
| Bitwise AND
| style="text-align:right;" | 7
| &lt;code&gt;x&amp;27&lt;/code&gt;
| style="text-align:right;" | 3
| style="text-align:right;" | 7
|-
| style="text-align:center;" | &lt;code&gt;|&lt;/code&gt;
| Bitwise OR
| style="text-align:right;" | 7
| &lt;code&gt;x&lt;nowiki&gt;|&lt;/nowiki&gt;27&lt;/code&gt;
| style="text-align:right;" | 31
| style="text-align:right;" | 7
|-
| style="text-align:center;" | &lt;code&gt;^&lt;/code&gt;
| Bitwise XOR
| style="text-align:right;" | 7
| &lt;code&gt;x^27&lt;/code&gt;
| style="text-align:right;" | 28
| style="text-align:right;" | 7
|-
| style="text-align:center;" | &lt;code&gt;~&lt;/code&gt;
| Bitwise inversion
| style="text-align:right;" | 7
| &lt;code&gt;~x&lt;/code&gt;
| style="text-align:right;" | -8
| style="text-align:right;" | 7
|}

Besides these logical bitwise functions, there are also operators to assign numbers to variables (&lt;code&gt;x = -5&lt;/code&gt;):

{| class="wikitable"
|-
! Operator
! Function
! Example&lt;br/&gt;input
! Example output
|-
| style="text-align:center;" | &lt;code&gt;&amp;=&lt;/code&gt;
| Assign &lt;code&gt;x&lt;/code&gt; bitwisely ANDed with another value to itself
| &lt;code&gt;x &amp;= 3&lt;/code&gt;
| style="text-align:right;" | 3
|-
| style="text-align:center;" | &lt;code&gt;|=&lt;/code&gt;
| Assign &lt;code&gt;x&lt;/code&gt; bitwisely ORed with another value to itself
| &lt;code&gt;x &lt;/code&gt;&lt;nowiki&gt;|&lt;/nowiki&gt;&lt;code&gt;= 3&lt;/code&gt;
| style="text-align:right;" | -5
|-
| style="text-align:center;" | &lt;code&gt;^=&lt;/code&gt;
| Assign &lt;code&gt;x&lt;/code&gt; bitwisely XORed with another value to itself
| &lt;code&gt;x ^= 3&lt;/code&gt;
| style="text-align:right;" | -8
|-
| style="text-align:center;" | &lt;code&gt; &lt;&lt;=&lt;/code&gt;
| Assign &lt;code&gt;x&lt;/code&gt; divided by another integer to itself
| &lt;code&gt;x &lt;&lt;= 1&lt;/code&gt;
| style="text-align:right;" | -10
|-
| style="text-align:center;" | &lt;code&gt; &gt;&gt;=&lt;/code&gt;
| Assign &lt;code&gt;x&lt;/code&gt; bitwisely negated with another value to itself
| &lt;code&gt;x &gt;&gt;= 1&lt;/code&gt;
| style="text-align:right;" | -3
|-
| style="text-align:center;" | &lt;code&gt; &gt;&gt;&gt;=&lt;/code&gt;
| Assign &lt;code&gt;x&lt;/code&gt; bitwisely negated with another value to itself
| &lt;code&gt;x &gt;&gt;&gt;= 1&lt;/code&gt;
| style="text-align:right;" | 2,305,843,009,213,693,949 (64 bit)
|}

The shift operators are used to shift the bits to the left or right, which is also a quick way to multiply/divide by two:

{| class="wikitable"
|-
! Operator
! Function
! Value of&lt;br/&gt;x before
! Example&lt;br/&gt;input
! Example output
! Value of&lt;br/&gt;x after
|-
| style="text-align:center;" | &lt;code&gt; &lt;&lt; &lt;/code&gt;
| Logical shift left
| style="text-align:right;" | -15
| &lt;code&gt;x &lt;&lt; 2&lt;/code&gt;
| style="text-align:right;" | -60
| style="text-align:right;" | -15
|-
| style="text-align:center;" | &lt;code&gt; &gt;&gt; &lt;/code&gt;
| Arithmetic shift right
| style="text-align:right;" | -15
| &lt;code&gt;x &gt;&gt; 3&lt;/code&gt;
| style="text-align:right;" | -2
| style="text-align:right;" | -15
|-
| style="text-align:center;" | &lt;code&gt; &gt;&gt;&gt; &lt;/code&gt;
| Logical shift right
| style="text-align:right;" | -15
| &lt;code&gt;x &gt;&gt;&gt; 3&lt;/code&gt;
| style="text-align:right;" | 2,305,843,009,213,693,937 (64 bit)
| style="text-align:right;" | -15
|}

&lt;noinclude&gt;{{Programming/Navigation}}
{{Status|100%}}&lt;/noinclude&gt;</text>
      <sha1>mbp0tbh1yzrx8wafqewdy8e1jm2qpbe</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Literals</title>
    <ns>0</ns>
    <id>58527</id>
    <revision>
      <id>3515364</id>
      <parentid>3515309</parentid>
      <timestamp>2019-02-09T16:05:32Z</timestamp>
      <contributor>
        <username>Atcovi</username>
        <id>1015207</id>
      </contributor>
      <minor/>
      <comment>[[WB:REVERT|Reverted]] edits by [[Special:Contributions/2405:205:2416:D0E5:0:0:17A1:A5|2405:205:2416:D0E5:0:0:17A1:A5]] ([[User talk:2405:205:2416:D0E5:0:0:17A1:A5|talk]]) to last version by WOSlinker</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="12191">&lt;noinclude&gt;{{Displaytitle|title=Literals}}
{{Programming/Navigation}}
{{Java Programming/LanguageFundamentalsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;
Java '''Literals''' are syntactic representations of boolean, character, numeric, or string data. Literals provide a means of expressing specific values in your program. For example, in the following statement, an integer variable named &lt;code&gt;count&lt;/code&gt; is declared and assigned an integer value. The literal &lt;code&gt;'''0'''&lt;/code&gt; represents, naturally enough, the value zero.

{{XExample|1=&lt;span id="code-section-61"&gt;'''Code section 3.61: Numeric literal.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int count = 0;
&lt;/syntaxhighlight&gt;}}

The [[#code-section-62|code section 3.62]] contains two number literals followed by two boolean literals at line 1, one string literal followed by one number literal at line 2, and one string literal followed by one real number literal at line 3:

{{XExample|1=&lt;span id="code-section-62"&gt;'''Code section 3.62: Literals.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
(2 &gt; 3) ? true : false;
"text".substring(2);
System.out.println("Display a hard coded float: " + 37.19f);
&lt;/syntaxhighlight&gt;}}

== Boolean Literals ==
There are two boolean literals

* {{Java:true}} represents a true boolean value
* {{Java:false}} represents a false boolean value

There are no other boolean literals, because there are no other boolean values!

== Numeric Literals ==
There are three types of numeric literals in Java.
=== Integer Literals ===
In Java, you may enter integer numbers in several formats:

# As decimal numbers such as &lt;code&gt;1995&lt;/code&gt;,  &lt;code&gt;51966&lt;/code&gt;. Negative decimal numbers such as &lt;code&gt;-42&lt;/code&gt; are actually ''expressions'' consisting of the integer literal with the unary negation operation &lt;code&gt;-&lt;/code&gt;.
# As octal numbers, using a leading &lt;code&gt;0&lt;/code&gt; (zero) digit and one or more additional octal digits (digits between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;7&lt;/code&gt;), such as &lt;code&gt;077&lt;/code&gt;. Octal numbers may evaluate to negative numbers; for example &lt;code&gt;037777777770&lt;/code&gt; is actually the decimal value -8.
# As hexadecimal numbers, using the form &lt;code&gt;0x&lt;/code&gt; (or &lt;code&gt;0X&lt;/code&gt;) followed by one or more hexadecimal digits (digits from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;f&lt;/code&gt; or &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;F&lt;/code&gt;). For example, 0xCAFEBABEL is the long integer 3405691582. Like octal numbers, hexadecimal literals may represent negative numbers.
# Starting in J2SE 7.0, as binary numbers, using the form &lt;code&gt;0b&lt;/code&gt; (or &lt;code&gt;0B&lt;/code&gt;) followed by one or more binary digits (0 or 1). For example, 0b101010 is the integer 42. Like octal and hex numbers, binary literals may represent negative numbers.

By default, the integer literal primitive type is {{Java:int}}. If you want a {{Java:long}}, add a letter ''el'' suffix (either the character &lt;code&gt;l&lt;/code&gt; or the character &lt;code&gt;L&lt;/code&gt;) to the integer literal. This suffix denotes a ''long integer'' rather than a standard integer. For example, &lt;code&gt;3405691582L&lt;/code&gt; is a long integer literal. Long integers are 8 bytes in length as opposed to the standard 4 bytes for {{Java:int}}. It is best practice to use the suffix &lt;code&gt;L&lt;/code&gt; instead of &lt;code&gt;l&lt;/code&gt; to avoid confusion with the digit &lt;code&gt;1&lt;/code&gt; (one) which looks like &lt;code&gt;l&lt;/code&gt; in many fonts: &lt;code&gt;200l&lt;/code&gt; &amp;ne; &lt;code&gt;2001&lt;/code&gt;. If you want a short integer literal, you have to cast it.

Starting in J2SE 7.0, you may insert underscores between digits in a numeric literal. They are ignored but may help readability by allowing the programmer to group digits.

=== Floating Point Literals ===
Floating point numbers are expressed as decimal fractions or as exponential notation:
{{XExample|1=&lt;span id="code-section-63"&gt;'''Code section 3.63: Floating point literals.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
double decimalNumber = 5.0;
decimalNumber = 89d;
decimalNumber = 0.5;
decimalNumber = 10f;
decimalNumber = 3.14159e0;
decimalNumber = 2.718281828459045D;
decimalNumber = 1.0e-6D;
&lt;/syntaxhighlight&gt;}}

Floating point numbers consist of:
# an optional leading &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; sign, indicating a positive or negative value; if omitted, the value is positive,
# one of the following number formats
#* ''integer digits'' (must be followed by either an exponent or a suffix or both, to distinguish it from an integer literal)
#* ''integer digits'' &lt;code&gt;.&lt;/code&gt;
#* ''integer digits'' &lt;code&gt;.&lt;/code&gt; ''integer digits''
#* &lt;code&gt;.&lt;/code&gt; ''integer digits''
# an optional exponent of the form
#* the exponent indicator &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;E&lt;/code&gt;
#* an optional exponent sign &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; (the default being a positive exponent)
#* ''integer digits'' representing the integer exponent value
# an optional floating point suffix:
#* either &lt;code&gt;f&lt;/code&gt; or &lt;code&gt;F&lt;/code&gt; indicating a single precision (4 bytes) floating point number, or
#* &lt;code&gt;d&lt;/code&gt; or &lt;code&gt;D&lt;/code&gt; indicating the number is a double precision floating point number (by default, thus the double precision (8 bytes) is default).

Here, ''integer digits'' represents one or more of the digits &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;9&lt;/code&gt;.

Starting in J2SE 7.0, you may insert underscores between digits in a numeric literal. They are ignored but may help readability by allowing the programmer to group digits.

=== Character Literals ===
Character literals are constant valued character expressions embedded in a Java program. Java characters are sixteen bit Unicode characters, ranging from 0 to 65535. Character literals are expressed in Java as a single quote, the character, and a closing single quote ({{Java:ch|a}}, {{Java:ch|7}}, {{Java:ch|$}}, {{Java:ch|π}}). Character literals have the type {{Java:char}}, an unsigned integer [[Java Programming/Primitive Types|primitive type]]. Character literals may be safely promoted to larger integer types such as {{Java:int}} and {{Java:long}}. Character literals used where a {{Java:short}} or {{Java:byte}} is called for must be cast to {{Java:short}} or {{Java:byte}} since truncation may occur.

== String Literals ==
String literals consist of the double quote character (&lt;code&gt;"&lt;/code&gt;) (ASCII 34, hex 0x22), zero or more characters (including Unicode characters), followed by a terminating double quote character (&lt;code&gt;"&lt;/code&gt;), such as: {{Java:string|Ceci est une string.}}

So a string literal follows the following grammar:
&lt;pre&gt;&lt;STRING :
        "\""
        (    (~["\"","\\","\n","\r"])
        |("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            |["0"-"7"](["0"-"7"])?
            |["0"-"3"]["0"-"7"]["0"-"7"]
            )
        )
        )*
        "\""&gt;
&lt;/pre&gt;

Within string and character literals, the backslash character can be used to escape special characters, such as [[Java Programming/Syntax/Unicode Escape Sequences|unicode escape sequences]], or the following special characters:

{| class="wikitable" style="margin: auto;"
! Name
! Character
! ASCII
! hex
|-
| Backspace
| &lt;code&gt;\b&lt;/code&gt;
| 8
| 0x08
|-
| TAB
| &lt;code&gt;\t&lt;/code&gt;
| 9
| 0x09
|-
| NUL character
| &lt;code&gt;\0&lt;/code&gt;
| 0
| 0x00
|-
| newline
| &lt;code&gt;\n&lt;/code&gt;
| 10
| 0x0a
|-
| carriage control
| &lt;code&gt;\r&lt;/code&gt;
| 13
| 0xd
|-
| double quote
| &lt;code&gt;\"&lt;/code&gt;
| 34
| 0x22
|-
| single quote
| &lt;code&gt;\'&lt;/code&gt;
| 39
| 0x27
|-
| backslash
| &lt;code&gt;\\&lt;/code&gt;
| 92
| 0x5c
|}

String literals may not contain unescaped newline or linefeed characters. However, the Java compiler will evaluate compile time expressions, so the following String expression results in a string with three lines of text:

{{XExample|1=&lt;span id="code-section-64"&gt;'''Code section 3.64: Multi-line string.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
String text = "This is a String literal\n"
            + "which spans not one and not two\n"
            + "but three lines of text.\n";
&lt;/syntaxhighlight&gt;}}

== null ==
{{Java:null}} is a special Java literal which represents a ''null value'': a value which does not refer to any object. It is an error to attempt to dereference the null value &amp;mdash; Java will throw a &lt;code&gt;NullPointerException&lt;/code&gt;. {{Java:null}} is often used to represent uninitialized state.

== Mixed Mode Operations ==
In concatenation operations, the values in brackets are concatenated first. Then the values are concatenated from the left to the right. Be careful when mixing character literals and integers in String concatenation operations:

{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-65"&gt;'''Code section 3.65: Concatenation operations.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="4"&gt;
int one = '1';
int zero = '0';

System.out.println("120? " + one + '2' + zero);
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Console for Code section 3.66'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
120? 49248
&lt;/pre&gt;}}
|}

The unexpected results arise because {{Java:ch|1}} and {{Java:ch|0}} are converted twice. The expression is concatenated as such:
{| style="margin: auto; text-align: center;"
|-
|&lt;code&gt;"120? " + one + '2' + zero&lt;/code&gt;
|-
|&lt;code&gt;&lt;u&gt;"120? " + '''49'''&lt;/u&gt; + '2' + '''48'''&lt;/code&gt;
|-
|&lt;code&gt;&lt;u&gt;'''"120? 49"''' + '2'&lt;/u&gt; + 48&lt;/code&gt;
|-
|&lt;code&gt;&lt;u&gt;'''"120? 492"''' + 48&lt;/u&gt;&lt;/code&gt;
|-
|&lt;code&gt;'''"120? 49248"'''&lt;/code&gt;
|}

# &lt;code&gt;one&lt;/code&gt; and &lt;code&gt;zero&lt;/code&gt; are integers. So they store integer values. The integer value of {{Java:ch|1}} is 49 and the integer value of {{Java:ch|0}} is 48.
# So the first concatenation concatenates {{Java:string|120? }} and &lt;code&gt;49&lt;/code&gt;. &lt;code&gt;49&lt;/code&gt; is first converted into String, yielding {{Java:string|49}} and the concatenation returns the string {{Java:string|120? 49}}.
# The second concatenation concatenates {{Java:string|120? 49}} and {{Java:ch|2}}. {{Java:ch|2}} is converted into the String {{Java:string|2}} and the concatenation returns the string {{Java:string|120? 492}}.
# The concatenation between {{Java:string|120? 492}} and {{Java:ch|0}} returns the string {{Java:string|120? 49248}}.
The [[#code-section-66|code section 66]] yields the desired result:

{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-66"&gt;'''Code section 3.66: Correct primitive type.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="4"&gt;
char one = '1';
char zero = '0';

System.out.println("120? " + one + '2' + zero);
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Console for Code section 3.66'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
120? 120
&lt;/pre&gt;}}
|}

{{Java/Hidden begin|title=Test your knowledge}}
'''Question 3.9''': Consider the following code:

{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="question-9"&gt;'''Question 3.9: New concatenation operations.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="4-6"&gt;
int one = '1';
int zero = '0';

System.out.println("  3? " + (one + '2' + zero));
System.out.println("102? " + 100 + '2' + 0);
System.out.println("102? " + (100 + '2' + 0));
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Console for Question 3.9'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
  3? 147
102? 10020
102? 150
&lt;/pre&gt;}}
|}

Explain the results seen.
{{Java/Hidden begin|title=Answer}}
For the first line:
{| style="margin: auto; text-align: center;"
|-
|&lt;code&gt;"  3? " + (one + '2' + zero)&lt;/code&gt;
|-
|&lt;code&gt;"  3? " + (&lt;u&gt;'''49''' + '2'&lt;/u&gt; + '''48''')&lt;/code&gt;
|-
|&lt;code&gt;"  3? " + (&lt;u&gt;'''99''' + 48&lt;/u&gt;)&lt;/code&gt;
|-
|&lt;code&gt;&lt;u&gt;"  3? " + '''147'''&lt;/u&gt;&lt;/code&gt;
|-
|&lt;code&gt;'''"  3? 147"'''&lt;/code&gt;
|}

For the second line:
{| style="margin: auto; text-align: center;"
|-
|&lt;code&gt;&lt;u&gt;"102? " + 100&lt;/u&gt; + '2' + 0&lt;/code&gt;
|-
|&lt;code&gt;&lt;u&gt;'''"102? 100"''' + '2'&lt;/u&gt; + 0&lt;/code&gt;
|-
|&lt;code&gt;&lt;u&gt;'''"102? 1002"''' + 0&lt;/u&gt;&lt;/code&gt;
|-
|&lt;code&gt;'''"102? 10020"'''&lt;/code&gt;
|}

For the last line:
{| style="margin: auto; text-align: center;"
|-
|&lt;code&gt;"102? " + (&lt;u&gt;100 + '2'&lt;/u&gt; + 0)&lt;/code&gt;
|-
|&lt;code&gt;"102? " + (&lt;u&gt;'''150''' + 0&lt;/u&gt;)&lt;/code&gt;
|-
|&lt;code&gt;&lt;u&gt;"102? " + '''150'''&lt;/u&gt;&lt;/code&gt;
|-
|&lt;code&gt;'''"102? 150"'''&lt;/code&gt;
|}
{{Hidden end}}
{{Hidden end}}

&lt;noinclude&gt;{{Programming/Navigation}}
{{Status|100%}}&lt;/noinclude&gt;</text>
      <sha1>14xdw2q5yydvuken99lf5sqfrv4zx3x</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Methods</title>
    <ns>0</ns>
    <id>23296</id>
    <revision>
      <id>3295232</id>
      <parentid>3244271</parentid>
      <timestamp>2017-09-17T14:42:38Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="16210">&lt;noinclude&gt;{{Displaytitle|title=Methods}}
{{Programming/Navigation}}
{{Java Programming/LanguageFundamentalsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

''Methods'' are how we communicate with objects. When we invoke or call a method we are asking the object to carry out a task. We can say methods implement the behaviour of objects. For each method we need to give a name, we need to define its input parameters and we need to define its return type. We also need to set its [[Java Programming/Scope|visibility]] (private, protected or public). If the method throws a checked exception, that needs to be declared as well. It is called a ''method definition''. The syntax of method definition is:
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
MyClass {
  ...
  public ReturnType methodName(ParamOneType parameter1, ParamTwoType parameter2) {
      ...
      return returnType;
  }
  ...
}
&lt;/syntaxhighlight&gt;
We can declare that the method does not return anything using the {{java:void}} Java keyword. For example:

{{XExample|1=&lt;span id="code-section-67"&gt;'''Code section 3.67: Method without returned data.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
private void methodName(String parameter1, String parameter2) {
  ...
  return;
}
&lt;/syntaxhighlight&gt;}}

When the method returns nothing, the {{java:return}} keyword at the end of the method is optional. When the execution flow reaches the {{java:return}} keyword, the method execution is stopped and the execution flow returns to the caller method. The {{java:return}} keyword can be used anywhere in the method as long as there is a way to execute the instructions below:

{{XWarning|1=&lt;span id="code-section-68" style="color: red;"&gt;'''Code section 3.68: {{java:return}} keyword location.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="5, 8"&gt;
private void aMethod(int a, int b) {
  int c = 0;
  if (a &gt; 0) {
    c = a;
    return;
  }
  int c = c + b;
  return;
  int c = c * 2;
}
&lt;/syntaxhighlight&gt;}}

In the [[#code-section-68|code section 3.68]], the {{java:return}} keyword at line 5 is well placed because the instructions below can be reached when &lt;code&gt;a&lt;/code&gt; is negative or equal to 0. However, the {{java:return}} keyword at line 8 is badly placed because the instructions below can't be reached.

{{Java/Hidden begin|title=Test your knowledge}}
'''Question 3.9''': Consider the following code:

{{XExample|1=&lt;span id="question-9"&gt;'''Question 3.9: Compiler error.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
private int myMethod(int a, int b, boolean c) {
  b = b + 2;
  if (a &gt; 0) {
    a = a + b;
    return a;
  } else {
    a = 0;
  }
}
&lt;/syntaxhighlight&gt;}}

The code above will return a compiler error. Why?
{{Java/Hidden begin|title=Answer}}
{{XExample|1=&lt;span id="answer-9"&gt;Answer 3.9: Compiler error.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1, 7"&gt;
private int myMethod(int a, int b, boolean c) {
  b = b + 2;
  if (a &gt; 0) {
    a = a + b;
    return a;
  } else {
    a = 0;
  }
}
&lt;/syntaxhighlight&gt;}}
The method is supposed to return a {{java:int}} but when &lt;code&gt;a&lt;/code&gt; is negative or equal to 0, it returns nothing.
{{Hidden end}}
{{Hidden end}}

== Parameter passing ==

We can pass any [[Java Programming/Primitive Types|primitive data types]] or reference data type to a method.

=== Primitive type parameter ===

The primitive types are ''passed in by value''. It means that as soon as the primitive type is passed in, there is no more link between the value inside the method and the source variable:

{{XExample|1=&lt;span id="code-section-69"&gt;'''Code section 3.69: A method modifying a variable.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
private void modifyValue(int number) {
  number += 1;
}
&lt;/syntaxhighlight&gt;}}

{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-70"&gt;'''Code section 3.70: Passing primitive value to method.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2"&gt;
int i = 0;
modifyValue(i);
System.out.println(i);
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code section 3.70'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
0  
&lt;/pre&gt;}}
|}

As you can see in [[#code-section-70|code section 3.70]], the &lt;code&gt;modifyValue()&lt;/code&gt; method has not modified the value of &lt;code&gt;i&lt;/code&gt;.

=== Reference type parameter ===

The object references are passed by value. It means that:
* There is no more link between the reference inside the method and the source reference,
* The source object itself and the object itself inside the method are still the same.

You must understand the difference between the reference of an object and the object itself. A ''object reference'' is the link between a variable name and an instance of object:

{| style="margin: auto;"
|&lt;code&gt;Object object&lt;/code&gt; ⇔ &lt;code&gt;new Object()&lt;/code&gt;
|}

An object reference is a pointer, an address to the object instance.

The object itself is the value of its attributes inside the object instance:
{| style="margin: auto;"
|object.firstName
|⇒
|"James"
|-
|object.lastName
|⇒
|"Gosling"
|-
|object.birthDay
|⇒
|"May 19"
|}

Take a look at the example above:
{{XExample|1=&lt;span id="code-section-71"&gt;'''Code section 3.71: A method modifying an object.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
private void modifyObject(FirstClass anObject) {
  anObject.setName("Susan");
}
&lt;/syntaxhighlight&gt;}}

{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-72"&gt;'''Code section 3.72: Passing reference value to method.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="4"&gt;
FirstClass object = new FirstClass();
object.setName("Christin");

modifyObject(object);

System.out.println(object.getName());
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code section 3.72'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
Susan
&lt;/pre&gt;}}
|}

The name has changed because the method has changed the object itself and not the reference. Now take a look at the other example:
{{XExample|1=&lt;span id="code-section-73"&gt;'''Code section 3.73: A method modifying an object reference.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
private void modifyObject(FirstClass anObject) {
  anObject = new FirstClass();
  anObject.setName("Susan");
}
&lt;/syntaxhighlight&gt;}}

{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-74"&gt;'''Code section 3.74: Passing reference value to method.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="4"&gt;
FirstClass object = new FirstClass();
object.setName("Christin");

modifyObject(object);

System.out.println(object.getName());
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code section 3.74'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
Christin
&lt;/pre&gt;}}
|}

The name has not changed because the method has changed the reference and not the object itself. The behavior is the same as if the method was in-lined and the parameters were assigned to new variable names:
{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-75"&gt;'''Code section 3.75: In-lined method.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="5-7"&gt;
FirstClass object = new FirstClass();
object.setName("Christin");

// Start of the method
FirstClass anObject = object;
anObject = new FirstClass();
anObject.setName("Susan");
// End of the method

System.out.println(object.getName());
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code section 3.75'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
Christin
&lt;/pre&gt;}}
|}

== Variable argument list ==
Java SE 5.0 added syntactic support for methods with [http://docs.oracle.com/javase/1.5.0/docs/guide/language/varargs.html variable argument list], which simplifies the typesafe usage of methods requiring a variable number of arguments. Less formally, these parameters are called ''varargs''[http://www.javabeat.net/qna/645-varargs-in-java-50/]. The type of a variable parameter must be followed with &lt;code&gt;...&lt;/code&gt;, and Java will box all the arguments into an array:

{{XExample|1=&lt;span id="code-section-76"&gt;'''Code section 3.76: A method using vararg parameters.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1"&gt;
public void drawPolygon(Point... points) {
  //…
}
&lt;/syntaxhighlight&gt;}}

When calling the method, a programmer can simply separate the points by commas, without having to explicitly create an [[Java Programming/Arrays|array]] of &lt;code&gt;Point&lt;/code&gt; objects. Within the method, the points can be referenced as &lt;code&gt;points[0]&lt;/code&gt;, &lt;code&gt;points[1]&lt;/code&gt;, etc. If no points are passed, the array has a length of zero.

A method can have both normal parameters and a variable parameter but the variable parameter must always be the last parameter. For instance, if the programmer is required to use a minimum number of parameters, those parameters can be specified before the variable argument:

{{XExample|1=&lt;span id="code-section-77"&gt;'''Code section 3.77: Variable arguments.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2"&gt;
// A polygon needs at least three points.
public void drawPolygon(Point p1, Point p2, Point p3, Point... otherPoints) {
  //…
}
&lt;/syntaxhighlight&gt;}}

== Return parameter ==
A method may return a value (which can be a primitive type or an object reference). If the method does not return a value we use the {{java:void}} Java keyword.

However, a method can return only one value so what if you want to return more than one value from a method?
You can pass in an object reference to the method, and let the method modify the object properties so the modified values can be considered as an output value from the method.
You can also create an Object array inside the method, assign the return values and return the array to the caller. However, this gives a problem if you want to mix primitive data types and object references as the output values from the method.

There is a better approach, define a special return object with the needed return values. Create that object inside the method, assign the values and return the reference to this object. This special object is "bound" to this method and used only for returning values, so do not use a public class. The best way is to use a nested class, see example below:

{{XCode|1=&lt;span id="code-listing-12"&gt;'''Code listing 3.12: Multiple returned variables.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="37"&gt;
public class MyObject {
  ...
 
  /** Nested object is for return values from getPersonInfoById method */
  private static class ReturnObject {
      private int age;
      private String name;

      public void setAge(int age) {
          this.age = age;
      }
 
      public int getAge() {
          return age;
      }

      public void setName(String name) {
          name = name;
      }
 
      public String getName() {
          return name;
      }
  } // End of nested class definition

  /** Method using the nested class to return values */
  public ReturnObject getPersonInfoById(int id) {
    int    age;
    String name;
    ...
    // Get the name and age based on the ID from the database
    ...
    ReturnObject result = new ReturnObject();
    result.setAge(age);
    result.setName(name);

    return result;
  }
}
&lt;/syntaxhighlight&gt;}}

In the above example the &lt;code&gt;getPersonInfoById&lt;/code&gt; method returns an object reference that contains both values of the name and the age. See below how you may use that object:

{{XExample|1=&lt;span id="code-section-78"&gt;'''Code section 3.78: Retrieving the values.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2"&gt;
MyObject object = new MyObject();
MyObject.ReturnObject person = object.getPersonInfoById(102);

System.out.println("Person Name=" + person.getName());
System.out.println("Person Age =" + person.getAge());
&lt;/syntaxhighlight&gt;}}

{{Java/Hidden begin|title=Test your knowledge}}
'''Question 3.10''': Consider the following code:

{{XExample|1=&lt;span id="question-10"&gt;'''Question 3.10: Compiler error.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
private int myMethod(int a, int b, String c) {
  if (a &gt; 0) {
    c = "";
    return c;
  }
  int b = b + 2;
  return b;
}
&lt;/syntaxhighlight&gt;}}

The code above will return a compiler error. Why?
{{Java/Hidden begin|title=Answer}}
{{XExample|1=&lt;span id="answer-10"&gt;Answer 3.10: Compiler error.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1, 4"&gt;
private int myMethod(int a, int b, String c) {
  if (a &gt; 0) {
    c = "";
    return c;
  }
  int b = b + 2;
  return b;
}
&lt;/syntaxhighlight&gt;}}
The method is supposed to return a {{java:int}} but at line 4, it returns &lt;code&gt;c&lt;/code&gt;, which is a String.
{{Hidden end}}
{{Hidden end}}

== Special method, the constructor ==
The constructor is a special method called automatically when an object is created with the {{java:new}} keyword. Constructor does not have a return value and its name is the same as the class name. Each class must have a constructor. If we do not define one, the compiler will create a default so called '''empty constructor''' automatically.

{{XCode|1=&lt;span id="code-listing-13"&gt;'''Code listing 3.13: Automatically created constructor.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="5-6"&gt;
public class MyClass {
  /**
  * MyClass Empty Constructor
  */
  public MyClass() {
  }
}
&lt;/syntaxhighlight&gt;}}

== Static methods ==

A ''static method'' is a method that can be called without an object instance. It can be called on the class directly. For example, the &lt;code&gt;valueOf(String)&lt;/code&gt; method of the &lt;code&gt;Integer&lt;/code&gt; class is a static method:

{{XExample|1=&lt;span id="code-section-79"&gt;'''Code section 3.79: Static method.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
Integer i = Integer.valueOf("10");
&lt;/syntaxhighlight&gt;}}

The static keyword makes attributes instance-agnostic. This means that you cannot reference a static attribute of a single object (because such a specific object attribute doesn't exist). Instead, only one instance of a static attribute exists, whether there is one object in the JVM or one hundred. Here is an example of using a static attribute in a static method:

{{XExample|1=&lt;span id="code-section-80"&gt;'''Code section 3.80: Static attribute.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
private static int count = 0;

public static int getNewInteger() {
  return count++;
}
&lt;/syntaxhighlight&gt;}}

You can notice that when you use &lt;code&gt;System.out.println()&lt;/code&gt;, &lt;code&gt;out&lt;/code&gt; is a static attribute of the &lt;code&gt;System&lt;/code&gt; class. A static attribute is related to a class, not to any object instance. This is how Java achieves one universal output stream that we can use to print output. Here is a more complex use case:
{| style="width: 100%;"
|valign="top"|{{XCode|1=&lt;span id="code-listing-14"&gt;'''Code listing 3.14: A static attribute.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3"&gt;
public class MyProgram {

    public static int count = 0;

    public static void main (String[] args) {
        MyProgram.count++;

        MyProgram program1 = new MyProgram();
        program1.count++;

        MyProgram program2 = new MyProgram();
        program2.count++;

        new MyProgram().count++;
        System.out.println(MyProgram.count);
    }
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code listing 3.14'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
4
&lt;/pre&gt;}}
|}

{{Java/Hidden begin|title=Test your knowledge}}
'''Question 3.11''': Visit the Oracle [http://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html JavaDoc of the class &lt;code&gt;java.lang.Integer&lt;/code&gt;].

How many static fields does this class have?
{{Java/Hidden begin|title=Answer}}
4.
* &lt;code&gt;int MAX_VALUE&lt;/code&gt;,
* &lt;code&gt;int MIN_VALUE&lt;/code&gt;,
* &lt;code&gt;int SIZE&lt;/code&gt; and
* &lt;code&gt;Class&lt;Integer&gt; TYPE&lt;/code&gt;.
{{Hidden end}}
{{Hidden end}}

:''To learn how to overload and override a method, see [[Java Programming/Overloading Methods and Constructors|Overloading Methods and Constructors]].''

&lt;noinclude&gt;{{Programming/Navigation}}
{{Status|100%}}&lt;/noinclude&gt;</text>
      <sha1>hv6lb03pmkf0r0t6yq74top6w7y7kjq</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/API/java.lang.String</title>
    <ns>0</ns>
    <id>85041</id>
    <revision>
      <id>3241519</id>
      <parentid>3072496</parentid>
      <timestamp>2017-07-04T18:00:38Z</timestamp>
      <contributor>
        <username>Strange quark</username>
        <id>3078616</id>
      </contributor>
      <minor/>
      <comment>Add deep categorization</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19800">&lt;noinclude&gt;{{Displaytitle|title=String}}
{| width="100%" style="border:solid 1px #71c837; background:#c6e9af; color:#2d5016;" class="noprint"
| style="text-align:left; width:33%; font-size:90%;" | [[File:Navigation Left Arrow.svg|18px]] [[Java Programming/Methods|Methods]]
| style="text-align:center; width:34%;" | [[Java Programming]]&lt;br /&gt;'''String'''
| style="text-align:right; width:33%; font-size:90%;" | [[Java Programming/Classes, Objects and Types|Classes, Objects and Types]] [[File:Navigation Right Arrow.svg|18px]]
|}
{{Java Programming/LanguageFundamentalsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

{{java:String}} is a class built into the Java language defined in the &lt;code&gt;java.lang&lt;/code&gt; package. It represents character strings. Strings are ubiquitous in Java. Study the &lt;code&gt;String&lt;/code&gt; class and its methods carefully. It will serve you well to know how to manipulate them skillfully. [[Java Programming/Literals#String Literals|String literals]] in Java programs, such as "abc", are implemented as instances of this class like this:

{{XExample|1='''Code section 3.81: String example.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
String str = "This is string literal";
&lt;/syntaxhighlight&gt;}}

On the right hand side a String object is created represented by the string literal. Its object reference is assigned to the &lt;code&gt;str&lt;/code&gt; variable.

== Immutability ==
Strings are ''immutable''; that is, they cannot be modified once created. Whenever it looks as if a String object was modified actually a new String object was created. For instance, the &lt;code&gt;String.trim()&lt;/code&gt; method returns the string with leading and trailing whitespace removed. Actually, it creates a new trimmed string and then returns it. Pay attention on what happens in [[#code-section-82|Code section 3.82]]:

{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-82"&gt;'''Code section 3.82: Immutability.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="4"&gt;
String badlyCutText = "     Java is great.     ";
System.out.println(badlyCutText);

badlyCutText.trim();
System.out.println(badlyCutText);
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code section 3.82'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
     Java is great.    
     Java is great.    
&lt;/pre&gt;}}
|}

The &lt;code&gt;trim()&lt;/code&gt; method call does not modify the object so nothing happens. It creates a new trimmed string and then throws it away.
{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-83"&gt;'''Code section 3.83: Assignment.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="4"&gt;
String badlyCutText = "     Java is great.     ";
System.out.println(badlyCutText);

badlyCutText = badlyCutText.trim();
System.out.println(badlyCutText);
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code section 3.83'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
     Java is great.    
Java is great.
&lt;/pre&gt;}}
|}

The returned string is assigned to the variable. It does the job as the &lt;code&gt;trim()&lt;/code&gt; method has created a new &lt;code&gt;String&lt;/code&gt; instance.

== Concatenation ==
The Java language provides special support for the string concatenation with operator &lt;code&gt;+&lt;/code&gt;:
{| style="width: 100%;"
|valign="top"|{{XExample|1='''Code section 3.84: Examples of concatenation.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
System.out.println("First part");
System.out.println(" second part");
String str = "First part" + " second part";
System.out.println(str);
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code section 3.84'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
First part
 second part
First part second part
&lt;/pre&gt;}}
|}

The concatenation is not always processed at the same time. [[Java Programming/Literals#String Literals|Raw string literals]] concatenation is done at compile time, hence there is a single string literal in the byte code of the class. Concatenation with at least one object is done at runtime.

&lt;code&gt;+&lt;/code&gt; operator can concatenate other objects with strings. For instance, integers will be converted to strings before the concatenation:
{| style="width: 100%;"
|valign="top"|{{XExample|1='''Code section 3.85: Concatenation of integers.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
System.out.println("Age=" + 25);
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code section 3.85'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
Age=25
&lt;/pre&gt;}}
|}

Each Java object has the &lt;code&gt;String toString()&lt;/code&gt; inherited from the {{java:Object}} class. This method provides a way to convert objects into &lt;code&gt;String&lt;/code&gt;s. Most classes override the default behavior to provide more specific (and more useful) data in the returned &lt;code&gt;String&lt;/code&gt;:
{| style="width: 100%;"
|valign="top"|{{XExample|1='''Code section 3.86: Concatenation of objects.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
System.out.println("Age=" + new Integer(31));
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code section 3.86'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
Age=31
&lt;/pre&gt;}}
|}

== Using StringBuilder/StringBuffer to concatenate strings ==

Remember that &lt;code&gt;String&lt;/code&gt; objects are immutable objects. Once a &lt;code&gt;String&lt;/code&gt; is created, it can not be modified, takes up memory until garbage collected. Be careful of writing a method like this:
{{XExample|1='''Code section 3.87: Raw concatenation.'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="5"&gt;
public String convertToString(Collection&lt;String&gt; words) {
  String str = "";
  // Loops through every element in words collection
  for (String word : words) {
    str = str + word + " ";
  }
  return str;
}
&lt;/syntaxhighlight&gt;}}
On the &lt;code&gt;+&lt;/code&gt; operation a new {{java:String}} object is created at each iteration. Suppose &lt;code&gt;words&lt;/code&gt; contains the elements &lt;code&gt;["Foo", "Bar", "Bam", "Baz"]&lt;/code&gt;. At runtime, the method creates thirteen &lt;code&gt;String&lt;/code&gt;s:
# &lt;code&gt;""&lt;/code&gt;
# &lt;code&gt;"Foo"&lt;/code&gt;
# &lt;code&gt;" "&lt;/code&gt;
# &lt;code&gt;"Foo "&lt;/code&gt;
# &lt;code&gt;"Foo Bar"&lt;/code&gt;
# &lt;code&gt;" "&lt;/code&gt;
# &lt;code&gt;"Foo Bar "&lt;/code&gt;
# &lt;code&gt;"Foo Bar Bam"&lt;/code&gt;
# &lt;code&gt;" "&lt;/code&gt;
# &lt;code&gt;"Foo Bar Bam "&lt;/code&gt;
# &lt;code&gt;"Foo Bar Bam Baz"&lt;/code&gt;
# &lt;code&gt;" "&lt;/code&gt;
# &lt;code&gt;"Foo Bar Bam Baz "&lt;/code&gt;
Even though only the last one is actually useful.

To avoid unnecessary memory use like this, use the &lt;code&gt;StringBuilder&lt;/code&gt; class. It provides similar functionality to {{java:String}}s, but stores its data in a mutable way. Only one &lt;code&gt;StringBuilder&lt;/code&gt; object is created. Also because object creation is time consuming, using &lt;code&gt;StringBuilder&lt;/code&gt; produces much faster code.
{{XExample|1='''Code section 3.88: Concatenation with &lt;code&gt;StringBuilder&lt;/code&gt;.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public String convertToString(Collection&lt;String&gt; words) {
  StringBuilder buf = new StringBuilder();
  // Loops through every element in words collection
  for (String word : words) {
    buf.append(word);
    buf.append(" ");
  }
  return buf.toString();
}
&lt;/syntaxhighlight&gt;}}

As &lt;code&gt;StringBuilder&lt;/code&gt; isn't thread safe (see the chapter on [[Java Programming/Concurrent Programming|Concurrency]]) you can't use it in more than one thread. For a multi-thread environment, use &lt;code&gt;StringBuffer&lt;/code&gt; instead which does the same and is thread safe. However, &lt;code&gt;StringBuffer&lt;/code&gt; is slower so only use it when it is required. Moreover, before Java 5 only &lt;code&gt;StringBuffer&lt;/code&gt; existed.

== Comparing Strings ==

Comparing strings is not as easy as it may first seem. Be aware of what you are doing when comparing &lt;code&gt;String&lt;/code&gt;'s using &lt;code&gt;==&lt;/code&gt;:

{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-89"&gt;'''Code section 3.89: Dangerous comparison.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3"&gt;
String greeting = "Hello World!";
if (greeting == "Hello World!") {
    System.out.println("Match found.");
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code section 3.89'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
Match found.
&lt;/pre&gt;}}
|}
The difference between the above and below code is that the above code checks
to see if the &lt;code&gt;String&lt;/code&gt;'s are the same objects in memory which they are. This is as a result of the fact that
&lt;code&gt;String&lt;/code&gt;'s are stored in a place in memory called the String Constant Pool. If the &lt;code&gt;new&lt;/code&gt; keyword is not explicitly used when 
creating the &lt;code&gt;String&lt;/code&gt; it checks to see if it already exists in the Pool and uses the existing one. If it does not exist, a new Object is created. This is what allows Strings to be immutable in Java.
To test for equality, use the &lt;code&gt;equals(Object)&lt;/code&gt; method inherited by every class and defined by &lt;code&gt;String&lt;/code&gt; to return {{java:true}} if and only if the object passed in is a &lt;code&gt;String&lt;/code&gt; contains the exact same data:
{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-90"&gt;'''Code section 3.90: Right comparison.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3"&gt;
String greeting = "Hello World!";
if (greeting.equals("Hello World!")) {
    System.out.println("Match found.");
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code section 3.90'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
Match found.
&lt;/pre&gt;}}
|}

Remember that the comparison is case sensitive.
{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-91"&gt;'''Code section 3.91: Comparison with lowercase.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3"&gt;
String greeting = "Hello World!";
if (greeting.equals("hello world!")) {
    System.out.println("Match found.");
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code section 3.91'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
&lt;/pre&gt;}}
|}

To order &lt;code&gt;String&lt;/code&gt; objects, use the '''&lt;code&gt;compareTo()&lt;/code&gt;''' method, which can be accessed wherever we use a String datatype. The &lt;code&gt;compareTo()&lt;/code&gt; method returns a negative, zero, or positive number if the parameter is less than, equal to, or greater than the object on which it is called. Let's take a look at an example:
{{XExample|1=&lt;span id="code-section-92"&gt;'''Code section 3.92: Order.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3"&gt;
String person1 = "Peter";
String person2 = "John";
if (person1.compareTo(person2) &gt; 0) {
    // Badly ordered
    String temp = person1;
    person1 = person2;
    person2 = temp;
}
&lt;/syntaxhighlight&gt;}}

The [[#code-section-92|code section 3.92]] is comparing the String variable &lt;code&gt;person1&lt;/code&gt; to &lt;code&gt;person2&lt;/code&gt;. If &lt;code&gt;person1&lt;/code&gt; is different even in the slightest manner, we will get a value above or below 0 depending on the exact difference. The result is negative if this String object lexicographically precedes the argument string. The result is positive if this String object lexicographically follows the argument string. Take a look at the [http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#compareTo%28java.lang.String%29 Java API] for more details.

== Splitting a String ==
Sometimes it is useful to split a string into separate strings, based on a ''[[Regular Expressions|regular expressions]]''. The {{java:String}} class has a '''&lt;code&gt;split()&lt;/code&gt;''' method, since Java 1.4, that will return a String array:

{{XExample|1=&lt;span id="code-section-93"&gt;'''Code section 3.93: Order.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3"&gt;
String person = "Brown, John:100 Yonge Street, Toronto:(416)777-9999";
...
String[] personData = person.split(":");
...
String name    = personData[0];
String address = personData[1];
String phone   = personData[2];
&lt;/syntaxhighlight&gt;}}

Another useful application could be to ''split'' the String text based on the new line character, so you could process the text line by line.

== Substrings ==
It may also be sometimes useful to create '''substrings''', or strings using the order of letters from an existing string.  This can be done in two methods.

The first method involves creating a substring out of the characters of a string from a given index to the end:
{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-94"&gt;'''Code section 3.94: Truncating string.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2"&gt;
String str = "coffee";
System.out.println(str.substring(3));
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code section 3.94'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
fee
&lt;/pre&gt;}}
|}

The index of the first character in a string is 0.
{| style="margin: auto;" cellspacing="0" cellpadding="2"
|style="color: blue;"|&lt;code&gt;c&lt;/code&gt;
|style="color: blue;"|&lt;code&gt;o&lt;/code&gt;
|style="color: blue;"|&lt;code&gt;f&lt;/code&gt;
|style="color: blue; background: grey;"|&lt;code&gt;f&lt;/code&gt;
|style="color: blue; background: grey;"|&lt;code&gt;e&lt;/code&gt;
|style="color: blue; background: grey;"|&lt;code&gt;e&lt;/code&gt;
|-
|''0''
|''1''
|''2''
|'''''3'''''
|''4''
|''5''
|}

By counting from there, it is apparent that the character in index 3 is the second "f" in "coffee". This is known as the &lt;code&gt;beginIndex&lt;/code&gt;. All characters from the &lt;code&gt;beginIndex&lt;/code&gt; until the end of the string will be copied into the new substring.

The second method involves a user-defined &lt;code&gt;beginIndex&lt;/code&gt; and &lt;code&gt;endIndex&lt;/code&gt;:
{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-95"&gt;'''Code section 3.95: Extraction of string.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2"&gt;
String str = "supporting";
System.out.println(str.substring(3, 7));
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code section 3.95'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
port
&lt;/pre&gt;}}
|}
The string returned by &lt;code&gt;substring()&lt;/code&gt; would be "port".
{| style="margin: auto;" cellspacing="0" cellpadding="2"
|style="color: blue;"|&lt;code&gt;s&lt;/code&gt;
|style="color: blue;"|&lt;code&gt;u&lt;/code&gt;
|style="color: blue;"|&lt;code&gt;p&lt;/code&gt;
|style="color: blue; background: grey;"|&lt;code&gt;p&lt;/code&gt;
|style="color: blue; background: grey;"|&lt;code&gt;o&lt;/code&gt;
|style="color: blue; background: grey;"|&lt;code&gt;r&lt;/code&gt;
|style="color: blue; background: grey;"|&lt;code&gt;t&lt;/code&gt;
|style="color: blue;"|&lt;code&gt;i&lt;/code&gt;
|style="color: blue;"|&lt;code&gt;n&lt;/code&gt;
|style="color: blue;"|&lt;code&gt;g&lt;/code&gt;
|-
|''0''
|''1''
|''2''
|'''''3'''''
|''4''
|''5''
|''6''
|'''''7'''''
|''8''
|''9''
|}

Please note that the endIndex is '''not''' inclusive. This means that the last character will be of the index &lt;code&gt;endIndex-1&lt;/code&gt;. Therefore, in this example, every character from index 3 to index 6, inclusive, was copied into the substring.

{{XNote|1=It is easy to mistake the method &lt;code&gt;substring()&lt;/code&gt; for &lt;code&gt;&lt;span style="border-bottom: red 1px dashed"&gt;subString&lt;/span&gt;()&lt;/code&gt; (which does not exist and would return with a syntax error on compilation). ''Substring'' is considered to be one word. This is why the method name does not seem to follow the common syntax of Java. Just remember that this style only applies to methods or other elements that are made up of more than one word.}}

== String cases ==
The &lt;code&gt;String&lt;/code&gt; class also allows for the modification of cases. The two methods that make this possible are &lt;code&gt;toLowerCase()&lt;/code&gt; and &lt;code&gt;toUpperCase()&lt;/code&gt;.
{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-96"&gt;'''Code section 3.96: Case modification.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2-3"&gt;
String str = "wIkIbOoKs";
System.out.println(str.toLowerCase());
System.out.println(str.toUpperCase());
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code section 3.96'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
wikibooks
WIKIBOOKS
&lt;/pre&gt;}}
|}

These methods are useful to do a search which is not case sensitive:
{| style="width: 100%;"
|valign="top"|{{XExample|1='''Code section 3.97: Text search.'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="8-9, 12, 18"&gt;
String word = "Integer";
String text = "A number without a decimal part is an integer."
  + " Integers are a list of digits.";

...

// Remove the case
String lowerCaseWord = word.toLowerCase();
String lowerCaseText = text.toLowerCase();

// Search
int index = lowerCaseText.indexOf(lowerCaseWord);
while (index != -1) {
  System.out.println(word
    + " appears at column "
    + (index + 1)
    + ".");
  index = lowerCaseText.indexOf(lowerCaseWord, index + 1);
}

&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code section 3.97'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
Integer appears at column 38.
Integer appears at column 47.
&lt;/pre&gt;}}
|}

{{Java/Hidden begin|title=Test your knowledge}}
'''Question 3.12''': You have mail addresses in the following form: &lt;code&gt;''&lt;firstName&gt;''.''&lt;lastName&gt;''@''&lt;companyName&gt;''.org&lt;/code&gt;

Write the &lt;code&gt;String getDisplayName(String)&lt;/code&gt; method that receives the mail string as parameter and returns the readable person name like this: &lt;code&gt;LASTNAME Firstname&lt;/code&gt;
{{Java/Hidden begin|title=Answer}}
{{XExample|1='''Answer 3.12: &lt;code&gt;getDisplayName()&lt;/code&gt;'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public static String getDisplayName(String mail) {
  String displayName = null;
 
  if (mail != null) {
    String[] mailParts = mail.split("@");
    String namePart = mailParts[0];
    String[] namesParts = namePart.split("\\.");
   
    // The last name
    String lastName = namesParts[1];
    lastName = lastName.toUpperCase();
   
    // The first name
    String firstName = namesParts[0];
   
    String firstNameInitial = firstName.substring(0, 1);
    firstNameInitial = firstNameInitial.toUpperCase();
   
    String firstNameEnd = firstName.substring(1);
    firstNameEnd = firstNameEnd.toLowerCase();
   
    // Concatenation
    StringBuilder displayNameBuilder = new StringBuilder(lastName).append(" ").append(firstNameInitial).append(firstNameEnd);
    displayName = displayNameBuilder.toString();
  }
 
  return displayName;
}
&lt;/syntaxhighlight&gt;}}

# We only process non null strings,
# We first split the mail into two parts to separate the personal information from the company information and we keep the name data,
# Then we split the name information to separate the first name from the last name. As the &lt;code&gt;split()&lt;/code&gt; method use regular expression and &lt;code&gt;.&lt;/code&gt; is a wildcard character, we have to escape it (&lt;code&gt;\.&lt;/code&gt;). However, in a string, the &lt;code&gt;\&lt;/code&gt; is also a special character, so we need to escape it too (&lt;code&gt;\\.&lt;/code&gt;),
# The last name is just capitalized,
# As the case of all the first name characters will not be the same, we have to cut the first name. Only the first name initial will be capitalized,
# Now we can concatenate all the fragments. We prefer to use a &lt;code&gt;StringBuilder&lt;/code&gt; to do that.

{{Hidden end}}
{{Hidden end}}

== See also ==
* {{java web api|java/lang/String.html|java.lang.String}}
* {{java web api|java/lang/StringBuffer.html|java.lang.StringBuffer}}
* {{java web api|java/lang/StringBuilder.html|java.lang.StringBuilder}}

&lt;noinclude&gt;{| width="100%" style="border:solid 1px #71c837; background:#c6e9af; color:#2d5016;" class="noprint"
| style="text-align:left; width:33%; font-size:90%;" | [[File:Navigation Left Arrow.svg|18px]] [[Java Programming/Methods|Methods]]
| style="text-align:center; width:34%;" | [[Java Programming]]&lt;br /&gt;'''String'''
| style="text-align:right; width:33%; font-size:90%;" | [[Java Programming/Classes, Objects and Types|Classes, Objects and Types]] [[File:Navigation Right Arrow.svg|18px]]
|}
{{Status|100%}}
{{BookCat|filing=deep}}&lt;/noinclude&gt;</text>
      <sha1>1x2j8bw04ffnvynwn701n0r5pswlcw6</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Classes, Objects and Types</title>
    <ns>0</ns>
    <id>72079</id>
    <revision>
      <id>3295185</id>
      <parentid>3181866</parentid>
      <timestamp>2017-09-17T14:41:09Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19767">&lt;noinclude&gt;{{Displaytitle|title=Classes, Objects and Types}}
{{Programming/Navigation}}
{{Java Programming/LanguageFundamentalsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

An '''object''' is composed of '''fields''' and '''methods'''. The fields, also called ''data members'', ''characteristics'', ''attributes'', or ''properties'', describe the state of the object. The methods generally describe the actions associated with a particular object. Think of an object as a noun, its fields as adjectives describing that noun, and its methods as the verbs that can be performed by or on that noun.

For example, a sports car is an object. Some of its fields might be its height, weight, acceleration, and speed. An object's fields just hold data about that object. Some of the methods of the sports car could be "drive", "park", "race", etc. The methods really don't mean much unless associated with the sports car, and the same goes for the fields.

The blueprint that lets us build our sports car object is called a ''class''. A class doesn't tell us how fast our sports car goes, or what color it is, but it does tell us that our sports car will have a field representing speed and color, and that they will be say, a number and a word (or hex color code), respectively. The class also lays out the methods for us, telling the car how to park and drive, but these methods can't take any action with just the blueprint &amp;mdash; they need an object to have an effect.

In Java, a class is located in a file similar to its own name.  If you want to have a class called &lt;code&gt;SportsCar&lt;/code&gt;, its source file needs to be &lt;code&gt;SportsCar.java&lt;/code&gt;.  The class is created by placing the following in the source file:
{{XCode|1=&lt;span id="code-listing-13"&gt;'''Code listing 3.13: SportsCar.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public class SportsCar {
   /* Insert your code here */
}
&lt;/syntaxhighlight&gt;}}

The class doesn't do anything yet, as you will need to add methods and field variables first.

The objects are different from the primitive types because:
# The primitive types are not instantiated.
# In the memory, for a primitive type only its value is stored. For an object, also a reference to an instance can be stored.
# In the memory, the allocated space of a primitive type is fixed, whatever their value. The allocated space of an object can vary, for instance either the object is instantiated or not.
# The primitive types don't have methods callable on them.
# A primitive type can't be inherited.

==Instantiation and constructors==
In order to get from class to object, we "build" our object by ''instantiation''. Instantiation simply means to create an ''instance'' of a class. Instance and object are very similar terms and are sometimes interchangeable, but remember that an instance refers to a ''specific object'', which was created from a class.

This instantiation is brought about by one of the class's methods, called a ''constructor''. As its name implies, a constructor builds the object based on the blueprint. Behind the scenes, this means that computer memory is being allocated for the instance, and values are being assigned to the data members.

In general there are four constructor types: default, non-default, copy, and cloning.

A '''default constructor''' will build the most basic instance. Generally, this means assigning all the fields values like null, zero, or an empty string. Nothing would stop you, however, from setting the color of your default sports car color to red, but this is generally bad programming style. Another programmer would be confused if your basic car came out red instead of say, colorless.
{{XExample|1='''Code section 3.79: A default constructor.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
SportsCar car = new SportsCar();
&lt;/syntaxhighlight&gt;}}

A '''non-default constructor''' is designed to create an object instance with prescribed values for most, if not all, of the object's fields. The car is red, goes from 0-60 in 12 seconds, tops out at 190mph, etc.

{{XExample|1='''Code section 3.80: A non-default constructor.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
SportsCar car = new SportsCar("red", 12, 190);
&lt;/syntaxhighlight&gt;}}

A '''copy constructor''' is not included in the Java language, however one can easily create a constructor that does the same as a copy constructor. It's important to understand what it is. As the name implies, a copy constructor creates a new instance to be a duplicate of an already existing one. In Java, this can be also accomplished by creating the instance with the default constructor, and then using the assignment operator to equivocate them. This is not possible in all languages though, so just keep the terminology under your belt.

Java has the concept of '''cloning an object''', and the end results are similar to the copy constructor. Cloning an object is faster than creation with the {{java:new}} keyword, because all the object memory is copied at once to the destination cloned object. This is possible by implementing the &lt;code&gt;Cloneable&lt;/code&gt; interface, which allows the method &lt;code&gt;Object.clone()&lt;/code&gt; to perform a field-by-field copy.

{{XExample|1='''Code section 3.81: Cloning object.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
SportsCar car = oldCar.clone();
&lt;/syntaxhighlight&gt;}}

== Type ==
When an object is created, a reference to the object is also created. The object can not be accessed directly in Java, only through this object reference. This object reference has a ''type'' assigned to it. We need this type when passing the object reference to a method as a parameter. Java does strong type checking.

Type is basically a list of features/operations, that can be performed through that object reference.  The object reference type is basically a contract that guarantees that those operations will be there at run time.

When a car is created, it comes with a list of features/operations listed in the user manual that guarantees that those will be there when the car is used.

When you create an object from a class by default its type is the same as its class. It means that all the features/operations the class defined are there and available, and can be used. See below:

{{XExample|1='''Code section 3.82: Default type.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
(new ClassName()).operations();
&lt;/syntaxhighlight&gt;}}

You can assign this to a variable having the same type as the class:

{{XExample|1='''Code section 3.83: A variable having the same type as the class.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
ClassName objRefVariable = new ClassName();
objRefVariable.operations();
&lt;/syntaxhighlight&gt;}}

You can assign the created object reference to the class, super class, or to an interface the class implements:

{{XExample|1='''Code section 3.84: Using the super class.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
SuperClass objectRef = new ClassName(); // features/operations list are defined by the SuperClass class
...
Interface inter = new ClassName(); // features/operations list are defined by the interface
&lt;/syntaxhighlight&gt;}}

In the car analogy, the created car may have different '''Type'''s of drivers. We create separate user manuals for them, an Average user manual, a Power user manual, a Child user manual, or a Handicapped user manual. Each type of user manual describes only those features/operations appropriate for the type of driver.  For instance, the Power driver may have additional gears to switch to higher speeds, that are not available to other type of users...

When the car key is passed from an adult to a child we are replacing the user manuals, that is called ''Type Casting''.

In Java, casts can occur in three ways:
* up casting going up in the inheritance tree, until we reach the {{java:Object}}
* up casting to an interface the class implements
* down casting until we reach the class the object was created from

== Autoboxing/unboxing ==
Autoboxing and unboxing, language features since Java 1.5, make the programmer's life much easier when it comes to working with the primitive wrapper types. Consider this code fragment:
{{XExample|1='''Code section 3.85: Traditional object creation.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int age = 23;
Integer ageObject = new Integer(age);
&lt;/syntaxhighlight&gt;}}

Primitive wrapper objects were Java's way of allowing one to treat primitive data types as though they were objects. Consequently, one was expected to ''wrap'' one's primitive data type with the corresponding primitive wrapper object, as shown above.

Since Java 1.5, one may write as below and the compiler will automatically create the wrap object. The extra step of wrapping the primitive is no longer required. It has been ''automatically boxed up'' on your behalf:

{{XExample|1='''Code section 3.86: Autoboxing.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int age = 23;
Integer ageObject = age;
&lt;/syntaxhighlight&gt;}}
{{XNote|Keep in mind that the compiler still creates the missing wrapper code, so one doesn't really gain anything performance-wise. Consider this feature a programmer convenience, not a performance booster.}}
Each primitive type has a class wrapper:
{| style="margin: auto;"
| Primitive type
| Class wrapper
|-
| &lt;code&gt;byte&lt;/code&gt; || &lt;code&gt;java.lang.Byte&lt;/code&gt;
|-
| &lt;code&gt;char &lt;/code&gt; || &lt;code&gt;java.lang.Character&lt;/code&gt;
|-
| &lt;code&gt;short &lt;/code&gt; || &lt;code&gt;java.lang.Short&lt;/code&gt;
|-
| &lt;code&gt;int&lt;/code&gt; || &lt;code&gt;java.lang.Integer&lt;/code&gt;
|-
| &lt;code&gt;long&lt;/code&gt; || &lt;code&gt;java.lang.Long&lt;/code&gt;
|-
| &lt;code&gt;float&lt;/code&gt; || &lt;code&gt;java.lang.Float&lt;/code&gt;
|-
| &lt;code&gt;double&lt;/code&gt; || &lt;code&gt;java.lang.Double&lt;/code&gt;
|-
| &lt;code&gt;boolean&lt;/code&gt; || &lt;code&gt;java.lang.Boolean&lt;/code&gt;
|-
| &lt;code&gt;void&lt;/code&gt; || &lt;code&gt;java.lang.Void&lt;/code&gt;
|}

Unboxing uses the same process in reverse. Study the following code for a moment. The {{java:if}} statement requires a {{java:boolean}} primitive value, yet it was given a Boolean wrapper object. No problem! Java 1.5 will automatically ''unbox'' this.
{{XExample|1='''Code section 3.87: Unboxing.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
Boolean canMove = new Boolean(true);
 
if (canMove) {
  System.out.println("This code is legal in Java 1.5");
}
&lt;/syntaxhighlight&gt;}}
{{Java/Hidden begin|title=Test your knowledge}}
'''Question 3.11''': Consider the following code:

{{XExample|1=&lt;span id="question-11"&gt;'''Question 3.11: Autoboxing/unboxing.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="5"&gt;
Integer a = 10;
Integer b = a + 2;
System.out.println(b);
&lt;/syntaxhighlight&gt;}}

How many autoboxings and unboxings are there in this code?
{{Java/Hidden begin|title=Answer}}
{{XExample|1=&lt;span id="question-11"&gt;Answer 3.11: Autoboxing/unboxing.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1-2"&gt;
Integer a = 10;
Integer b = a + 2;
System.out.println(b);
&lt;/syntaxhighlight&gt;}}
3
* 1 autoboxing at line 1 to assign.
* 1 unboxing at line 2 to do the addition.
* 1 autoboxing at line 2 to assign.
* No autoboxing nor unboxing at line 3 as &lt;code&gt;println()&lt;/code&gt; supports the &lt;code&gt;Integer&lt;/code&gt; class as parameter.
{{Hidden end}}
{{Hidden end}}

== Methods in the &lt;code&gt;Object&lt;/code&gt; class ==
Methods in the &lt;code&gt;java.lang.Object&lt;/code&gt; class are inherited, and thus shared in common by all classes.

=== The &lt;code&gt;clone&lt;/code&gt; method ===
The &lt;code&gt;java.lang.Object.clone()&lt;/code&gt; method returns a new object that is a copy of the current object.  Classes must implement the marker interface &lt;code&gt;java.lang.Cloneable&lt;/code&gt; to indicate that they can be cloned.

=== The &lt;code&gt;equals&lt;/code&gt; method ===
The &lt;code&gt;java.lang.Object.equals(java.lang.Object)&lt;/code&gt; method compares the object to another object and returns a &lt;code&gt;boolean&lt;/code&gt; result indicating if the two objects are equal.  Semantically, this method compares the contents of the objects whereas the equality comparison operator "&lt;code&gt;==&lt;/code&gt;" compares the object references.  The &lt;code&gt;equals&lt;/code&gt; method is used by many of the data structure classes in the &lt;code&gt;java.util&lt;/code&gt; package.  Some of these data structure classes also rely on the &lt;code&gt;Object.hashCode&lt;/code&gt; method—see the &lt;code&gt;hashCode&lt;/code&gt; method for details on the contract between &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;hashCode&lt;/code&gt;. Implementing equals() isn't always as easy as it seems, see '[http://www.angelikalanger.com/Articles/JavaSolutions/SecretsOfEquals/Equals.html Secrets of equals()]' for more information.

=== The &lt;code&gt;finalize&lt;/code&gt; method ===
The &lt;code&gt;java.lang.Object.finalize()&lt;/code&gt; method is called exactly once before the garbage collector frees the memory for object.  A class overrides &lt;code&gt;finalize&lt;/code&gt; to perform any clean up that must be performed before an object is reclaimed.  Most objects do not need to override &lt;code&gt;finalize&lt;/code&gt;.

There is no guarantee when the &lt;code&gt;finalize&lt;/code&gt; method will be called, or the order in which the &lt;code&gt;finalize&lt;/code&gt; method will be called for multiple objects.  If the JVM exits without performing garbage collection, the OS may free the objects, in which case the &lt;code&gt;finalize&lt;/code&gt; method doesn't get called.

The &lt;code&gt;finalize&lt;/code&gt; method should always be declared &lt;code&gt;protected&lt;/code&gt; to prevent other classes from calling the &lt;code&gt;finalize&lt;/code&gt; method.

 protected void finalize() throws Throwable { ... }

=== The &lt;code&gt;getClass&lt;/code&gt; method ===
The &lt;code&gt;java.lang.Object.getClass()&lt;/code&gt; method returns the &lt;code&gt;java.lang.Class&lt;/code&gt; object for the class that was used to instantiate the object.  The class object is the base class of [[Java Programming/Reflection|reflection]] in Java.  Additional reflection support is provided in the &lt;code&gt;java.lang.reflect&lt;/code&gt; package.

=== The &lt;code&gt;hashCode&lt;/code&gt; method ===
The &lt;code&gt;java.lang.Object.hashCode()&lt;/code&gt; method returns an integer (&lt;code&gt;int&lt;/code&gt;). This integer can be used to distinguish objects although not completely. It quickly separates most of the objects and those with the same ''hash code'' are separated later in another way. It is used by the classes that provide associative arrays, for instance, those that implement the &lt;code&gt;java.util.Map&lt;/code&gt; interface
. They use the ''hash code'' to store the object in the associative array. A good &lt;code&gt;hashCode&lt;/code&gt; implementation will return a hash code:
* Stable: does not change
* Evenly distributed: the hash codes of unequal objects tend to be unequal and the hash codes are evenly distributed across integer values.

The second point means that two different objects can have the same ''hash code'' so two objects with the same ''hash code'' are &lt;u&gt;not necessarily the same&lt;/u&gt;!

Since associative arrays depend on both the &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;hashCode&lt;/code&gt; methods, there is an important contract between these two methods that must be maintained if the objects are to be inserted into a &lt;code&gt;Map&lt;/code&gt;:

: For two objects ''a'' and ''b''
:* &lt;code&gt;a.equals(b) == b.equals(a)&lt;/code&gt;
:* if &lt;code&gt;a.equals(b)&lt;/code&gt; then &lt;code&gt;a.hashCode() == b.hashCode()&lt;/code&gt;
:* but &lt;del&gt;if &lt;code&gt;a.hashCode() == b.hashCode()&lt;/code&gt; then &lt;code&gt;a.equals(b)&lt;/code&gt;&lt;/del&gt;

In order to maintain this contract, a class that overrides the &lt;code&gt;equals&lt;/code&gt; method must also override the &lt;code&gt;hashCode&lt;/code&gt; method, and vice versa, so that &lt;code&gt;hashCode&lt;/code&gt; is based on the same properties (or a subset of the properties) as &lt;code&gt;equals&lt;/code&gt;.

A further contract that the map has with the object is that the results of the &lt;code&gt;hashCode&lt;/code&gt; and &lt;code&gt;equals&lt;/code&gt; methods will not change once the object has been inserted into the map.  For this reason, it is generally a good practice to base the hash function on immutable properties of the object.

=== The &lt;code&gt;toString&lt;/code&gt; method ===
The &lt;code&gt;java.lang.Object.toString()&lt;/code&gt; method returns a &lt;code&gt;java.lang.String&lt;/code&gt; that contains a text representation of the object.  The &lt;code&gt;'''''toString'''''&lt;/code&gt; method is implicitly called by the compiler when an object operand is used with the string concatenation operators (&lt;code&gt;+&lt;/code&gt; and &lt;code&gt;+=&lt;/code&gt;).

=== The wait and notify thread signaling methods ===
Every object has two wait lists for threads associated with it.  One wait list is used by the &lt;code&gt;synchronized&lt;/code&gt; keyword to acquire the mutex lock associated with the object.  If the mutex lock is currently held by another thread, the current thread is added to the list of blocked threads waiting on the mutex lock.  The other wait list is used for signaling between threads accomplished through the &lt;code&gt;wait&lt;/code&gt; and &lt;code&gt;notify&lt;/code&gt; and &lt;code&gt;notifyAll&lt;/code&gt; methods.

Use of wait/notify allows efficient coordination of tasks between threads.  When one thread needs to wait for another thread to complete an operation, or needs to wait until an event occurs, the thread can suspend its execution and wait to be notified when the event occurs.  This is in contrast to polling, where the thread repeatedly sleeps for a short period of time and then checks a flag or other condition indicator.  Polling is both more computationally expensive, as the thread has to continue checking, and less responsive since the thread won't notice the condition has changed until the next time to check.

==== The &lt;code&gt;wait&lt;/code&gt; methods ====
There are three overloaded versions of the &lt;code&gt;wait&lt;/code&gt; method to support different ways to specify the timeout value: &lt;code&gt;java.lang.Object.wait()&lt;/code&gt;, &lt;code&gt;java.lang.Object.wait(long)&lt;/code&gt; and &lt;code&gt;java.lang.Object.wait(long, int)&lt;/code&gt;.  The first method uses a timeout value of zero (0), which means that the wait does not timeout; the second method takes the number of milliseconds as a timeout; the third method takes the number of nanoseconds as a timeout, calculated as &lt;code&gt;1000000 * timeout + nanos&lt;/code&gt;.

The thread calling &lt;code&gt;wait&lt;/code&gt; is blocked (removed from the set of executable threads) and added to the object's wait list.  The thread remains in the object's wait list until one of three events occurs:
# another thread calls the object's &lt;code&gt;notify&lt;/code&gt; or &lt;code&gt;notifyAll&lt;/code&gt; method;
# another thread calls the thread's &lt;code&gt;java.lang.Thread.interrupt&lt;/code&gt; method; or
# a non-zero timeout that was specified in the call to &lt;code&gt;wait&lt;/code&gt; expires.

The &lt;code&gt;wait&lt;/code&gt; method must be called inside of a block or method synchronized on the object.  This insures that there are no race conditions between &lt;code&gt;wait&lt;/code&gt; and &lt;code&gt;notify&lt;/code&gt;.  When the thread is placed in the wait list, the thread releases the object's mutex lock.  After the thread is removed from the wait list and added to the set of executable threads, it must acquire the object's mutex lock before continuing execution.

==== The &lt;code&gt;notify&lt;/code&gt; and &lt;code&gt;notifyAll&lt;/code&gt; methods ====
The &lt;code&gt;java.lang.Object.notify()&lt;/code&gt; and &lt;code&gt;java.lang.Object.notifyAll()&lt;/code&gt; methods remove one or more threads from an object's wait list and add them to the set of executable threads.  &lt;code&gt;notify&lt;/code&gt; removes a single thread from the wait list, while &lt;code&gt;notifyAll&lt;/code&gt; removes all threads from the wait list.  Which thread is removed by &lt;code&gt;notify&lt;/code&gt; is unspecified and dependent on the JVM implementation.

The notify methods must be called inside of a block or method synchronized on the object.  This insures that there are no race conditions between &lt;code&gt;wait&lt;/code&gt; and &lt;code&gt;notify&lt;/code&gt;.

&lt;noinclude&gt;{{Status|100%}}
{{Programming/Navigation}}

[[de:Java Standard: Class]]
[[es:Programación en Java/Clases]]
[[fr:Programmation Java/Les classes en Java]]
[[it:Java/Classi e oggetti]]
[[nl:Programmeren in Java/Klassen]]
[[pt:Java/Introdução às classes]]
&lt;/noinclude&gt;</text>
      <sha1>pog7jjrvubmw1wzjpdwvafoq684zc89</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Packages</title>
    <ns>0</ns>
    <id>71422</id>
    <revision>
      <id>3295238</id>
      <parentid>3156985</parentid>
      <timestamp>2017-09-17T14:42:49Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6499">&lt;noinclude&gt;{{Displaytitle|title=Packages}}
{{Programming/Navigation}}
{{Java Programming/LanguageFundamentalsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

If your application becomes quite big, you may have lots of classes. Although you can browse them in their alphabetic order, it becomes confusing. So your application classes can be sorted into ''packages''.

A package is a name space that mainly contains classes and interfaces. For instance, the standard class &lt;code&gt;ArrayList&lt;/code&gt; is in the package &lt;code&gt;java.util&lt;/code&gt;. For this class, &lt;code&gt;java.util.ArrayList&lt;/code&gt; is called its ''fully qualified name'' because this syntax has no ambiguity. Classes in different packages can have the same name. For example, you have the two classes &lt;code&gt;java.util.Date&lt;/code&gt; and &lt;code&gt;java.sql.Date&lt;/code&gt; which are not the same. If no package is declared in a class, its package is the default package.

== Package declaration ==
In a class, a package is declared at the top of the source code using the keyword {{java:package}}:
{{XCode|1=&lt;span id="code-listing-14"&gt;'''Code listing 3.14: BusinessClass.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1"&gt;
package business;

public class BusinessClass {
}
&lt;/syntaxhighlight&gt;}}

If your class is declared in a package, say &lt;code&gt;business&lt;/code&gt;, your class must be placed in a subfolder called &lt;code&gt;business&lt;/code&gt; from the root of your application folder. This is how the compiler and the class loader find the Java files on the file system. You can declare your class in a subpackage, say &lt;code&gt;engine&lt;/code&gt;. So the full package is &lt;code&gt;business.engine&lt;/code&gt; and the class must be placed in a subsubfolder called &lt;code&gt;engine&lt;/code&gt; in the subfolder &lt;code&gt;business&lt;/code&gt; (not in a folder called &lt;code&gt;business.engine&lt;/code&gt;).

== Import and class usage ==
The simpliest way to use a class declared in a package is to prefix the class name with its package:
{{XExample|1='''Code section 3.88: Package declaration.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
business.BusinessClass myBusinessClass = new business.BusinessClass();
&lt;/syntaxhighlight&gt;}}

If you are using the class from a class in the same package, you don't have to specify the package. If another class with the same name exists in another package, it will use the local class.

The syntax above is a bit verbose. You can import the class by using the {{java:import}} Java keyword at the top of the file and then only specify its name:

{{XCode|1=&lt;span id="code-listing-15"&gt;'''Code listing 3.15: MyClass.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1"&gt;
import business.BusinessClass;

public class MyClass {
  public static void main(String[] args) {
    BusinessClass myBusinessClass = new BusinessClass();
  }
}
&lt;/syntaxhighlight&gt;}}

Note that you can't import two classes with the same name in two different packages.

The classes &lt;code&gt;Integer&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; belongs to the package &lt;code&gt;java.lang&lt;/code&gt; but they don't need to be imported as the &lt;code&gt;java.lang&lt;/code&gt; package is implicitly imported in all classes.

== Wildcard imports ==

It is possible to import an entire package, using an asterisk:
{{XExample|1='''Code section 3.89: Wildcard imports.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
import javax.swing.*;
&lt;/syntaxhighlight&gt;}}

While it may seem convenient, it may cause problems if you make a typographical error.  For example, if you use the above import to use JFrame, but then type &lt;code&gt;JFraim frame = new JFraim();&lt;/code&gt;, the Java compiler will report an error similar to "Cannot find symbol: JFraim".  Even though it seems as if it was imported,  the compiler is giving the error report at the first mention of JFraim, which is half-way through your code, instead of the point where you imported JFrame along with everything else in javax.swing.

If you change this to &lt;code&gt;import javax.swing.JFraim;&lt;/code&gt; the error will be at the import instead of within your code.

Furthermore, if you &lt;code&gt;import javax.swing.*;&lt;/code&gt; and &lt;code&gt;import java.util.*;&lt;/code&gt;, and javax.swing.Queue is later added in a future version of Java, your code that uses Queue (java.util) will fail to compile.  This particular example is fairly unlikely, but if you are working with non-Oracle libraries, it may be more likely to happen.

== Package convention ==
A package name should start with a lower character. This eases to distinguish a package from a class name. In some operating systems, the directory names are not case sensitive. So package names should be lowercase.

The Java package needs to be unique across Vendors to avoid name collisions. For that reason Vendors usually use their domain name in reverse order. That is guaranteed to be unique.  For example a company called ''Your Company Inc.'', would use a package name something like this: &lt;code&gt;com.yourcompany.yourapplicationname.yourmodule.YourClass&lt;/code&gt;.

== Importing packages from .jar files ==
If you are importing library packages and classes that reside in a &lt;code&gt;.jar&lt;/code&gt; file, you must ensure that the file is in the current classpath (both at compile- and execution-time). Apart from this requirement, importing these packages and classes is the same as if they were in their full, expanded, directory structure.

=== Javac ===
For example, to compile and run a class from a project's top directory (that contains the two directories &lt;code&gt;/source&lt;/code&gt; and &lt;code&gt;/libraries&lt;/code&gt;) you could use the following command:

{{XCode|1='''Compilation'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
$ javac -classpath libraries/lib.jar source/MainClass.java
&lt;/pre&gt;}}

And then to run it, similarly:

{{XCode|1='''Execution'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
$ java -classpath libraries/lib.jar source/MainClass
&lt;/pre&gt;}}

The above is simplified, and demands that &lt;code&gt;MainClass&lt;/code&gt; be in the default package, or a package called &lt;code&gt;source&lt;/code&gt;, which isn't very desirable.

=== BlueJ ===
With BlueJ just click on ''Tools, Preferences, Libraries'', and add the .jar one by one.

== Class loading/package ==
The runtime identity of a class in Java is defined by the fully qualified class name and its defining class loader. This means that the same class, loaded by two different class loaders, is seen by the Virtual Machine as two completely different types.

&lt;noinclude&gt;
{{Programming/Navigation}}
{{Status|100%}}

[[fr:Programmation Java/Extensions]]
[[it:Java/Package]]
&lt;/noinclude&gt;</text>
      <sha1>358wzlvcru0pu6i8bv3ug8svdfao8e5</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Arrays</title>
    <ns>0</ns>
    <id>56685</id>
    <revision>
      <id>3295177</id>
      <parentid>3075101</parentid>
      <timestamp>2017-09-17T14:40:53Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9075">&lt;noinclude&gt;{{Displaytitle|title=Arrays}}
{{Programming/Navigation}}
{{Java Programming/LanguageFundamentalsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;
An '''array''' is similar to a table of objects or primitive types, keyed by index. You may have noticed the strange parameter of the default &lt;code&gt;main()&lt;/code&gt; method (&lt;code&gt;String[] args&lt;/code&gt;) since the beginning of the book. It is an array. Let's handle this parameter:

{| style="width: 100%;"
|valign="top"|{{XCode|1=&lt;span id="code-listing-15"&gt;'''Code listing 3.15: The default array parameter.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2"&gt;
public class ArrayExample {
  public static void main(String[] args) {
    for (int i = 0; i &lt; args.length; ++i) {
      System.out.println("Argument #" + (i + 1) + ": " + args[i]);
    }
  }
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XCode|1='''Console for Code listing 3.15'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
$ java ArrayExample This is a test
Argument #1 This
Argument #2 is
Argument #3 a
Argument #4 test
&lt;/pre&gt;}}
|}

In the [[#code-listing-15|code listing 3.15]], the array is &lt;code&gt;args&lt;/code&gt;. It is an array of &lt;code&gt;String&lt;/code&gt; objects (here those objects are the words that have been typed by the user at the program launching). At line 4, One contained object is accessed using its index in the array. You can see that its value is printed on the standard output. Note that the strings have been put in the array with the right order.

== Fundamentals ==

In Java, an array is an object. This object has a given type for the contained primitive types or objects (&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, ...). An array can be declared in several ways:

{{XExample|1=&lt;span id="code-section-52"&gt;'''Code section 3.52: Array declarations.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int[] array1 = null;
int array2[] = null;
&lt;/syntaxhighlight&gt;}}

Those syntaxes are identical but the first one is recommended. It can also be instantiated in several ways:
{{XExample|1=&lt;span id="code-section-53"&gt;'''Code section 3.53: Array instantiations.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
array1 = new int[10];
int[] array0 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; //this only works in the declaration
array1 = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
&lt;/syntaxhighlight&gt;}}
At line 1, we instantiate an array of 10 items that get the default value (which is 0 for &lt;code&gt;int&lt;/code&gt;). At lines 2 and 3, we instantiate arrays of 10 given items. It will each be given an index according to its order. We can know the size of the array using the &lt;code&gt;length&lt;/code&gt; attribute:

{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-54"&gt;'''Code section 3.54: The array size.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3"&gt;
int nbItems = 10;
Object[] array3 = new Object[nbItems];
System.out.println(array3.length);
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XCode|1='''Output for Code section 3.54'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
10
&lt;/pre&gt;}}
|}

Arrays are allocated at runtime, so the specified size in an array creation expression may be a variable (rather than a constant expression as in C). However, the size of an instantiated array never changes. If you need to change the size, you have to create a new instance. Items can be accessed by their index. Beware! The first index is 0:

{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-55"&gt;'''Code section 3.55: The array indexes.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2-4"&gt;
char[] array4 = {'a', 'b', 'c', 'd', 'e'};
System.out.println(array4[2]);
array4[4] = 'z';
System.out.println(array4[4]);
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XCode|1='''Output for Code section 3.55'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
c
z
&lt;/pre&gt;}}
|}

If you attempt to access to a too high index or negative index, you will get an &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;.

{{Java/Hidden begin|title=Test your knowledge}}
'''Question 3.20''': Consider the following code:

{{XCode|1=&lt;span id="question-20"&gt;'''Question 3.20: Question20.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public class Question20 {
  public static void main(String[] args) {
    String[] listOfWord = {"beggars", "can't", "be", "choosers"};
    System.out.println(listOfWord[1]);
    System.out.println(listOfWord[listOfWord.length-1]);
  }
}
&lt;/syntaxhighlight&gt;}}

What will be printed in the standard output?
{{Java/Hidden begin|title=Answer}}
{{XCode|1='''Output for Question 3.20'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
can't
choosers
&lt;/pre&gt;}}
Indexes start at 0. So the index 1 point at the second string (&lt;code&gt;can't&lt;/code&gt;). There are 4 items so the size of the array is 4. Hence the item pointed by the index 3 is the last one (&lt;code&gt;choosers&lt;/code&gt;).
{{Hidden end}}
{{Hidden end}}

==Two-Dimensional Arrays==
Actually, there are no two-dimensional arrays in Java. However, an array can contain any class of object, including an array:
{{XExample|1=&lt;span id="code-section-56"&gt;'''Code section 3.56: Two-dimensional arrays.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
String[][] twoDimArray = {{"a", "b", "c", "d", "e"},
                          {"f", "g", "h", "i", "j"},
                          {"k", "l", "m", "n", "o"}};

int[][] twoDimIntArray = {{ 0,  1,  2,  3,  4},
                          {10, 11, 12, 13, 14},
                          {20, 21, 22, 23, 24}};
&lt;/syntaxhighlight&gt;}}
It's not exactly equivalent to two-dimensional arrays because the size of the sub-arrays may vary. The sub-array reference can even be null. Consider:

{{XExample|1=&lt;span id="code-section-57"&gt;'''Code section 3.57: Weird two-dimensional array.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
String[][] weirdTwoDimArray = {{"10", "11", "12"},
                               null,
                               {"20", "21", "22", "23", "24"}};
&lt;/syntaxhighlight&gt;}}

Note that the length of a two-dimensional array is the number of one-dimensional arrays it contains. In the above example, &lt;code&gt;weirdTwoDimArray.length&lt;/code&gt; is 3, whereas &lt;code&gt;weirdTwoDimArray[2].length&lt;/code&gt; is 5.

In the [[#code-section-58|code section 3.58]], we defined an array that has three elements, each element contains an array having 5 elements. We could create the array having the 5 elements first and use that one in the initialize block.

{{XExample|1=&lt;span id="code-section-58"&gt;'''Code section 3.58: Included array.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
String[] oneDimArray = {"00", "01", "02", "03", "04"};
String[][] twoDimArray = {oneDimArray,
                          {"10", "11", "12", "13", "14"},
                          {"20", "21", "22", "23", "24"}};
&lt;/syntaxhighlight&gt;}}

{{Java/Hidden begin|title=Test your knowledge}}
'''Question 3.21''': Consider the following code:

{{XExample|1=&lt;span id="question-21"&gt;'''Question 3.21: The alphabet.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
String[][] alphabet = {{"a", "b", "c", "d", "e"},
                          {"f", "g", "h", "i", "j"},
                          {"k", "l", "m", "n", "o"},
                          {"p", "q", "r", "s", "t"},
                          {"u", "v", "w", "x", "y"},
                          {"z"}};
&lt;/syntaxhighlight&gt;}}

Print the whole alphabet in the standard output.
{{Java/Hidden begin|title=Answer}}
{{XCode|1=&lt;span id="question-21"&gt;'''Question 3.21: Answer21.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="10-14"&gt;
public class Answer21 {
  public static void main(String[] args) {
    String[][] alphabet = {{"a", "b", "c", "d", "e"},
                          {"f", "g", "h", "i", "j"},
                          {"k", "l", "m", "n", "o"},
                          {"p", "q", "r", "s", "t"},
                          {"u", "v", "w", "x", "y"},
                          {"z"}};

    for (int i = 0; i &lt; alphabet.length; i++) {
      for (int j = 0; j &lt; alphabet[i].length; j++) {
        System.out.println(alphabet[i][j]);
      }
    }
  }
}
&lt;/syntaxhighlight&gt;}}
&lt;code&gt;i&lt;/code&gt; will be the indexes of the main array and &lt;code&gt;j&lt;/code&gt; will be the indexes of all the sub-arrays. We have to first iterate on the main array. We have to read the size of the array. Then we iterate on each sub-array. We have to read the size of each array as it may vary. Doing so, we iterate on all the sub-array items using the indexes. All the items will be read in the right order.
{{Hidden end}}
{{Hidden end}}

== Multidimensional Array ==
Going further any number of dimensional array can be defined.
{| style="margin: auto;"
|'''''elementType'''''[][]...[] '''''arrayName'''''
|}
or
{| style="margin: auto;"
|'''''elementType''''' '''''arrayName'''''[][]...[]
|}

&lt;noinclude&gt;{{Status|100%}}
{{Programming/Navigation}}

&lt;!--Interwikis--&gt;
[[de:Java_Standard: Felder]]
[[es:Programación en Java/Arrays]]
[[fr:Programmation Java/Tableaux]]
[[nl:Programmeren in Java/Arrays]]
[[pt:Java/Vetores]]&lt;/noinclude&gt;</text>
      <sha1>nfnjzwtrwhu79qi8zzvn5g2khnvv4rz</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Mathematical functions</title>
    <ns>0</ns>
    <id>215564</id>
    <revision>
      <id>3295231</id>
      <parentid>3246355</parentid>
      <timestamp>2017-09-17T14:42:36Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="28845">&lt;noinclude&gt;{{Displaytitle|title=Mathematical functions}}
{{Programming/Navigation}}
{{Java Programming/LanguageFundamentalsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;
The &lt;code&gt;java.lang.Math&lt;/code&gt; class allows the use of many common mathematical functions that can be used while creating programs.

Since it is in the &lt;code&gt;java.lang&lt;/code&gt; package, the &lt;code&gt;Math&lt;/code&gt; class does not need to be imported. However, in programs extensively utilizing these functions, a static import can be used.

== Math constants ==
There are two constants in the &lt;code&gt;Math&lt;/code&gt; class that are fairly accurate approximations of irrational mathematical numbers.

=== Math.E ===
The &lt;code&gt;Math.E&lt;/code&gt; constant represents the value of [[w:Euler's number|Euler's number]] (''e''), the base of the natural logarithm.
{{XExample|1='''Code section 3.20: &lt;code&gt;Math.E&lt;/code&gt;'''
&lt;syntaxhighlight lang="Java" line start="1"&gt;
public static final double E = 2.718281828459045;
&lt;/syntaxhighlight&gt;}}

=== Math.PI ===
The &lt;code&gt;Math.PI&lt;/code&gt; constant represents the value of [[w:Pi|pi]], the ratio of a circle's circumference to its diameter.
{{XExample|1='''Code section 3.21: &lt;code&gt;Math.PI&lt;/code&gt;'''
&lt;syntaxhighlight lang="Java" line start="1"&gt;
public static final double PI = 3.141592653589793;
&lt;/syntaxhighlight&gt;}}

== Math methods ==

=== Exponential methods ===
[[File:Java Programming.pdf|thumb]]
There are several methods in the &lt;code&gt;Math&lt;/code&gt; class that deal with exponential functions.
==== [[Exponentiation]] ====
The power method, &lt;code&gt;double Math.'''pow'''(double, double)&lt;/code&gt;, returns the first parameter to the power of the second parameter.  For example, a call to &lt;code&gt;Math.pow(2, 10)&lt;/code&gt; will return a value of 1024 (2&lt;sup&gt;10&lt;/sup&gt;).

The &lt;code&gt;Math.'''exp'''(double)&lt;/code&gt; method, a special case of &lt;code&gt;pow&lt;/code&gt;, returns ''e'' to the power of the parameter. In addition, &lt;code&gt;double Math.'''expm1'''(double)&lt;/code&gt; returns (''e''&lt;sup&gt;x&lt;/sup&gt; - 1). Both of these methods are more accurate and convenient in these special cases.

Java also provides special cases of the pow function for square roots and cube roots of doubles, &lt;code&gt;double Math.'''sqrt'''(double)&lt;/code&gt; and &lt;code&gt;double Math.'''cbrt'''(double)&lt;/code&gt;.

=== Logarithms ===
Java has no general logarithm function; when needed this can be simulated using the change-of-base theorem.

&lt;code&gt;{{Java:double}} Math.'''log'''({{Java:double}})&lt;/code&gt; returns the natural logarithm of the parameter ('''not the common logarithm''', as its name suggests!).

&lt;code&gt;{{Java:double}} Math.'''log10'''({{Java:double}})&lt;/code&gt; returns the common (base-10) logarithm of the parameter.

&lt;code&gt;{{Java:double}} Math.'''log1p'''({{Java:double}})&lt;/code&gt; returns ln(parameter+1). It is recommended for small values.

=== Trigonometric and hyperbolic methods ===
The trigonometric methods of the &lt;code&gt;Math&lt;/code&gt; class allow users to easily deal with trigonometric functions in programs. All accept only {{Java:double}}s. Please note that all values using these methods are initially passed and returned in '''radians''', ''not degrees''.  However, conversions are possible.

==== Trigonometric functions ====
The three main trigonometric methods are &lt;code&gt;Math.'''sin'''(x)&lt;/code&gt;, &lt;code&gt;Math.'''cos'''(x)&lt;/code&gt;, and &lt;code&gt;Math.'''tan'''(x)&lt;/code&gt;, which are used to find the sine, cosine, and tangent, respectively, of any given number. So, for example, a call to &lt;code&gt;Math.sin(Math.PI/2)&lt;/code&gt; would return a value of about 1.  Although methods for finding the cosecant, secant, and cotangent are not available, these values can be found by taking the reciprocal of the sine, cosine, and tangent, respectively.  For example, the cosecant of pi/2 could be found using &lt;code&gt;1/Math.sin(Math.PI/2)&lt;/code&gt;.

==== Inverse trigonometric functions ====
Java provides inverse counterparts to the trigonometric functions: &lt;code&gt;Math.'''asin'''(x)&lt;/code&gt;, and &lt;code&gt;Math.'''acos'''(x)&lt;/code&gt;, &lt;code&gt;Math.'''atan'''(x)&lt;/code&gt;.

==== Hyperbolic functions ====
In addition, hyperbolic functions are available: &lt;code&gt;Math.'''sinh'''(x)&lt;/code&gt;, &lt;code&gt;Math.'''cosh'''(x)&lt;/code&gt;, and &lt;code&gt;Math.'''tanh'''(x)&lt;/code&gt;.

==== Radian/degree conversion ====
To convert between degree and radian measures of angles, two methods are available, &lt;code&gt;Math.'''toRadians'''(x)&lt;/code&gt; and &lt;code&gt;Math.'''toDegrees'''(x)&lt;/code&gt;.  While using &lt;code&gt;Math.toRadians(x)&lt;/code&gt;, a degrees value must be passed in, and that value in radians (the degree value multiplied by pi/180) will be returned.  The &lt;code&gt;Math.toDegrees(x)&lt;/code&gt; method takes in a value in radians and the value in degrees (the radian value multiplied by 180/pi) is returned.

=== Absolute value: &lt;code&gt;Math.abs&lt;/code&gt; ===
The absolute value method of the &lt;code&gt;Math&lt;/code&gt; class is compatible with the {{Java:int}}, {{Java:long}}, {{Java:float}}, and {{Java:double}} types. The data returned is the absolute value of parameter (how far away it is from zero) in the same data type.  For example:
{{XExample|1='''Code section 3.22: &lt;code&gt;Math.abs&lt;/code&gt;'''
&lt;syntaxhighlight lang="Java" line start="1"&gt;
int result = Math.abs(-3);
&lt;/syntaxhighlight&gt;}}
In this example, &lt;code&gt;result&lt;/code&gt; will contain a value of 3.

=== Maximum and minimum values ===
These methods are very simple comparing functions.  Instead of using {{Java:if}}...{{Java:else}} statements, one can use the &lt;code&gt;Math.max(x1, x2)&lt;/code&gt; and &lt;code&gt;Math.min(x1, x2)&lt;/code&gt; methods.  The &lt;code&gt;Math.max(x1, x2)&lt;/code&gt; simply returns the greater of the two values, while the &lt;code&gt;Math.min(x1, x2)&lt;/code&gt; returns the lesser of the two.  Acceptable types for these methods include {{Java:int}}, {{Java:long}}, {{Java:float}}, and {{Java:double}}.

== Functions dealing with floating-point representation ==
Java 1.5 and 1.6 introduced several non-mathematical functions specific to the computer floating-point representation of numbers.

&lt;code&gt;Math.'''ulp'''({{Java:double}})&lt;/code&gt; and &lt;code&gt;Math.'''ulp'''({{Java:float}})&lt;/code&gt; return an ulp, the smallest value which, when added to the argument, would be recognized as larger than the argument.

&lt;code&gt;Math.copySign&lt;/code&gt; returns the value of the first argument with the sign of the second argument. It can be used to determine the sign of a zero value.

&lt;code&gt;Math.getExponent&lt;/code&gt; returns (as an {{Java:int}}) the exponent used to scale the floating-point argument in computer representation.

== Rounding number example ==

Sometimes, we are not only interested in mathematically correct rounded numbers, but we want that a fixed number of significant digits are always displayed, regardless of the number used. Here is an example program that returns always the correct string. You are invited to modify it such that it does the same and is simpler!

The constant class contains repeating constants that should exist only once in the code so that to avoid inadvertent changes. (If the one constant is changed inadvertently, it is most likely to be seen, as it is used at several locations.)
{{XCode|1=&lt;span id="code-listing-20"&gt;'''Code listing 3.20: StringUtils.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
/**
 * Class that comprises of constant values &amp; string utilities.
 *
 * @since 2013-09-05
 * @version 2014-10-14
 */
public class StringUtils {
	/** Dash or minus constant */
	public static final char DASH = '-'; 
	/** The exponent sign in a scientific number, or the capital letter E */
	public static final char EXPONENT = 'E';
	/** The full stop or period */
	public static final char PERIOD = '.';
	/** The zero string constant used at several places */
	public static final String ZERO = "0";

	/**
	 * Removes all occurrences of the filter character in the text.
	 *
	 * @param text Text to be filtered
	 * @param filter The character to be removed.
	 * @return the string
	 */
	public static String filter(final String text, final String filter) {
		final String[] words = text.split("[" + filter + "]");

		switch (words.length) {
			case 0: return text;
			case 1: return words[0];
			default:
				final StringBuilder filteredText = new StringBuilder();

				for (final String word : words) {
					filteredText.append(word);
				}

				return filteredText.toString();
		}
	}
}
&lt;/syntaxhighlight&gt;}}

The MathsUtils class is like an addition to the &lt;code&gt;java.lang.Math&lt;/code&gt; class and contains the rounding calculations.
{{XCode|1=&lt;span id="code-listing-21"&gt;'''Code listing 3.21: MathsUtils.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
package string;

/**
 * Class for special mathematical calculations.&lt;br/&gt;
 * ATTENTION:&lt;br/&gt;Should depend only on standard Java libraries!
 *
 * @since 2013-09-05
 * @version 2014-10-14
*/
public class MathsUtils {

	// CONSTANTS
	// ------------------------------------------

	/** The exponent sign in a scientific number, or the capital letter E. */
	public static final char EXPONENT = 'E';

	/** Value after which the language switches from scientific to double */
	private static final double E_TO_DOUBLE = 1E-3;

	/** The zero string constant used at several places. */
	public static final String ZERO = "0";

	/** The string of zeros */
	private static final String ZEROS = "000000000000000000000000000000000";

	// METHODS
	// ------------------------------------------

	/**
	 * Determines, if the number uses a scientific representation.
	 *
	 * @param number the number
	 * @return true, if it is a scientific number, false otherwise
	 */
	private static boolean isScientific(final double number) {
		return ((new Double(number)).toString().indexOf(EXPONENT) &gt; 0);
	}

	/**
	 * Determines how many zeros are to be appended after the decimal digits.
	 *
	 * @param significantsAfter Requested significant digits after decimal
	 * @param separator Language-specific decimal separator
	 * @param number Rounded number
	 * @return Requested value
	 */
	private static byte calculateMissingSignificantZeros(
			final byte significantsAfter,
			final char separator,
			final double number) {

		final byte after = findSignificantsAfterDecimal(separator, number);

		final byte zeros =
				(byte) (significantsAfter - ((after == 0) ? 1 : after));

		return ((zeros &gt;= 0) ? zeros : 0);
	}

	/**
	 * Finds the insignificant zeros after the decimal separator.
	 *
	 * @param separator Language-specific decimal separator
	 * @param number the number
	 * @return the byte
	 */
	private static byte findInsignificantZerosAfterDecimal(
			final char separator,
			final double number) {

		if ((Math.abs(number) &gt;= 1) || isScientific(number)) {
			return 0;
		} else {
			final StringBuilder string = new StringBuilder();

			string.append(number);
			string.delete(0,
					string.indexOf(new Character(separator).toString()) + 1);

			// Determine what to match:
			final String regularExpression = "[1-9]";

			final String[] split = string.toString().split(regularExpression);

			return (split.length &gt; 0) ? (byte) split[0].length() : 0;
		}
	}

	/**
	 * Calculates the number of all significant digits (without the sign and
	 * the decimal separator).
	 *
	 * @param significantsAfter Requested significant digits after decimal
	 * @param separator Language-specific decimal separator
	 * @param number Value where the digits are to be counted
	 * @return Number of significant digits
	 */
	private static byte findSignificantDigits(final byte significantsAfter,
			final char separator,
			final double number) {

		if (number == 0) { return 0; }
		else {
			String mantissa =
					findMantissa(separator, new Double(number).toString());

			if (number == (long)number) {
				mantissa = mantissa.substring(0, mantissa.length() - 1);
			}

			mantissa = retrieveDigits(separator, mantissa);
			// Find the position of the first non-zero digit:
			short nonZeroAt = 0;

			for (; (nonZeroAt &lt; mantissa.length())
					&amp;&amp; (mantissa.charAt(nonZeroAt) == '0'); nonZeroAt++) ;

			return (byte)mantissa.substring(nonZeroAt).length();
		}
	}
	
	/**
	 * Determines the number of significant digits after the decimal separator
	 * knowing the total number of significant digits and the number before the
	 * decimal separator.
	 *
	 * @param significantsBefore Number of significant digits before separator
	 * @param significantDigits Number of all significant digits
	 * @return Number of significant decimals after the separator
	 */
	private static byte findSignificantsAfterDecimal(
			final byte significantsBefore,
			final byte significantDigits) {

		final byte afterDecimal =
				(byte) (significantDigits - significantsBefore);

		return (byte) ((afterDecimal &gt; 0) ? afterDecimal : 0);
	}

	/**
	 * Determines the number of digits before the decimal point.
	 *
	 * @param separator Language-specific decimal separator
	 * @param number Value to be scrutinised
	 * @return Number of digits before the decimal separator
	 */
	private static byte findSignificantsBeforeDecimal(final char separator,
													final double number) {

		final String value = new Double(number).toString();

		// Return immediately, if result is clear: Special handling at
		// crossroads of floating point and exponential numbers:
		if ((number == 0) || (Math.abs(number) &gt;= E_TO_DOUBLE)
				&amp;&amp; (Math.abs(number) &lt; 1)) {

			return 0;
		} else if ((Math.abs(number) &gt; 0) &amp;&amp; (Math.abs(number) &lt; E_TO_DOUBLE)) {
			return 1;
		} else {
			byte significants = 0;
			// Significant digits to the right of decimal separator:
			for (byte b = 0; b &lt; value.length(); b++) {
				if (value.charAt(b) == separator) {
					break;
				} else if (value.charAt(b) != StringUtils.DASH) {
					significants++;
				}
			}

			return significants;
		}
	}

	/**
	 * Returns the exponent part of the double number.
	 *
	 * @param number Value of which the exponent is of interest
	 * @return Exponent of the number or zero.
	 */
	private static short findExponent(final double number) {
		return new Short(findExponent((new Double(number)).toString()));
	}

	/**
	 * Finds the exponent of a number.
	 *
	 * @param value Value where an exponent is to be searched
	 * @return Exponent, if it exists, or "0".
	 */
	private static String findExponent(final String value) {
		final short exponentAt = (short) value.indexOf(EXPONENT);

		if (exponentAt &lt; 0) { return ZERO; }
		else {
			return value.substring(exponentAt + 1);
		}
	}

	/**
	 * Finds the mantissa of a number.
	 *
	 * @param separator Language-specific decimal separator
	 * @param value Value where the mantissa is to be found
	 * @return Mantissa of the number
	 */
	private static String findMantissa(final char separator,
										final String value) {

		String strValue = value;

		final short exponentAt = (short) strValue.indexOf(EXPONENT);

		if (exponentAt &gt; -1) {
			strValue = strValue.substring(0, exponentAt);
		}
		return strValue;
	}

	/**
	 * Retrieves the digits of the value without decimal separator or sign.
	 *
	 * @param separator
	 * @param number Mantissa to be scrutinised
	 * @return The digits only
	 */
	private static String retrieveDigits(final char separator, String number) {
		// Strip off exponent part, if it exists:
		short eAt = (short)number.indexOf(EXPONENT);

		if (eAt &gt; -1) {
			number = number.substring(0, eAt);
		}

		return number.replace((new Character(StringUtils.DASH)).toString(), "").
				replace((new Character(separator)).toString(), "");
	}


	// ---- Public methods ----------------------

	/**
	 * Returns the number of digits in the long value.
	 *
	 * @param value the value
	 * @return the byte
	 */
	public static byte digits(final long value) {
		return (byte) StringUtils.filter(Long.toString(value), ".,").length();
	}

	/**
	 * Finds the significant digits after the decimal separator of a mantissa.
	 *
	 * @param separator Language-specific decimal separator
	 * @param number Value to be scrutinised
	 * @return Number of significant zeros after decimal separator.
	 */
	public static byte findSignificantsAfterDecimal(final char separator,
													final double number) {

		if (number == 0) { return 1; }
		else {
			String value = (new Double(number)).toString();

			final short separatorAt = (short) value.indexOf(separator);

			if (separatorAt &gt; -1) {
				value = value.substring(separatorAt + 1);
			}

			final short exponentAt = (short) value.indexOf(EXPONENT);

			if (exponentAt &gt; 0) {
				value = value.substring(0, exponentAt);
			}

			final Long longValue = new Long(value).longValue();

			if (Math.abs(number) &lt; 1) {
				return (byte) longValue.toString().length();
			} else if (longValue == 0) {
				return 0;
			} else {
				return (byte) (("0." + value).length() - 2);
			}
		}
	}

	/**
	 * Calculates the power of the base to the exponent without changing the
	 * least-significant digits of a number.
	 *
	 * @param basis
	 * @param exponent
	 * @return basis to power of exponent
	 */
	public static double power(final int basis, final short exponent) {
		return power((short) basis, exponent);
	}

	/**
	 * Calculates the power of the base to the exponent without changing the
	 * least-significant digits of a number.
	 *
	 * @param basis the basis
	 * @param exponent the exponent
	 * @return basis to power of exponent
	 */
	public static double power(final short basis, final short exponent) {
		if (basis == 0) {
			return (exponent != 0) ? 1 : 0;
		} else {
			if (exponent == 0) {
				return 1;
			} else {
				// The Math method power does change the least significant
				// digits after the decimal separator and is therefore useless.
				double result = 1;
				short s = 0;

				if (exponent &gt; 0) {
					for (; s &lt; exponent; s++) {
						result *= basis;
					}
				} else if (exponent &lt; 0) {
					for (s = exponent; s &lt; 0; s++) {
						result /= basis;
					}
				}

				return result;
			}
		}
	}

	/**
	 * Rounds a number to the decimal places.
	 *
	 * @param significantsAfter Requested significant digits after decimal
	 * @param separator Language-specific decimal separator
	 * @param number Number to be rounded
	 * @return Rounded number to the requested decimal places
	 */
	public static double round(final byte significantsAfter,
								final char separator,
								final double number) {

		if (number == 0) { return 0; }
		else {
			final double constant = power(10, (short)
					(findInsignificantZerosAfterDecimal(separator, number)
							+ significantsAfter));
			final short dExponent = findExponent(number);

			short exponent = dExponent;

			double value = number*constant*Math.pow(10, -exponent);
			final String exponentSign =
					(exponent &lt; 0) ? String.valueOf(StringUtils.DASH) : "";

			if (exponent != 0) {
				exponent = (short) Math.abs(exponent);

				value = round(value);
			} else {
				value = round(value)/constant;
			}

			// Power method cannot be used, as the exponentiated number may
			// exceed the maximal long value.
			exponent -= Math.signum(dExponent)*(findSignificantDigits
					(significantsAfter, separator, value) - 1);

			if (dExponent != 0) {
				String strValue = Double.toString(value);

				strValue = strValue.substring(0, strValue.indexOf(separator))
						+ EXPONENT + exponentSign + Short.toString(exponent);

				value = new Double(strValue);
			}

			return value;
		}
	}

	/**
	 * Rounds a number according to mathematical rules.
	 *
	 * @param value the value
	 * @return the double
	 */
	public static double round(final double value) {
		return (long) (value + .5);
	}

	/**
	 * Rounds to a fixed number of significant digits.
	 *
	 * @param significantDigits Requested number of significant digits
	 * @param separator Language-specific decimal separator
	 * @param dNumber Number to be rounded
	 * @return Rounded number
	 */
	public static String roundToString(final byte significantDigits,
										final char separator,
										double dNumber) {
										
		// Number of significants that *are* before the decimal separator:
		final byte significantsBefore =
			findSignificantsBeforeDecimal(separator, dNumber);
		// Number of decimals that *should* be after the decimal separator:
		final byte significantsAfter = findSignificantsAfterDecimal(
				significantsBefore, significantDigits);
		// Round to the specified number of digits after decimal separator:
		final double rounded = MathsUtils.round(significantsAfter, separator, dNumber);

		final String exponent = findExponent((new Double(rounded)).toString());
		final String mantissa = findMantissa(separator,
						(new Double(rounded)).toString());

		final double dMantissa = new Double(mantissa).doubleValue();
		final StringBuilder result = new StringBuilder(mantissa);
		// Determine the significant digits in this number:
		final byte significants = findSignificantDigits(significantsAfter,
				separator, dMantissa);
		// Add lagging zeros, if necessary:
		if (significants &lt;= significantDigits) {
			if (significantsAfter != 0) {
				result.append(ZEROS.substring(0,
						calculateMissingSignificantZeros(significantsAfter,
								separator, dMantissa)));
			} else {
				// Cut off the decimal separator &amp; after decimal digits:
				final short decimal = (short) result.indexOf(
						new Character(separator).toString());

				if (decimal &gt; -1) {
					result.setLength(decimal);
				}
			}
		} else if (significantsBefore &gt; significantDigits) {
			dNumber /= power(10, (short) (significantsBefore - significantDigits));

			dNumber = round(dNumber);

			final short digits =
					(short) (significantDigits + ((dNumber &lt; 0) ? 1 : 0));

			final String strDouble = (new Double(dNumber)).toString().substring(0, digits);

			result.setLength(0);
			result.append(strDouble + ZEROS.substring(0,
					significantsBefore - significantDigits));
		}

		if (new Short(exponent) != 0) {
			result.append(EXPONENT + exponent);
		}

		return result.toString();
	} // public static String roundToString(…)

	/**
	 * Rounds to a fixed number of significant digits.
	 *
	 * @param separator Language-specific decimal separator
	 * @param significantDigits Requested number of significant digits
	 * @param value Number to be rounded
	 * @return Rounded number
	 */
	public static String roundToString(final char separator,
										final int significantDigits,
										float value) {

		return roundToString((byte)significantDigits, separator,
				(double)value);
	}
} // class MathsUtils
&lt;/syntaxhighlight&gt;}}

The code is tested with the following [[w:JUnit|JUnit]] test:

{{XCode|1=&lt;span id="code-listing-21"&gt;'''Code listing 3.22: MathsUtilsTest.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
package string;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.Vector;

import org.junit.Test;

/**
 * The JUnit test for the &lt;code&gt;MathsUtils&lt;/code&gt; class.
 *
 * @since 2013-03-26
 * @version 2014-10-14
 */
public class MathsUtilsTest {

	/**
	 * Method that adds a negative and a positive value to values.
	 *
	 * @param d the double value
	 * @param values the values
	 */
	private static void addValue(final double d, Vector&lt;Double&gt; values) {
		values.add(-d);
		values.add(d);
	}

	// Public methods ------

	/**
	 * Tests the round method with a double parameter.
	 */
	@Test
	public void testRoundToStringDoubleByteCharDouble() {
		// Test rounding
		final Vector&lt;Double&gt; values = new Vector&lt;Double&gt;();
		final Vector&lt;String&gt; strValues = new Vector&lt;String&gt;();

		values.add(0.0);
		strValues.add("0.00000");
		addValue(1.4012984643248202e-45, values);
		strValues.add("-1.4012E-45");
		strValues.add("1.4013E-45");
		addValue(1.999999757e-5, values);
		strValues.add("-1.9999E-5");
		strValues.add("2.0000E-5");
		addValue(1.999999757e-4, values);
		strValues.add("-1.9999E-4");
		strValues.add("2.0000E-4");
		addValue(1.999999757e-3, values);
		strValues.add("-0.0019999");
		strValues.add("0.0020000");
		addValue(0.000640589, values);
		strValues.add("-6.4058E-4");
		strValues.add("6.4059E-4");
		addValue(0.3396899998188019, values);
		strValues.add("-0.33968");
		strValues.add("0.33969");
		addValue(0.34, values);
		strValues.add("-0.33999");
		strValues.add("0.34000");
		addValue(7.07, values);
		strValues.add("-7.0699");
		strValues.add("7.0700");
		addValue(118.188, values);
		strValues.add("-118.18");
		strValues.add("118.19");
		addValue(118.2, values);
		strValues.add("-118.19");
		strValues.add("118.20");
		addValue(123.405009, values);
		strValues.add("-123.40");
		strValues.add("123.41");
		addValue(30.76994323730469, values);
		strValues.add("-30.769");
		strValues.add("30.770");
		addValue(130.76994323730469, values);
		strValues.add("-130.76");
		strValues.add("130.77");
		addValue(540, values);
		strValues.add("-539.99");
		strValues.add("540.00");
		addValue(12345, values);
		strValues.add("-12344");
		strValues.add("12345");
		addValue(123456, values);
		strValues.add("-123450");
		strValues.add("123460");
		addValue(540911, values);
		strValues.add("-540900");
		strValues.add("540910");
		addValue(9.223372036854776e56, values);
		strValues.add("-9.2233E56");
		strValues.add("9.2234E56");

		byte i = 0;
		final byte significants = 5;

		for (final double element : values) {
			final String strValue;

			try {
				strValue = MathsUtils.roundToString(significants, StringUtils.PERIOD, element);

				System.out.println(" MathsUtils.round(" + significants  + ", '"
						+ StringUtils.PERIOD + "', " + element + ") ==&gt; "
						+ strValue + " = " + strValues.get(i));
				assertEquals("Testing roundToString", strValue, strValues.get(i++));
			} catch (final Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}

}	// class MathsUtilsTest
&lt;/syntaxhighlight&gt;}}

The output of the JUnit test follows:

{{XCode|1='''Output for code listing 3.22'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
 MathsUtils.round(5, '.', 0.0) ==&gt; 0.00000 = 0.00000
 MathsUtils.round(5, '.', -1.4012984643248202E-45) ==&gt; -1.4012E-45 = -1.4012E-45
 MathsUtils.round(5, '.', 1.4012984643248202E-45) ==&gt; 1.4013E-45 = 1.4013E-45
 MathsUtils.round(5, '.', -1.999999757E-5) ==&gt; -1.9999E-5 = -1.9999E-5
 MathsUtils.round(5, '.', 1.999999757E-5) ==&gt; 2.0000E-5 = 2.0000E-5
 MathsUtils.round(5, '.', -1.999999757E-4) ==&gt; -1.9999E-4 = -1.9999E-4
 MathsUtils.round(5, '.', 1.999999757E-4) ==&gt; 2.0000E-4 = 2.0000E-4
 MathsUtils.round(5, '.', -0.001999999757) ==&gt; -0.0019999 = -0.0019999
 MathsUtils.round(5, '.', 0.001999999757) ==&gt; 0.0020000 = 0.0020000
 MathsUtils.round(5, '.', -6.40589E-4) ==&gt; -6.4058E-4 = -6.4058E-4
 MathsUtils.round(5, '.', 6.40589E-4) ==&gt; 6.4059E-4 = 6.4059E-4
 MathsUtils.round(5, '.', -0.3396899998188019) ==&gt; -0.33968 = -0.33968
 MathsUtils.round(5, '.', 0.3396899998188019) ==&gt; 0.33969 = 0.33969
 MathsUtils.round(5, '.', -0.34) ==&gt; -0.33999 = -0.33999
 MathsUtils.round(5, '.', 0.34) ==&gt; 0.34000 = 0.34000
 MathsUtils.round(5, '.', -7.07) ==&gt; -7.0699 = -7.0699
 MathsUtils.round(5, '.', 7.07) ==&gt; 7.0700 = 7.0700
 MathsUtils.round(5, '.', -118.188) ==&gt; -118.18 = -118.18
 MathsUtils.round(5, '.', 118.188) ==&gt; 118.19 = 118.19
 MathsUtils.round(5, '.', -118.2) ==&gt; -118.19 = -118.19
 MathsUtils.round(5, '.', 118.2) ==&gt; 118.20 = 118.20
 MathsUtils.round(5, '.', -123.405009) ==&gt; -123.40 = -123.40
 MathsUtils.round(5, '.', 123.405009) ==&gt; 123.41 = 123.41
 MathsUtils.round(5, '.', -30.76994323730469) ==&gt; -30.769 = -30.769
 MathsUtils.round(5, '.', 30.76994323730469) ==&gt; 30.770 = 30.770
 MathsUtils.round(5, '.', -130.7699432373047) ==&gt; -130.76 = -130.76
 MathsUtils.round(5, '.', 130.7699432373047) ==&gt; 130.77 = 130.77
 MathsUtils.round(5, '.', -540.0) ==&gt; -539.99 = -539.99
 MathsUtils.round(5, '.', 540.0) ==&gt; 540.00 = 540.00
 MathsUtils.round(5, '.', -12345.0) ==&gt; -12344 = -12344
 MathsUtils.round(5, '.', 12345.0) ==&gt; 12345 = 12345
 MathsUtils.round(5, '.', -123456.0) ==&gt; -123450 = -123450
 MathsUtils.round(5, '.', 123456.0) ==&gt; 123460 = 123460
 MathsUtils.round(5, '.', -540911.0) ==&gt; -540900 = -540900
 MathsUtils.round(5, '.', 540911.0) ==&gt; 540910 = 540910
 MathsUtils.round(5, '.', -9.223372036854776E56) ==&gt; -9.2233E56 = -9.2233E56
 MathsUtils.round(5, '.', 9.223372036854776E56) ==&gt; 9.2234E56 = 9.2234E56
&lt;/pre&gt;}}

If you are interested in a comparison with [[w:C Sharp (programming language)|C#]], take a look at the [[C Sharp Programming/The .NET Framework/Console Programming#Rounding number example|rounding number example]] there. If you are interested in a comparison with [[w:C++|C++]], you can compare this code here with the same [[C%2B%2B_Programming/Code/IO#.E2.80.8ERounding_number_example|example]] over there.

Notice that in the expression starting with &lt;code&gt;if ((D == 0)&lt;/code&gt;, I have to use OR instead of the &lt;code&gt;||&lt;/code&gt; because of a bug in the source template.

&lt;noinclude&gt;{{Todo|Add some exercises like the ones in [[Java Programming/Variables#What are variables?|Variables]]}}
{{Programming/Navigation}}
{{Status|75%}}&lt;/noinclude&gt;</text>
      <sha1>28t0cass7eljl1ey116wc9ezs6cppqg</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Large numbers</title>
    <ns>0</ns>
    <id>221308</id>
    <revision>
      <id>3295225</id>
      <parentid>2757037</parentid>
      <timestamp>2017-09-17T14:42:24Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2607">&lt;noinclude&gt;{{displaytitle|title=Large numbers}}
{{Programming/Navigation}}
{{Java Programming/LanguageFundamentalsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

The integer primitive type with the largest range of value is the {{Java:long}}, from -2&lt;sup&gt;63&lt;/sup&gt; to 2&lt;sup&gt;63&lt;/sup&gt;-1. If you need greater or lesser values, you have to use the &lt;code&gt;BigInteger&lt;/code&gt; class in the package &lt;code&gt;java.math&lt;/code&gt;. A &lt;code&gt;BigInteger&lt;/code&gt; object can represent &lt;u&gt;any&lt;/u&gt; integer (as large as the RAM on the computer can hold) as it is not mapped on a primitive type. Respectively, you need to use the &lt;code&gt;BigDecimal&lt;/code&gt; class for great decimal numbers.

However, as these perform much slower than primitive types, it is recommended to use primitive types when it is possible.

== BigInteger ==
The &lt;code&gt;BigInteger&lt;/code&gt; class represents integers of almost any size. As with other objects, they need to be constructed.  Unlike regular numbers, the &lt;code&gt;BigInteger&lt;/code&gt; represents an immutable object - methods in use by the &lt;code&gt;BigInteger&lt;/code&gt; class will return a new copy of a &lt;code&gt;BigInteger&lt;/code&gt;.  

To instantiate a &lt;code&gt;BigInteger&lt;/code&gt;, you can create it from either byte array, or from a string.  For example:

{{XExample|1='''Code section 3.23: 1 quintillion, or 10^18. Too large to fit in a long.'''
&lt;syntaxhighlight lang="Java" line start="1"&gt;
BigInteger i = new BigInteger("1000000000000000000");
&lt;/syntaxhighlight&gt;}}

&lt;code&gt;BigInteger&lt;/code&gt; cannot use the normal [[Java Programming/Mathematical functions|Java operators]]. They use the methods provided by the class.

{{XExample|1='''Code section 3.24: Multiplications and an addition.'''
&lt;syntaxhighlight lang="Java" line start="1"&gt;
BigInteger a = new BigInteger("3");
BigInteger b = new BigInteger("4");

// c = a^2 + b^2
BigInteger c = a.multiply(a).add(b.multiply(b));
&lt;/syntaxhighlight&gt;}}

It is possible to convert to a {{Java:long}}, but the {{Java:long}} may not be large enough.

{{XExample|1='''Code section 3.25: Conversion.'''
&lt;syntaxhighlight lang="Java" line start="1"&gt;
BigInteger aBigInteger = new BigInteger("3");
long aLong = aBigInteger.longValue();
&lt;/syntaxhighlight&gt;}}

== BigDecimal ==

The &lt;code&gt;BigInteger&lt;/code&gt; class cannot handle decimal numbers. The &lt;code&gt;BigDecimal&lt;/code&gt; class represents a floating point value of arbitrary precision.  It is composed of both a &lt;code&gt;BigInteger&lt;/code&gt;, and a scale value (represented by a 32-bit integer).

&lt;noinclude&gt;{{Todo|Add some exercises like the ones in [[Java Programming/Variables#What are variables?|Variables]]}}
{{Programming/Navigation}}
{{Status|75%}}&lt;/noinclude&gt;</text>
      <sha1>0aahw0g5uvdzi95yt3t67po6tm8hmvo</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Random numbers</title>
    <ns>0</ns>
    <id>160063</id>
    <revision>
      <id>3295243</id>
      <parentid>3072977</parentid>
      <timestamp>2017-09-17T14:43:00Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3732">&lt;noinclude&gt;{{Displaytitle|title=Random numbers}}
{{Programming/Navigation}}
{{Java Programming/LanguageFundamentalsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

To generate random numbers the &lt;code&gt;Math.random()&lt;/code&gt; method can be used, which returns a {{java:double}}, greater than or equal to 0.0 and less than 1.0.

The following code returns a random integer between n and m (where ''n &lt;= randomNumber &lt; m''):

{{XExample|1=&lt;span id="code-section-30"&gt;'''Code section 3.30: A random integer.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
  int randomNumber = n + (int)(Math.random() * ( m - n ));
&lt;/syntaxhighlight&gt;}}

Alternatively, the &lt;code&gt;java.util.Random&lt;/code&gt; class provides methods for generating random {{java:boolean}}s, {{java:byte}}s, {{java:float}}s, {{java:int}}s, {{java:long}}s and 'Gaussians' ({{java:double}}s from a normal distribution with mean 0.0 and standard deviation 1.0). For example, the following code is equivalent to that above:

{{XExample|1=&lt;span id="code-section-31"&gt;'''Code section 3.31: A random integer with Gaussian.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
  Random random = new Random();
  int randomNumber = n + random.nextInt(m - n);
&lt;/syntaxhighlight&gt;}}

As an example using random numbers, we can make a program that uses a Random object to simulate flipping a coin 20 times:

{| style="width: 100%;"
|valign="top"|{{XCode|1=&lt;span id="code-listing-25"&gt;'''Code listing 3.25: CoinFlipper.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
import java.util.Random;

public class CoinFlipper {

  public static void main(String[] args) {
    // The number of times to flip the coin
    final int TIMES_TO_FLIP = 20;
    int heads = 0;
    int tails = 0;
    // Create a Random object
    Random random = new Random();
    for (int i = 0; i &lt; TIMES_TO_FLIP; i++) {
      // 0 or 1
      int result = random.nextInt(2);
      if (result == 1) {
        System.out.println("Heads");
        heads++;
      } else {
        System.out.println("Tails");
        tails++;
      }
    }
    System.out.println("There were "
            + heads
            + " heads and "
            + tails
            + " tails");
  }
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XCode|1='''Possible output for code listing 3.25'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
Heads
Tails
Tails
Tails
Heads
Tails
Heads
Heads
Heads
Heads
Heads
Heads
Tails
Tails
Tails
Tails
Heads
Tails
Tails
Tails
There were 9 heads and 11 tails
&lt;/pre&gt;}}
|}

Of course, if you run the program you will probably get different results.

== Truly random numbers ==

Both &lt;code&gt;Math.random()&lt;/code&gt; and the &lt;code&gt;Random&lt;/code&gt; class produce pseudorandom numbers. This is good enough for a lot of applications, but remember that it is not ''truly'' random. If you want a more secure random number generator, Java provides the &lt;code&gt;java.security.SecureRandom&lt;/code&gt; package. What happens with &lt;code&gt;Math.random()&lt;/code&gt; and the &lt;code&gt;Random&lt;/code&gt; class is that a 'seed' is chosen from which the pseudorandom numbers are generated. &lt;code&gt;SecureRandom&lt;/code&gt; increases the security to ensure that the seed which is used by the pseudorandom number generator is non-deterministic &amp;mdash; that is, you cannot simply put the machine in the same state to get the same set of results. Once you have created a &lt;code&gt;SecureRandom&lt;/code&gt; instance, you can use it in the same way as you can the &lt;code&gt;Random&lt;/code&gt; class.

If you want ''truly'' random numbers, you can get a hardware random number generator or use a randomness generation service.

&lt;noinclude&gt;{{Todo|Add some exercises like the ones in [[Java Programming/Variables#What are variables?|Variables]]}}
{{Programming/Navigation}}
{{Status|75%}}&lt;/noinclude&gt;</text>
      <sha1>day4kiirbm0ypur5x63j38id6sl09qw</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Unicode</title>
    <ns>0</ns>
    <id>58646</id>
    <revision>
      <id>3295261</id>
      <parentid>3072979</parentid>
      <timestamp>2017-09-17T14:43:34Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4252">&lt;noinclude&gt;{{Displaytitle|title=Unicode}}
{{Programming/Navigation}}
__NOTOC__{{Java Programming/LanguageFundamentalsTopic/Nav}}
&lt;/noinclude&gt;

Most Java program text consists of [[wikipedia:ASCII|ASCII]] characters, but any Unicode character can be used as part of identifier names, in comments, and in character and string literals. For example, π (which is the Greek Lowercase Letter '''pi''') is a valid Java identifier:

{{XExample|1=&lt;span id="code-section-100"&gt;'''Code section 3.100: Pi.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
double π = Math.PI;
&lt;/syntaxhighlight&gt;}}

and in a string literal:

{{XExample|1=&lt;span id="code-section-101"&gt;'''Code section 3.101: Pi literal.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
String pi = "π";
&lt;/syntaxhighlight&gt;}}

== Unicode escape sequences ==
Unicode characters can also be expressed through Unicode Escape Sequences. Unicode escape sequences may appear anywhere in a Java source file (including inside identifiers, comments, and [[Java Programming/Literals|string literals]]).

Unicode escape sequences consist of
# a backslash '&lt;code&gt;\&lt;/code&gt;' (ASCII character 92, hex 0x5c),
# a '&lt;code&gt;u&lt;/code&gt;' (ASCII 117, hex 0x75)
# optionally one or more additional '&lt;code&gt;u&lt;/code&gt;' characters, and
# four hexadecimal digits (the characters '&lt;code&gt;0&lt;/code&gt;' through '&lt;code&gt;9&lt;/code&gt;' or '&lt;code&gt;a&lt;/code&gt;' through '&lt;code&gt;f&lt;/code&gt;' or '&lt;code&gt;A&lt;/code&gt;' through '&lt;code&gt;F&lt;/code&gt;').

Such sequences represent the UTF-16 encoding of a Unicode character. For example, 'a' is equivalent to '\u0061'. This escape method does not support characters beyond U+FFFF or you have to make use of surrogate pairs.&lt;ref&gt;"3.1 Unicode", The Java™ Language
Specification [http://download.oracle.com/otn-pub/jcp/jls-7-mr3-fullv-oth-JSpec/JLS-JavaSE7-Full.pdf], Java SE 7 Edition, pp. 15-16.&lt;/ref&gt;

Any and all characters in a program may be expressed in Unicode escape characters, but such programs are not very readable, except by the Java compiler - in addition, they are not very compact.

One can find a full list of the characters [[Unicode/Character reference|here]].

π may also be represented in Java as the ''Unicode escape sequence'' &lt;code&gt;\u03C0&lt;/code&gt;. Thus, the following is a valid, but not very readable, declaration and assignment:

{{XExample|1=&lt;span id="code-section-102"&gt;'''Code section 3.102: Unicode escape sequences for Pi.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
double \u03C0 = Math.PI;
&lt;/syntaxhighlight&gt;}}

The following demonstrates the use of Unicode escape sequences in other Java syntax:

{{XExample|1=&lt;span id="code-section-103"&gt;'''Code section 3.103: Unicode escape sequences in a string literal.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
// Declare Strings pi and quote which contain \u03C0 and \u0027 respectively:
String pi = "\u03C0";
String quote = "\u0027";
&lt;/syntaxhighlight&gt;}}

Note that a Unicode escape sequence functions just like any other character in the source code. E.g., &lt;code&gt;\u0022&lt;/code&gt; (double quote, ") needs to be quoted in a string just like ".

{{XExample|1=&lt;span id="code-section-104"&gt;'''Code section 3.104: Double quote.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
// Declare Strings doubleQuote1 and doubleQuote2 which both contain " (double quote):
String doubleQuote1 = "\"";
String doubleQuote2 = "\\u0022"; // "\u0022" doesn't work since """ doesn't work.
&lt;/syntaxhighlight&gt;}}

== International language support ==
The language distinguishes between bytes and characters. Characters are stored internally using UCS-2, although as of J2SE 5.0, the language also supports using UTF-16 and its surrogates. Java program source may therefore contain any Unicode character.

The following is thus perfectly valid Java code; it contains Chinese characters in the class and [[Java Programming/Variables|variable]] names as well as in a string [[Java Programming/Literals|literal]]:
{{XCode|1=&lt;span id="code-listing-50"&gt;'''Code listing 3.50: 哈嘍世界.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public class 哈嘍世界 {
    private String 文本 = "哈嘍世界";
}
&lt;/syntaxhighlight&gt;}}

== References ==
{{Reflist}}

&lt;noinclude&gt;{{Programming/Navigation}}
{{Status|100%}}&lt;/noinclude&gt;</text>
      <sha1>dwtr0bf0zvnqki4v9nd07sde1gfceak</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Comments</title>
    <ns>0</ns>
    <id>44075</id>
    <revision>
      <id>3295189</id>
      <parentid>3073271</parentid>
      <timestamp>2017-09-17T14:41:17Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6216">&lt;noinclude&gt;{{Displaytitle|title=Comments}}
{{Programming/Navigation}}
__NOTOC__{{Java Programming/LanguageFundamentalsTopic/Nav}}
&lt;/noinclude&gt;

A comment allows to insert text that will not be compiled nor interpreted. It can appear anywhere in the source code where whitespaces are allowed.

It is useful for explaining what the source code does by:
* explaining the adopted technical choice: why this given algorithm and not another, why calling this given method...
* explaining what should be done in the next steps (the TODO list): improvement, issue to fix...
* giving the required explanation to understand the code and be able to update it yourself later or by other developers.

It can also be used to make the compiler ignore a portion of code: temporary code for debugging, code under development...

== Syntax ==
The comments in Java use the same syntax as in [[C++ Programming|C++]].

An end-of-line comment starts with two slashes and ends with the end of the line. This syntax can be used on a single line too.

{{XExample|1=&lt;span id="code-section-105"&gt;'''Code section 3.105: Slash-slash comment.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
// A comment to give an example

int n = 10; // 10 articles
&lt;/syntaxhighlight&gt;}}

A comment on several lines is framed with '/' + '*' and '*' + '/'.

{{XExample|1=&lt;span id="code-section-106"&gt;'''Code section 3.106: Slash-star comment in multiple lines.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
/*
 * This is a comment
 * on several lines.
 */

/* This also works; slash-star comments may be on a single line. */

/*
Disable debugging code:

int a = 10;
while (a-- &gt; 0) System.out.println("DEBUG: tab["+a+"]=" + tab[a]);
*/
&lt;/syntaxhighlight&gt;}}

By convention, subsequent lines of slash-star comments begin with a star aligned under the star in the open comment sequence, but this is not required. Never nest a slash-star comment in another slash-star comment. If you accidentally nest such comments, you will probably get a syntax error from the compiler soon after the first star-slash sequence.

{{XWarning|1=&lt;span id="code-section-107" style="color: red;"&gt;'''Code section 3.107: Nested slash-star comment.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
/* This comment appears to contain /* a nested comment. */
 * The comment ends after the first star-slash and
 * everything after the star-slash sequence is parsed
 * as non-comment source.
 */
&lt;/syntaxhighlight&gt;}}

If you need to have the sequence */ inside a comment you can use html numeric entities: &lt;code&gt;&lt;nowiki&gt;*&amp;amp;#47;&lt;/nowiki&gt;&lt;/code&gt;.

Slash-star comments may also be placed between any Java tokens, though not recommended:

{{XExample|1=&lt;span id="code-section-108"&gt;'''Code section 3.108: Inline slash-star comment.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
int i = /* maximum integer */ Integer.MAX_VALUE;
&lt;/syntaxhighlight&gt;}}

However, comments are not parsed as comments when they occur in string literals.

{{XExample|1=&lt;span id="code-section-109"&gt;'''Code section 3.109: String literal.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
String text = "/* This is not a comment. */";
&lt;/syntaxhighlight&gt;}}

It results in a 33 character string.

{{Java/Hidden begin|title=Test your knowledge}}
'''Question 3.26''': Consider the following code:

{{XExample|1=&lt;span id="question-26"&gt;'''Question 3.26: Commented code.'''&lt;/span&gt;
&lt;pre&gt;
int a = 0;
// a = a + 1;
a = a + 1;
/*
a = a + 1;
*/
a = a + 1;
// /*
a = a + 1;
// */
a = a /*+ 1*/;
a = a + 1; // a = a + 1;
System.out.println("a=" + a);
&lt;/pre&gt;}}

What is printed in the standard output?
{{Java/Hidden begin|title=Answer}}

{{XConsole|1='''Output for Answer 3.26'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
a=4
&lt;/pre&gt;}}

{{XExample|1=&lt;span id="answer-26"&gt;'''Answer 3.26: Commented code.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1, 3, 7, 9, 11, 12, 13"&gt;
int a = 0;
// a = a + 1;
a = a + 1;
/*
a = a + 1;
*/
a = a + 1;
// /*
a = a + 1;
// */
a = a /*+ 1*/;
a = a + 1; // a = a + 1;
System.out.println("a=" + a);
&lt;/syntaxhighlight&gt;}}

The highlighted lines are code lines but line 11 does nothing and only the first part of line 12 is code.
{{Hidden end}}
{{Hidden end}}

== Comments and unicode ==
Be aware that Java still interprets Unicode sequences within comments. For example, the Unicode sequence &lt;code&gt;\u002a\u002f&lt;/code&gt; (whose codepoints correspond to */) is processed early in the Java compiler's lexical scanning of the source file, even before comments are processed, so this is a valid star-slash comment in Java:

{{XExample|1=&lt;span id="code-section-110"&gt;'''Code section 3.110: Unicode sequence interruption.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java" line start="1"&gt;
/* This is a comment. \u002a\u002f
String statement = "This is not a comment.";
&lt;/syntaxhighlight&gt;}}

and is lexically equivalent to

{{XExample|1=&lt;span id="code-section-111"&gt;'''Code section 3.111: Unicode sequence interruption effect.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java" line start="1"&gt;
/* This is a comment. */
String statement = "This is not a comment.";
&lt;/syntaxhighlight&gt;}}

(The &lt;code&gt;'*'&lt;/code&gt; character is Unicode &lt;code&gt;002A&lt;/code&gt; and the &lt;code&gt;'/'&lt;/code&gt; character is Unicode &lt;code&gt;002F&lt;/code&gt;.)

Similar caveats apply to newline characters in slash-slash comments.

For example:
{{XWarning|1=&lt;span id="code-section-112" style="color: red;"&gt;'''Code section 3.112: New line.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
// This is a single line comment \u000a This is code
&lt;/syntaxhighlight&gt;}}

That is because &lt;code&gt;\u000a&lt;/code&gt; is Unicode for a new line, making the compiler think that you have added a new line when you haven't.

== Javadoc comments ==

[[Java Programming/Javadoc|Javadoc]] comments are a special case of slash-star comments.

{{XExample|1=&lt;span id="code-section-113"&gt;'''Code section 3.113: Javadoc comment.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
/**
 * Comments which start with slash-star-star are Javadoc comments.
 * These are used to extract documentation from the Java source.
 * More on javadoc will be covered later.
 */
&lt;/syntaxhighlight&gt;}}

&lt;noinclude&gt;{{Status|100%}}
{{Programming/Navigation}}&lt;/noinclude&gt;</text>
      <sha1>dpkkq4jpwkzor62xq5rphdr5gya1y7f</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Keywords</title>
    <ns>0</ns>
    <id>58445</id>
    <revision>
      <id>3295223</id>
      <parentid>3242387</parentid>
      <timestamp>2017-09-17T14:42:20Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4595">&lt;noinclude&gt;{{Displaytitle|title=Keywords}}
{{Programming/Navigation}}
__NOTOC__
{{Java Programming/LanguageFundamentalsTopic/Nav}}&lt;/noinclude&gt;

'''Keywords''' are special tokens in the language which have reserved use in the language. Keywords may not be used as identifiers in Java &amp;mdash; you cannot declare a field whose name is a keyword, for instance.

Examples of keywords are the primitive types, {{Java:int}} and {{Java:boolean}}; the control flow statements {{Java:for}} and {{Java:if}}; access modifiers such as {{Java:public}}, and special words which mark the declaration and definition of Java classes, packages, and interfaces: {{Java:class}}, {{Java:package}}, {{Java:interface}}.

Below are all the Java language keywords:
&lt;div class="references-small" style="column-count:3;-moz-column-count:3;"&gt;
* {{Java:abstract}}
* {{Java:assert}} (since Java 1.4)
* {{Java:boolean}}
* {{Java:break}}
* {{Java:byte}}
* {{Java:case}}
* {{Java:catch}}
* {{Java:char}}
* {{Java:class}}
* {{Java:const}} (not used)
* {{Java:continue}}
* {{Java:default}}
* {{Java:do}}
* {{Java:double}}
* {{Java:else}}
* {{Java:enum}} (since Java 5.0)
* {{Java:extends}}
* {{Java:final}}
* {{Java:finally}}
* {{Java:float}}
* {{Java:for}}
* {{Java:goto}} (not used)
* {{Java:if}}
* {{Java:implements}}
* {{Java:import}}
* {{Java:instanceof}}
* {{Java:int}}
* {{Java:interface}}
* {{Java:long}}
* {{Java:native}}
* {{Java:new}}
* {{Java:package}}
* {{Java:private}}
* {{Java:protected}}
* {{Java:public}}
* {{Java:return}}
* {{Java:short}}
* {{Java:static}}
* {{Java:strictfp}} (since Java 1.2)
* {{Java:super}}
* {{Java:switch}}
* {{Java:synchronized}}
* {{Java:this}}
* {{Java:throw}}
* {{Java:throws}}
* {{Java:transient}}
* {{Java:try}}
* {{Java:void}}
* {{Java:volatile}}
* {{Java:while}}
&lt;/div&gt;

{{TOCright}}

In addition, the identifiers {{Java:null}}, {{Java:true}}, and {{Java:false}} denote literal values and may not be used to create identifiers.

==abstract==
{{:Java Programming/Keywords/abstract}}

==assert==
{{:Java Programming/Keywords/assert}}

==boolean==
{{:Java Programming/Keywords/boolean}}

==break==
{{:Java Programming/Keywords/break}}

==byte==
{{:Java Programming/Keywords/byte}}

==case==
{{:Java Programming/Keywords/case}}

==catch==
{{:Java Programming/Keywords/catch}}

==char==
{{:Java Programming/Keywords/char}}

==class==
{{:Java Programming/Keywords/class}}

==const==
{{:Java Programming/Keywords/const}}

==continue==
{{:Java Programming/Keywords/continue}}

==default==
{{:Java Programming/Keywords/default}}

==do==
{{:Java Programming/Keywords/do}}

==double==
{{:Java Programming/Keywords/double}}

==else==
{{:Java Programming/Keywords/else}}

==enum==
{{:Java Programming/Keywords/enum}}

==extends==
{{:Java Programming/Keywords/extends}}

==final==
{{:Java Programming/Keywords/final}}

==finally==
{{:Java Programming/Keywords/finally}}

==float==
{{:Java Programming/Keywords/float}}

==for==
{{:Java Programming/Keywords/for}}

==goto==
{{:Java Programming/Keywords/goto}}

==if==
{{:Java Programming/Keywords/if}}

==implements==
{{:Java Programming/Keywords/implements}}

==import==
{{:Java Programming/Keywords/import}}

==instanceof==
{{:Java Programming/Keywords/instanceof}}

==int==
{{:Java Programming/Keywords/int}}

==interface==
{{:Java Programming/Keywords/interface}}

==long==
{{:Java Programming/Keywords/long}}

==native==
{{:Java Programming/Keywords/native}}

==new==
{{:Java Programming/Keywords/new}}

==package==
{{:Java Programming/Keywords/package}}

==private==
{{:Java Programming/Keywords/private}}

==protected==
{{:Java Programming/Keywords/protected}}

==public==
{{:Java Programming/Keywords/public}}

==return==
{{:Java Programming/Keywords/return}}

==short==
{{:Java Programming/Keywords/short}}

==static==
{{:Java Programming/Keywords/static}}

==strictfp==
{{:Java Programming/Keywords/strictfp}}

==super==
{{:Java Programming/Keywords/super}}

==switch==
{{:Java Programming/Keywords/switch}}

==synchronized==
{{:Java Programming/Keywords/synchronized}}

==this==
{{:Java Programming/Keywords/this}}

==throw==
{{:Java Programming/Keywords/throw}}

==throws==
{{:Java Programming/Keywords/throws}}

==transient==
{{:Java Programming/Keywords/transient}}

==try==
{{:Java Programming/Keywords/try}}

==void==
{{:Java Programming/Keywords/void}}

==volatile==
{{:Java Programming/Keywords/volatile}}

==while==
{{:Java Programming/Keywords/while}}

&lt;noinclude&gt;{{Programming/Navigation}}
{{Status|100%}}

[[{{BOOKCATEGORY}}/Keywords]]

[[fr:Programmation Java/Liste des mots réservés]]
[[pt:Java/Palavra-chave]]&lt;/noinclude&gt;</text>
      <sha1>b4e9hirrooccc0k17mjotdw4cw4h8wg</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Coding conventions</title>
    <ns>0</ns>
    <id>292798</id>
    <revision>
      <id>3295187</id>
      <parentid>3101847</parentid>
      <timestamp>2017-09-17T14:41:13Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2774">&lt;noinclude&gt;{{displaytitle|title=Coding conventions}}
{{Programming/Navigation}}
{{Java Programming/LanguageFundamentalsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

The Java code conventions are defined by Oracle in the [http://www.oracle.com/technetwork/java/codeconventions-150003.pdf coding conventions] document. In short, these conventions ask the user to use [[w:en:CamelCase|camel case]] when defining classes, methods, or variables. Classes start with a capital letter and should be nouns, like &lt;code&gt;CalendarDialogView&lt;/code&gt;. For methods, the names should be verbs in imperative form, like &lt;code&gt;getBrakeSystemType&lt;/code&gt;, and should start with a lowercase letter.

It is important to get used to and follow coding conventions, so that code written by multiple programmers will appear the same. Projects may re-define the standard code conventions to better fit their needs. Examples include a list of allowed abbreviations, as these can often make the code difficult to understand for other designers. Documentation should always accompany code.

One example from the coding conventions is how to define a constant. Constants should be written with capital letters in Java, where the words are separated by an underscore ('_') character. In the Java coding conventions, a constant is a &lt;code&gt;static final&lt;/code&gt; field in a class.

The reason for this diversion is that Java is not 100% object-oriented and discerns between "simple" and "complex" types. These will be handled in detail in the following sections. An example for a simple type is the &lt;code&gt;byte&lt;/code&gt; type. An example for a complex type is a class. A subset of the complex types are classes that cannot be modified after creation, like a &lt;code&gt;String&lt;/code&gt;, which is a concatenation of characters.

For instance, consider the following "constants":

&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public class MotorVehicle {
  /** Number of motors */
  private static final int MOTORS = 1;

  /** Name of a motor */
  private static final String MOTOR_NAME = "Mercedes V8";

  /** The motor object */
  private static final Motor THE_MOTOR = new MercedesMotor();

  /**
   * Constructor
   */
  public MotorVehicle() {
    MOTORS = 2;                     // Gives a syntax error as MOTORS has already been assigned a value.
    THE_MOTOR = new ToshibaMotor(); // Gives a syntax error as THE_MOTOR has already been assigned a value.
    MOTOR_NAME.toLowercase();       // Does not give a syntax error, because it returns a new String rather than editing the MOTOR_NAME variable.
    THE_MOTOR.fillFuel(20.5);       // Does not give a syntax error, as it changes a variable in the motor object, not the variable itself.
  }
}
&lt;/syntaxhighlight&gt;

&lt;noinclude&gt;{{Programming/Navigation}}
{{Status|100%}}&lt;/noinclude&gt;</text>
      <sha1>q9l8iun8g7hl9n2p9hl47w46van7shj</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Classes and Objects</title>
    <ns>0</ns>
    <id>58121</id>
    <revision>
      <id>3295184</id>
      <parentid>3242355</parentid>
      <timestamp>2017-09-17T14:41:07Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="1447">&lt;noinclude&gt;{{Displaytitle|title=Classes and Objects}}
{{Programming/Navigation}}
__NOTOC__
{{Java Programming/ClassesAndObjectsTopic/Nav}}
{{Java Programming/BeginnersTopics/Nav}}&lt;/noinclude&gt;

== Classes and Objects ==

An object-oriented program is built from objects. A class is a "template" that is used to create objects. The class defines the values the object can contain and the operations that can be performed on the object.

After compilation, a class is stored on the file system in a '(class-name).class' file.

The class is [[Java Programming/Class Loading|loaded]] into memory when we are about to [[Java Programming/Creating Objects|create]] the first object from that class, or when we call one of its static functions.

During class loading all the class static variables are initialized. Also operations defined in a &lt;code&gt;static { ... } &lt;/code&gt; block are executed. Once a class is loaded it stays in memory, and the class static variables won't be initialized again.

After the class is loaded into memory, objects can be created from that class. When an object is created, its member variables are initialized, but the class static variables are not.

When there are no more references to an object, the garbage collector will [[Java Programming/Destroying Objects|destroy]] the object and free its memory, so that the memory can be reused to hold new objects.

&lt;noinclude&gt;{{Programming/Navigation}}
{{Status|100%}}&lt;/noinclude&gt;</text>
      <sha1>cjyd70y72hu02qp29fu2zclmzbr40cb</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Defining Classes</title>
    <ns>0</ns>
    <id>56398</id>
    <revision>
      <id>3295197</id>
      <parentid>3083961</parentid>
      <timestamp>2017-09-17T14:41:33Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="9615">&lt;noinclude&gt;{{Displaytitle|title=Defining Classes}}
{{Programming/Navigation}}
__NOTOC__
{{Java Programming/ClassesAndObjectsTopic/Nav}}&lt;/noinclude&gt;

==Fundamentals==
Every class in Java can be composed of the following elements:
*'''fields''', '''member variables''' or '''instance variables''' — Fields are variables that hold data specific to each object.  For example, an employee might have an ID number. There is one field for each object of a class.
*'''member methods''' or '''instance methods''' — Member methods perform operations on an object.  For example, an employee might have a method to issue his paycheck or to access his name.
*'''static fields''' or '''class fields''' — Static fields are common to any object of the same class.  For example, a static field within the Employee class could keep track of the last ID number issued. Each static field exists only once in the class, regardless of how many objects are created for that class.
*'''static methods''' or '''class methods''' — Static methods are methods that do not affect a specific object.
*'''inner classes''' — Sometimes it is useful to contain a class within another one if it is useless outside of the class or should not be accessed outside the class.
*'''Constructors''' — A special method that generates a new object.
*'''Parameterized types''' — Since 1.5, ''parameterized types'' can be assigned to a class during definition.  The ''parameterized types'' will be substituted with the types specified at the class's instantiation. It is done by the compiler. It is similar to the C language macro '#define' statement, where a preprocessor evaluates the macros.

{{XCode|1=&lt;span id="code-listing-1"&gt;'''Code listing 4.1: Employee.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public class Employee {              // This defines the Employee class.
                                     // The public modifier indicates that
                                     // it can be accessed by any other class

    private static int nextID;       // Define a static field. Only one copy of this will exist,
                                     // no matter how many Employees are created.

    private int myID;                // Define fields that will be stored  
    private String myName;           // for each Employee. The private modifier indicates that
                                     // only code inside the Employee class can access it.
 
    public Employee(String name) {   // This is a constructor. You can pass a name to the constructor
                                     // and it will give you a newly created Employee object.
        myName = name;
        myID = nextID;               // Automatically assign an ID to the object
        nextID++;                    // Increment the ID counter
    }
 
    public String getName() {        // This is a member method that returns the
                                     // Employee object's name.
        return myName;               // Note how it can access the private field myName.
    }
 
    public int getID() {             // This is another member method.
   
        return myID;  
    }
 
    public static int getNextID() {  // This is a static method that returns the next ID
                                     // that will be assigned if another Employee is created.
        return nextID;
    }
}
&lt;/syntaxhighlight&gt;}}

The following Java code would produce this output:
{| style="width: 100%;"
|valign="top"|{{XCode|1=&lt;span id="code-listing-10"&gt;'''Code listing 4.2: EmployeeList.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public class EmployeeList {
    public static void main(String[] args) {

        System.out.println(Employee.getNextID());
 
        Employee a = new Employee("John Doe");
        Employee b = new Employee("Jane Smith");
        Employee c = new Employee("Sally Brown");
 
        System.out.println(Employee.getNextID());
 
        System.out.println(a.getID() + ": " + a.getName());
        System.out.println(b.getID() + ": " + b.getName());
        System.out.println(c.getID() + ": " + c.getName());
    }
}&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Console for Code listing 4.2'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
0
3
0: John Doe
1: Jane Smith
2: Sally Brown
&lt;/pre&gt;}}
|}

== Constructors ==
A constructor is called to initialize an object immediately after the object has been allocated:
{{XCode|1=&lt;span id="code-listing-3"&gt;'''Code listing 4.3: Cheese.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3-5"&gt;
public class Cheese {
  // This is a constructor
  public Cheese() {
    System.out.println("Construct an instance");
  }
}
&lt;/syntaxhighlight&gt;}}

Typically, a constructor is invoked using the {{java:new}} keyword:
{{XExample|1='''Code section 4.1: A constructor call.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
Cheese cheese = new Cheese();
&lt;/syntaxhighlight&gt;}}

The constructor syntax is close to the method syntax. However, the constructor has the same name as the name of the class (with the same case) and the constructor has no return type. The second point is the most important difference as a method can also have the same name as the class, which is not recommended:
{{XCode|1=&lt;span id="code-listing-4"&gt;'''Code listing 4.4: Cheese.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3"&gt;
public class Cheese {
  // This is a method with the same name as the class
  public void Cheese() {
    System.out.println("A method execution.");
  }
}
&lt;/syntaxhighlight&gt;}}

The returned object is always a valid, meaningful object, as opposed to relying on a separate initialization method. A constructor cannot be {{java:abstract}}, {{java:final}}, {{java:native}}, {{java:static}}, {{java:strictfp}} nor {{java:synchronized}}. However, a constructor, like methods, can be overloaded and take parameters.
{{XCode|1=&lt;span id="code-listing-5"&gt;'''Code listing 4.5: Cheese.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="8, 13"&gt;
public class Cheese {
     // This is a constructor
     public Cheese() {
          doStuff();
     }

     // This is another constructor
     public Cheese(int weight) {
          doStuff();
     }

     // This is yet another constructor
     public Cheese(String type, int weight) {
          doStuff();
     }
}
&lt;/syntaxhighlight&gt;}}

By convention, a constructor that accepts an object of its own type as a parameter and copies the data members is called a ''copy constructor''. One interesting feature of constructors is that if and only if you do not specify a constructor in your class, the compiler will create one for you. This default constructor, if written out would look like:
{{XCode|1=&lt;span id="code-listing-6"&gt;'''Code listing 4.6: Cheese.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2-4"&gt;
public class Cheese {
     public Cheese() {
           super();
     }
}
&lt;/syntaxhighlight&gt;}}

The &lt;code&gt;super()&lt;/code&gt; command calls the constructor of the superclass. If there is no explicit call to &lt;code&gt;super(...)&lt;/code&gt; or &lt;code&gt;this(...)&lt;/code&gt;, then the default superclass constructor &lt;code&gt;super();&lt;/code&gt; is called before the body of the constructor is executed. That said, there are instances where you need to add in the call manually. For example, if you write even one constructor, no matter what parameters it takes, the compiler will not add a default constructor. The [[#code-listing-8|code listing 4.8]] results in a runtime error:
{{XCode|1=&lt;span id="code-listing-7"&gt;'''Code listing 4.7: Cheese.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public class Cheese {
     public Cheese(int weight, String type) {
          doStuff();
     }
}
&lt;/syntaxhighlight&gt;}}

{{XCode|1=&lt;span id="code-listing-8"&gt;'''Code listing 4.8: Mouse.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3"&gt;
public class Mouse {
     public void eatCheese() {
             Cheese c = new Cheese(); // Oops, compile time error!
     }
}
&lt;/syntaxhighlight&gt;}}
This is something to keep in mind when extending existing classes. Either make a default constructor, or make sure every class that inherits your class uses the correct constructor.

== Initializers ==
''Initializers'' are blocks of code that are executed at the same time as initializers for fields.

=== Static initializers ===
''Static initializers'' are blocks of code that are executed at the same time as initializers for static fields.  Static field initializers and static initializers are executed in the order declared.  The static initialization is executed after the class is loaded.
{{XExample|1='''Code section 4.2: Static initializer.'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3-7"&gt;
static int count = 20;
static int[] squares;
static {  // a static initializer
    squares = new int[count];
    for (int i = 0; i &lt; count; i++)
        squares[i] = i * i;
}
static int x = squares[5];  // x is assigned the value 25
&lt;/syntaxhighlight&gt;}}

=== Instance initializers ===
''Instance initializers'' are blocks of code that are executed at the same time as initializers for instance (non-&lt;code&gt;static&lt;/code&gt;) fields.  Instance field initializers and instance initializers are executed in the order declared. Both instance initializers and instance field initializers are executed during the invocation of a constructor.  The initializers are executed immediately after the superclass constructor and before the body of the constructor.

&lt;noinclude&gt;{{Programming/Navigation}}
{{Status|100%}}&lt;/noinclude&gt;</text>
      <sha1>a63lgq3wjy8flkbt30w4stnnuphhhyq</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Inheritance</title>
    <ns>0</ns>
    <id>291433</id>
    <revision>
      <id>3376277</id>
      <parentid>3295212</parentid>
      <timestamp>2018-02-19T20:05:54Z</timestamp>
      <contributor>
        <ip>86.168.64.76</ip>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6188">&lt;noinclude&gt;{{Displaytitle|title=Inheritance}}
{{Programming/Navigation}}
__NOTOC__
{{Java Programming/ClassesAndObjectsTopic/Nav}}&lt;/noinclude&gt;
Inheritance is one of the most powerful mechanisms of the [[Object Oriented Programming]]. It allows the reuse of the members of a class (called the ''superclass'' or the ''mother class'') in another class (called ''subclass'', ''child class'' or the ''derived class'') that inherits from it. This way, classes can be built by successive inheritance.

In Java, this mechanism is enabled by the {{Java:extends}} keyword.
Example:
{{XCode|1=&lt;span id="code-listing-9"&gt;'''Code listing 4.9: Vehicle.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public class Vehicle {
    public int speed;
    public int numberOfSeats;
}
&lt;/syntaxhighlight&gt;}}
{{XCode|1=&lt;span id="code-listing-10"&gt;'''Code listing 4.10: Car.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1"&gt;
public class Car extends Vehicle {
    public Car() {
        this.speed = 90;
        this.numberOfSeats = 5;
    }
}
&lt;/syntaxhighlight&gt;}}
In the [[#code-listing-10|Code listing 4.10]], the class &lt;code&gt;Car&lt;/code&gt; inherits from &lt;code&gt;Vehicle&lt;/code&gt;, which means that the attributes &lt;code&gt;speed&lt;/code&gt; and &lt;code&gt;numberOfSeats&lt;/code&gt; are present in the class &lt;code&gt;Car&lt;/code&gt;, whereas they are defined in the class &lt;code&gt;Vehicle&lt;/code&gt;. Also, the constructor defined in the class &lt;code&gt;Car&lt;/code&gt; allows to initialize those attributes.
In Java, the inheritance mechanism allows to define a class hierarchy with all the classes. Without explicit inheritance, a class implicitly inherits from the &lt;code&gt;Object&lt;/code&gt; class. This &lt;code&gt;Object&lt;/code&gt; class is the root of the class hierarchy.

Some classes can't be inherited. Those classes are defined with the {{Java:final}} keyword. For instance, the &lt;code&gt;Integer&lt;/code&gt; class can't have subclasses. It is called a ''final'' class.
== The &lt;code&gt;Object&lt;/code&gt; class ==
At the instantiating, the child class receives the features inherited from its superclass, which also has received the features inherited from its own superclass and so on to the &lt;code&gt;Object&lt;/code&gt; class.
This mechanism allows to define reusable global classes, whose user details the behavior in the derived more specific classes.

In Java, a class can only inherit from one class. Java does not allow you to create a subclass from two classes, as that would require creating complicated rules to disambiguate fields and methods inherited from multiple superclasses.  If there is a need for Java to inherit from multiple sources, the best option is through interfaces, described in the next chapter.

== The ''super'' keyword ==
The {{Java:super}} keyword allows access to the members of the superclass of a class, as you can use {{Java:this}} to access the members of the current class.
Example:
{{XCode|1=&lt;span id="code-listing-11"&gt;'''Code listing 4.11: Plane.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3"&gt;
public class Plane extends Vehicle {
    public Plane() {
        super();
    }
}
&lt;/syntaxhighlight&gt;}}
In this example, the constructor of the &lt;code&gt;Plane&lt;/code&gt; class calls the constructor of its superclass &lt;code&gt;Vehicle&lt;/code&gt;. You can only use {{Java:super}} to access the members of the superclass inside the child class. If you use it from another class, it accesses the superclass of the other class.
This keyword also allows you to explicitly access the members of the superclass, for instance, in the case where there is a method with the same name in your class (overriding, ...).
Example :
{{XCode|1=&lt;span id="code-listing-12"&gt;'''Code listing 4.12: Vehicle.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3"&gt;
public class Vehicle {
    // ...
    public void run() throws Exception {
        position += speed;
    }
}
&lt;/syntaxhighlight&gt;}}
 
{{XCode|1=&lt;span id="code-listing-13"&gt;'''Code listing 4.13: Plane.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="7"&gt;
public class Plane extends Vehicle {
    // ...
    public void run() throws Exception {
        if (0 &lt; height) {
           throw new Exception("A plane can't run in flight.");
        } else {
           super.run();
        }
    }
}
&lt;/syntaxhighlight&gt;}}
{{Java/Hidden begin|title=Test your knowledge}}
'''Question 4.1''': Consider the following classes.
{{XCode|1=&lt;span id="question-1"&gt;'''Question 4.1: Class1.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public class Class1 {
    public static final int CONSTANT_OF_CLASS_1 = 9;
    public int myAttributeOfClass1 = 40;
    public void myMethodOfClass1(int i) {
    }
}
&lt;/syntaxhighlight&gt;}}
{{XCode|1=&lt;span id="question-1bis"&gt;'''Question 4.1: Class2.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public class Class2 extends Class1 {
    public int myAttributeOfClass2 = 10;
    public void myMethodOfClass2(int i) {
    }
}
&lt;/syntaxhighlight&gt;}}
{{XCode|1=&lt;span id="question-1ter"&gt;'''Question 4.1: Class3.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public class Class3 {
    public static final int CONSTANT_OF_CLASS_3 = 9;
    public void myMethodOfClass3(int i) {
    }
}
&lt;/syntaxhighlight&gt;}}
{{XCode|1=&lt;span id="question-1qua"&gt;'''Question 4.1: Question1.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public class Question1 extends Class2 {
    public static final int CONSTANT = 2;
    public int myAttribute = 20;
    public void myMethod(int i) {
    }
}
&lt;/syntaxhighlight&gt;}}
List all the attributes and methods that can be accessed in the class &lt;code&gt;Question1&lt;/code&gt;.
{{Java/Hidden begin|title=Answer}}
* &lt;code&gt;CONSTANT_OF_CLASS_1&lt;/code&gt;
* &lt;code&gt;myAttributeOfClass1&lt;/code&gt;
* &lt;code&gt;myMethodOfClass1(int)&lt;/code&gt;
* &lt;code&gt;myAttributeOfClass2&lt;/code&gt;
* &lt;code&gt;myMethodOfClass2(int)&lt;/code&gt;
* &lt;code&gt;CONSTANT&lt;/code&gt;
* &lt;code&gt;myAttribute&lt;/code&gt;
* &lt;code&gt;myMethod(int)&lt;/code&gt;
&lt;code&gt;Question1&lt;/code&gt; inherits from &lt;code&gt;Class1&lt;/code&gt; and &lt;code&gt;Class2&lt;/code&gt; but not from &lt;code&gt;Class3&lt;/code&gt;.
{{Hidden end}}
{{Hidden end}}
:''See also the [[Object Oriented Programming]] book about the inheritance concept.''
&lt;noinclude&gt;{{Programming/Navigation}}
{{Status|100%}}&lt;/noinclude&gt;</text>
      <sha1>dpdraomrdqcqrzoojy3v002yr17tmlv</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Interfaces</title>
    <ns>0</ns>
    <id>75783</id>
    <revision>
      <id>3295214</id>
      <parentid>3073299</parentid>
      <timestamp>2017-09-17T14:42:03Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="11927">&lt;noinclude&gt;{{Displaytitle|title=Interfaces}}
{{Programming/Navigation}}
__NOTOC__
{{Java Programming/ClassesAndObjectsTopic/Nav}}&lt;/noinclude&gt;
An interface is an abstraction of class with no implementation details. For example, &lt;code&gt;java.lang.Comparable&lt;/code&gt; is a standard interface in Java. You cannot instantiate an interface. An interface is not a class but it is written the same way. The first difference is that you do not use the {{Java:class}} keyword but the {{Java:interface}} keyword to define it. Then, there are fields and methods you cannot define here:
* A field is always a constant: it is always public, static and final, even if you do not mention it.
* A method must be public and abstract, but it is not required to write the {{Java:public}} and {{Java:abstract}} keywords.
* Constructors are forbidden.
An interface represents a ''contract'':
{{XCode|1=&lt;span id="code-listing-14"&gt;'''Code listing 4.14: SimpleInterface.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public interface SimpleInterface {
    public static final int CONSTANT1 = 1;
    int method1(String parameter);
}
&lt;/syntaxhighlight&gt;}}
You can see that the &lt;code&gt;method1()&lt;/code&gt; method is abstract (unimplemented). To use an interface, you have to define a class that implements it, using the {{Java:implements}} keyword:
{{XCode|1=&lt;span id="code-listing-15"&gt;'''Code listing 4.15: ClassWithInterface.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1"&gt;
public class ClassWithInterface implements SimpleInterface {
    int method1(String parameter) {
        return 0;
    }
}
&lt;/syntaxhighlight&gt;}}
A class can implement several interface, separated by a comma. Java interfaces behave much like the concept of the [[Objective-C Programming|Objective-C]] protocol. It is recommended to name an interface &lt;code&gt;''&lt;verb&gt;''able&lt;/code&gt;, to mean the type of action this interface would enable on a class. However, it is not recommended to start the name of an interface by &lt;code&gt;I&lt;/code&gt; as in [[C++ Programming|C++]]. It is useless. Your IDE will help you instead.
== Interest ==
If you have objects from different classes that do not have a common superclass, you can't call the same method in those classes, even if the two classes implement a method with the same signature.
{{XCode|1=&lt;span id="code-listing-16"&gt;'''Code listing 4.16: OneClass.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2-4"&gt;
public class OneClass {
    public int method1(String parameter) {
        return 1;
    }
}
&lt;/syntaxhighlight&gt;}}
{{XCode|1=&lt;span id="code-listing-17"&gt;'''Code listing 4.17: AnotherClass.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2-4"&gt;
public class AnotherClass {
    public int method1(String parameter) {
        return 2;
    }
}
&lt;/syntaxhighlight&gt;}}
{{XWarning|1=&lt;span id="code-section-16" style="color: red;"&gt;'''Code section 4.16: Impossible call.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="7"&gt;
public static void main(String[] args) {
    doAction(new OneClass());
    doAction(new AnotherClass());
}

public void doAction(Object anObject) {
    anObject.method1("Hello!");
}
&lt;/syntaxhighlight&gt;}}
The solution is to write an interface that defines the method that should be implemented in the two classes as the &lt;code&gt;SimpleInterface&lt;/code&gt; in the [[#code-listing-14|Code listing 4.14]] and then the both classes can implement the interface as in the [[#code-listing-15|Code listing 4.15]].
{{XExample|1='''Code section 4.17: Interface use.'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="7"&gt;
public static void main(String[] args) {
    doAction(new ClassWithInterface());
    doAction(new AnotherClassWithInterface());
}

public void doAction(SimpleInterface anObject) {
    anObject.method1("Hello!");
}
&lt;/syntaxhighlight&gt;}}
You can also implement this using a common super class but a class can only inherit from one super class whereas it can implement several interfaces.

Java does not support full orthogonal multiple inheritance (i.e. Java does not allow you to create a subclass from two classes). Multiple inheritance in [[C++]] has complicated rules to disambiguate fields and methods inherited from multiple superclasses and types that are inherited multiple times.  By separating interface from implementation, interfaces offer much of the benefit of multiple inheritance with less complexity and ambiguity.  The price of no multiple inheritance is some code redundancy; since interfaces only define the signature of a class but cannot contain any implementation, every class inheriting an interface must provide the implementation of the defined methods, unlike in pure multiple inheritance, where the implementation is also inherited. The major benefit of that is that all Java objects can have a common ancestor (a class called {{java:Object}}).

When overriding methods defined in interfaces there are several rules to be followed:
* Checked exceptions should not be declared on implementation methods other than the ones declared by the interface method or subclasses of those declared by the interface method.
* The signature of the interface method and the same return type or subtype should be maintained when implementing the methods.
* All the methods of the interface need to be defined in the class, unless the class that implements the interface is abstract.

== Extending interfaces ==
[[Image:BlueJ Java Wikibooks example.png|400 px|thumb|Execution of this example on BlueJ.]]
An interface can extend several interfaces, similar to the way that a class can extend another class, using the {{Java:extends}} keyword:
{{XCode|1=&lt;span id="code-listing-18"&gt;'''Code listing 4.18: InterfaceA.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public interface InterfaceA {
  public void methodA();
}
&lt;/syntaxhighlight&gt;}}
{{XCode|1=&lt;span id="code-listing-19"&gt;'''Code listing 4.19: InterfaceB.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public interface InterfaceB {
  public void methodB();
}
&lt;/syntaxhighlight&gt;}}
{{XCode|1=&lt;span id="code-listing-20"&gt;'''Code listing 4.20: InterfaceAB.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1"&gt;
public interface InterfaceAB extends InterfaceA, InterfaceB {
  public void otherMethod();
}
&lt;/syntaxhighlight&gt;}}
This way, a class implementing the &lt;code&gt;InterfaceAB&lt;/code&gt; interface has to implement the &lt;code&gt;methodA()&lt;/code&gt;, the &lt;code&gt;methodB()&lt;/code&gt; and the &lt;code&gt;otherMethod()&lt;/code&gt; methods:
{{XCode|1=&lt;span id="code-listing-21"&gt;'''Code listing 4.21: ClassAB.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1"&gt;
public class ClassAB implements InterfaceAB {
  public void methodA() {
    System.out.println("A");
  }

  public void methodB() {
    System.out.println("B");
  }

  public void otherMethod() {
    System.out.println("foo");
  }

  public static void main(String[] args) {
    ClassAB classAb = new ClassAB();
    classAb.methodA();
    classAb.methodB();
    classAb.otherMethod();
  }
}
&lt;/syntaxhighlight&gt;}}
Doing so, a &lt;code&gt;ClassAB&lt;/code&gt; object can be casted into &lt;code&gt;InterfaceA&lt;/code&gt;, &lt;code&gt;InterfaceB&lt;/code&gt; and &lt;code&gt;InterfaceAB&lt;/code&gt;.
{{Java/Hidden begin|title=Test your knowledge}}
'''Question 4.2''': Consider the following interfaces.
{{XCode|1=&lt;span id="question-2"&gt;'''Question 4.2: Walkable.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public interface Walkable {
    void walk();
}
&lt;/syntaxhighlight&gt;}}
{{XCode|1=&lt;span id="question-2bis"&gt;'''Question 4.2: Jumpable.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public interface Jumpable {
    void jump();
}
&lt;/syntaxhighlight&gt;}}
{{XCode|1=&lt;span id="question-2ter"&gt;'''Question 4.2: Swimable.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public interface Swimable {
    void swim();
}
&lt;/syntaxhighlight&gt;}}
{{XCode|1=&lt;span id="question-2qua"&gt;'''Question 4.2: Movable.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public interface Movable extends Walkable, Jumpable {
}
&lt;/syntaxhighlight&gt;}}
List all the methods that an implementing class of &lt;code&gt;Movable&lt;/code&gt; should implement.
{{Java/Hidden begin|title=Answer}}
* &lt;code&gt;walk()&lt;/code&gt;
* &lt;code&gt;jump()&lt;/code&gt;
{{XCode|1=&lt;span id="answer-2"&gt;'''Answer 4.2: Person.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2, 6"&gt;
public class Person implements Movable {
    public void walk() {
        System.out.println("Do something.");
    }

    public void jump() {
        System.out.println("Do something.");
    }
}
&lt;/syntaxhighlight&gt;}}
{{Hidden end}}
'''Question 4.3''': Consider the following classes and the following code.
{{XCode|1=&lt;span id="question-3"&gt;'''Question 4.3: ConsoleLogger.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
import java.util.Date;

public class ConsoleLogger {
    public void printLog(String log) {
        System.out.println(new Date() + ": " + log);
    }
}
&lt;/syntaxhighlight&gt;}}
{{XCode|1=&lt;span id="question-3bis"&gt;'''Question 4.3: FileLogger.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
import java.io.File;
import java.io.FileOutputStream;

public class FileLogger {
  public void printLog(String log) {
    try {
      File file = new File("log.txt");
      FileOutputStream stream = new FileOutputStream(file);
      byte[] logInBytes = (new Date() + ": " + log).getBytes();

      stream.write(logInBytes);

      stream.flush();
      stream.close();
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
&lt;/syntaxhighlight&gt;}}
{{XExample|1=&lt;span id="question-3ter"&gt;'''Question 4.3: Common code.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
Object[] loggerArray = new Object[2];
loggerArray[0] = new ConsoleLogger();
loggerArray[1] = new FileLogger();

for (Object logger : loggerArray) {
    // logger.printLog("Check point.");
}
&lt;/syntaxhighlight&gt;}}
Change the implementation of the code in order to be able to uncomment the commented line without compile error.
{{Java/Hidden begin|title=Answer}}
You have to create an interface that defines the method &lt;code&gt;printLog(String)&lt;/code&gt; and makes &lt;code&gt;ConsoleLogger&lt;/code&gt; and &lt;code&gt;FileLogger&lt;/code&gt; implement it:
{{XCode|1=&lt;span id="answer-3"&gt;'''Answer 4.3: Logger.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public interface Logger {
    void printLog(String log);
}
&lt;/syntaxhighlight&gt;}}
{{XCode|1=&lt;span id="answer-3bis"&gt;'''Answer 4.3: ConsoleLogger.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3"&gt;
import java.util.Date;

public class ConsoleLogger implements Logger {
    public void printLog(String log) {
        System.out.println(new Date() + ": " + log);
    }
}
&lt;/syntaxhighlight&gt;}}
{{XCode|1=&lt;span id="answer-3ter"&gt;'''Answer 4.3: FileLogger.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="4"&gt;
import java.io.File;
import java.io.FileOutputStream;

public class FileLogger implements Logger {
  public void printLog(String log) {
    try {
      File file = new File("log.txt");
      FileOutputStream stream = new FileOutputStream(file);
      byte[] logInBytes = (new Date() + ": " + log).getBytes();

      stream.write(logInBytes);

      stream.flush();
      stream.close();
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
&lt;/syntaxhighlight&gt;}}
Now your code has to cast the objects to the &lt;code&gt;Logger&lt;/code&gt; type and then you can uncomment the code.
{{XExample|1=&lt;span id="answer-3qua"&gt;'''Answer 4.3: Common code.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1, 5, 6"&gt;
Logger[] loggerArray = new Logger[2];
loggerArray[0] = new ConsoleLogger();
loggerArray[1] = new FileLogger();

for (Logger logger : loggerArray) {
    logger.printLog("Check point.");
}
&lt;/syntaxhighlight&gt;}}
{{Hidden end}}
{{Hidden end}}
&lt;noinclude&gt;{{Status|100%}}
{{Programming/Navigation}}
[[fr:Programmation Java/Interfaces]]&lt;/noinclude&gt;</text>
      <sha1>e9ov0kykhe6lv2j1wlbfe6quz29hjen</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Overloading Methods and Constructors</title>
    <ns>0</ns>
    <id>90088</id>
    <revision>
      <id>3360336</id>
      <parentid>3295237</parentid>
      <timestamp>2018-01-10T19:14:02Z</timestamp>
      <contributor>
        <username>Nictrisha</username>
        <id>2031115</id>
      </contributor>
      <comment>Edit to 2nd to last paragraph - private variables in super classes can not be redefined as they are not visible to other classes.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="14301">&lt;noinclude&gt;{{Displaytitle|title=Overloading and Overriding}}
{{Programming/Navigation}}
__NOTOC__
{{Java Programming/ClassesAndObjectsTopic/Nav}}&lt;/noinclude&gt;

== Method overloading ==

In a class, there can be several methods with the same name. However they must have a different ''signature''. The signature of a method is comprised of its name, its parameter types and the order of its parameters. The signature of a method is '''not''' comprised of its return type nor its visibility nor the exceptions it may throw.
The practice of defining two or more methods within the same class that share the same name but have different parameters is called ''overloading methods''.  

Methods with the same name in a class are called ''overloaded methods''. Overloading methods offers no specific benefit to the JVM but it is useful to the programmer to have several methods do the same things but with different parameters. For example, we may have the operation &lt;code&gt;runAroundThe&lt;/code&gt; represented as two methods with the same name, but different input parameter types:

{{XExample|1=&lt;span id="code-section-22"&gt;'''Code section 4.22: Method overloading.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public void runAroundThe(Building block) {
  ...
}

public void runAroundThe(Park park) {
  ...
}
&lt;/syntaxhighlight&gt;}}

One type can be the subclass of the other:

{| style="width: 100%;"
|valign="top"|{{XCode|1=&lt;span id="code-listing-10"&gt;'''Code listing 4.11: ClassName.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="12-13, 15-16"&gt;
public class ClassName {

  public static void sayClassName(Object aObject) {
    System.out.println("Object");
  }

  public static void sayClassName(String aString) {
    System.out.println("String");
  }

  public static void main(String[] args) {
    String aString = new String();
    sayClassName(aString);

    Object aObject = new String();
    sayClassName(aObject);
  }
}&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XCode|1='''Console for Code listing 4.11'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
String
Object
&lt;/pre&gt;}}
|}

Although both methods would be fit to call the method with the &lt;code&gt;String&lt;/code&gt; parameter, it is the method with the nearest type that will be called instead. To be more accurate, it will call the method whose parameter type is a subclass of the parameter type of the other method. So, &lt;code&gt;aObject&lt;/code&gt; will output &lt;code&gt;Object&lt;/code&gt;. Beware! The parameter type is defined by the ''declared'' type of an object, '''not''' its ''instantiated'' type!

The following two method definitions are valid

{{XExample|1=&lt;span id="code-section-23"&gt;'''Code section 4.23: Method overloading with the type order.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public void logIt(String param, Error err) {
  ...
}

public void logIt(Error err, String param) {
  ...
}
&lt;/syntaxhighlight&gt;}}

because the type order is different. If both input parameters were type String, that would be a problem since the compiler would not be able to distinguish between the two:
{{XWarning|1=&lt;span id="code-section-24" style="color: red;"&gt;'''Code section 4.24: Bad method overloading.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public void logIt(String param, String err) {
  ...
}

public void logIt(String err, String param) {
  ...
}
&lt;/syntaxhighlight&gt;}}

The compiler would give an error for the following method definitions as well:

{{XWarning|1=&lt;span id="code-section-25" style="color: red;"&gt;'''Code section 4.25: Another bad method overloading.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public void logIt(String param) {
  ...
}

public String logIt(String param) {
  String retValue;
  ...
  return retValue;
}
&lt;/syntaxhighlight&gt;}}

Note, the return type is not part of the unique signature.  Why not?  The reason is that a method can be called without assigning its return value to a variable.  This feature came from C and C++. So for the call:
{{XWarning|1=&lt;span id="code-section-26" style="color: red;"&gt;'''Code section 4.26: Ambiguous method call.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="5"&gt;
logIt(msg);
&lt;/syntaxhighlight&gt;}}

the compiler would not know which method to call. It is also the case for the thrown exceptions.

{{Java/Hidden begin|title=Test your knowledge}}
'''Question 4.6''': Which methods of the &lt;code&gt;Question6&lt;/code&gt; class will cause compile errors?
{{XCode|1='''Question6.java'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public class Question6 {
 
  public void example1() {
  }

  public int example1() {
  }

  public void example2(int x) {
  }

  public void example2(int y) {
  }

  private void example3() {
  }

  public void example3() {
  }

  public String example4(int x) {
    return null;
  }

  public String example4() {
    return null;
  }
}
&lt;/syntaxhighlight&gt;}}

{{Java/Hidden begin|title=Answer}}
{{XCode|1='''Question6.java'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3, 6, 9, 12, 15, 18"&gt;
public class Question6 {
 
  public void example1() {
  }

  public int example1() {
  }

  public void example2(int x) {
  }

  public void example2(int y) {
  }

  private void example3() {
  }

  public void example3() {
  }

  public String example4(int x) {
    return null;
  }

  public String example4() {
    return null;
  }
}
&lt;/syntaxhighlight&gt;}}
The &lt;code&gt;example1&lt;/code&gt;, &lt;code&gt;example2&lt;/code&gt; and &lt;code&gt;example3&lt;/code&gt; methods will cause compile errors. The &lt;code&gt;example1&lt;/code&gt; methods cannot co-exist because they have the same signature (remember, return type is '''not''' part of the signature). The &lt;code&gt;example2&lt;/code&gt; methods cannot co-exist because the names of the parameters are not part of the signature. The &lt;code&gt;example3&lt;/code&gt; methods cannot co-exist because the visibility of the methods are not part of the signature. The &lt;code&gt;example4&lt;/code&gt; methods can co-exist, because they have different method signatures.

{{Hidden end}}
{{Hidden end}}

== Variable Argument ==
Instead of overloading, you can use a dynamic number of arguments. After the last parameter, you can pass optional unlimited parameters of the same type. These parameters are defined by adding a last parameter and adding &lt;code&gt;...&lt;/code&gt; after its type. The dynamic arguments will be received as an array:

{{XExample|1=&lt;span id="code-section-27"&gt;'''Code section 4.27: Variable argument.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1, 6-15"&gt;
  public void registerPersonInAgenda(String firstName, String lastName, Date... meeting) {
    String[] person = {firstName, lastName};
    lastPosition = lastPosition + 1;
    contactArray[lastPosition] = person;

    if (meeting.length &gt; 0) {
      Date[] temporaryMeetings = registeredMeetings.length + meeting.length;
      for (i = 0; i &lt; registeredMeetings.length; i++) {
        temporaryMeetings[i] = registeredMeetings[i];
      }
      for (i = 0; i &lt; meeting.length; i++) {
        temporaryMeetings[registeredMeetings.length + i] = meeting[i];
      }
      registeredMeetings = temporaryMeetings;
    }
  }
&lt;/syntaxhighlight&gt;}}

The above method can be called with a dynamic number of arguments, for example:
{{XExample|1=&lt;span id="code-section-27"&gt;'''Code section 4.27: Constructor calls.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
registerPersonInAgenda("John", "Doe");
registerPersonInAgenda("Mark", "Lee", new Date(), new Date());
&lt;/syntaxhighlight&gt;}}

This feature was not available before Java 1.5 .

== Constructor overloading ==

The constructor can be overloaded. You can define more than one constructor with different parameters. For example:

{{XCode|1=&lt;span id="code-listing-12"&gt;'''Code listing 4.12: Constructors.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="8-10, 15-18"&gt;
public class MyClass {

  private String memberField;
 
  /**
   * MyClass Constructor, there is no input parameter
   */
  public MyClass() {
     ...
  }
 
  /**
   * MyClass Constructor, there is one input parameter
   */
   public MyClass(String param1) {
     memberField = param1;
     ...
  }
}
&lt;/syntaxhighlight&gt;}}

In the [[#code-listing-12|code listing 4.12]], we defined two constructors, one with no input parameter, and one with one input parameter. You may ask which constructor will be called.  Its depends how the object is created with the {{java:new}} keyword. See below:

{{XExample|1=&lt;span id="code-section-29"&gt;'''Code section 4.29: Constructor calls.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
// The constructor with no input parameter will be called
MyClass obj1 = new MyClass();

// The constructor with one input param. will be called
MyClass obj2 = new MyClass("Init Value");
&lt;/syntaxhighlight&gt;}}

In the [[#code-section-29|code section 4.29]], we created two objects from the same class, or we can also say that &lt;code&gt;obj1&lt;/code&gt; and &lt;code&gt;obj2&lt;/code&gt; both have the same type. The difference between the two is that in the first one the &lt;code&gt;memberField&lt;/code&gt; field is not initialized, in the second one that is initialized to &lt;code&gt;"Init Value"&lt;/code&gt;. A constructor may also be called from another constructor, see below:

{{XCode|1=&lt;span id="code-listing-13"&gt;'''Code listing 4.13: Constructor pooling.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="9"&gt;
public class MyClass {

  private String memberField;
 
  /**
   * MyClass Constructor, there is no input parameter
   */
  public MyClass() {
    MyClass("Default Value");
  }
 
  /**
   * MyClass Constructor, there is one input parameter
   */
  public MyClass(String param1) {
    memberField = param1;
    ...
  }
}
&lt;/syntaxhighlight&gt;}}

In the [[#code-listing-13|code listing 4.13]], the constructor with no input parameter calls the other constructor with the default initial value. This call must be the first instruction of a constructor or else a compiler error will occur. The code gives an option to the user, to create the object with the default value or create the object with a specified value. The first constructor could have been written using the {{java:this}} keyword as well:

{{XExample|1=&lt;span id="code-section-30"&gt;'''Code section 4.30: Another constructor pooling.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2"&gt;
  public MyClass() {
    this("Default Value");
  }
&lt;/syntaxhighlight&gt;}}

Such a call reduces the code repetition.

== Method overriding ==

To easily remember what can be done in method overriding, keep in mind that all you can do in an object of a class, you can also do in an object of a subclass, only the behavior can change. A subclass should be ''covariant''.

Although a method signature has to be unique inside a class, the same method signature can be defined in different classes.  If we define a method that exists in the super class then we override the super class method.  It is called ''method overriding''.  This is different from method overloading. Method overloading happens with methods with the same name but different signature.  Method overriding happens with methods with the same name and same signature between inherited classes.

The return type can cause the same problem we saw above.  When we override a super class method the return type also must be the same.  If that is not the same, the compiler will give you an error.

Beware! If a class declares two public methods with the same name, and a subclass overrides one of them, the subclass still inherits the other method. In this respect, the Java programming language differs from C++.

Method overriding is related to ''dynamic linking'', or ''runtime binding''. In order for the Method Overriding to work, the method call that is going to be called can not be determined at compilation time. It will be decided at runtime, and will be looked up in a table.

{{XExample|1=&lt;span id="code-section-31"&gt;'''Code section 4.31: Runtime binding.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="11"&gt;
MyClass obj;

if (new java.util.Calendar().get(java.util.Calendar.AM_PM) == java.util.Calendar.AM) {
  // Executed during a morning
  obj = new SubOfMyClass();
} else {
  // Executed during an afternoon
  obj = new MyClass();
}
 
obj.myMethod();
&lt;/syntaxhighlight&gt;}}

In the [[#code-section-31|code section 4.31]], the expression at line 3 is true if it is executed during a morning and false if it is executed during an afternoon. Thus, the instance of &lt;code&gt;obj&lt;/code&gt; will be a &lt;code&gt;MyClass&lt;/code&gt; or a &lt;code&gt;SubOfMyClass&lt;/code&gt; depending on the execution time. So it is impossible to determine the method address at compile time. Because the &lt;code&gt;obj&lt;/code&gt; reference can point to an object and all its sub objects, and that will be known only at runtime, a table is kept with all the possible method addresses to be called. Do not confuse:

{{XExample|1=&lt;span id="code-section-32"&gt;'''Code section 4.32: Declared type and instantiated type.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
obj.myMethod(myParameter);
&lt;/syntaxhighlight&gt;}}

The implementation of this method is searched using the &lt;u&gt;instantiated&lt;/u&gt; type of the called object (&lt;code&gt;obj&lt;/code&gt;) and the &lt;u&gt;declared&lt;/u&gt; type of the parameter object (&lt;code&gt;myParameter&lt;/code&gt;).

Also another rule is that when you do an override, the visibility of the new method that overrides the super class method can not be reduced.  The visibility can be increased, however.  So if the super class method visibility is {{java:public}}, the override method can not be {{java:package}}, or {{java:private}}. An override method must throw the same exceptions as the super class, or their subexceptions.

&lt;code&gt;super&lt;/code&gt; references to the parent class (i.e. &lt;code&gt;super.someMethod()&lt;/code&gt;). It can be used in a subclass to access inherited methods that the subclass has overridden or inherited fields that the subclass has hidden.

{{XNote|A common mistake is to think that if we can override methods, we could also override member variables. This is not the case, as it is useless. You can not redefine a variable that is private in the super class as such a variable is not visible.}}

&lt;noinclude&gt;{{Status|75%}}
{{Todo|Add some exercises like the ones in [[Java Programming/Variables#Kinds of variables|Variables]]}}
{{Programming/Navigation}}&lt;/noinclude&gt;</text>
      <sha1>em60fbjlnfvry6sk35034wretc061bv</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Object Lifecycle</title>
    <ns>0</ns>
    <id>70961</id>
    <revision>
      <id>3439008</id>
      <parentid>3439007</parentid>
      <timestamp>2018-06-27T17:13:49Z</timestamp>
      <contributor>
        <ip>2405:204:7146:2D0D:6CF0:F103:39B4:6AA8</ip>
      </contributor>
      <comment>/* Re-creating an object received from a remote source */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="13275">&lt;noinclude&gt;{{Displaytitle|title=Object Lifecycle}}
{{Programming/Navigation}}
__NOTOC__
{{Java Programming/ClassesAndObjectsTopic/Nav}}&lt;/noinclude&gt;

Before a Java object can be created the class byte code must be loaded from the file system (with &lt;code&gt;.class&lt;/code&gt; extension) to memory. This process of locating the byte code for a given class name and converting that code into a Java [[Java Programming/API/java.lang.Class|class]] instance is known as ''class loading''. There is one class created for each type of Java class.

All objects in Java programs are created on heap memory.  An object is created based on its class.  You can consider a class as a blueprint, template, or a description how to create an object.  When an object is created, memory is allocated to hold the object properties. An object reference pointing to that memory location is also created. To use the object in the future, that object reference has to be stored as a local variable or as an object member variable.

The Java Virtual Machine (JVM) keeps track of the usage of object references.  If there are no more reference to the object, the object can not be used any more and becomes garbage.  After a while the heap memory  will be full of  unused objects.  The JVM collects those garbage objects and frees the memory they allocated, so the memory can be reused again when a new object is created.  See below a simple example:
{{XExample|1='''Code section 4.30: Object creation.'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3"&gt;
{
  // Create an object
  MyObject obj = new MyObject();

  // Use the object
  obj.printMyValues();
}
&lt;/syntaxhighlight&gt;}}

The &lt;code&gt;obj&lt;/code&gt; variable contains the object reference pointing to an object created from the &lt;code&gt;MyObject&lt;/code&gt; class. The &lt;code&gt;obj&lt;/code&gt; object reference is in [[Java Programming/Scope|scope]] inside the &lt;code&gt;{&lt;/code&gt; &lt;code&gt;}&lt;/code&gt;.  After the &lt;code&gt;}&lt;/code&gt; the object becomes garbage.  Object references can be passed in to methods and can be returned from methods.

== Creating object with the {{java:new}} keyword ==
99% of new objects are created using the {{java:new}} keyword.
{{XCode|1=&lt;span id="code-listing-13"&gt;'''Code listing 4.13: MyProgram.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="5"&gt;
public class MyProgram {

  public static void main(String[] args) {
    // Create an 'MyObject' for the first time the application started
    MyObject obj = new MyObject();
  }
}
&lt;/syntaxhighlight&gt;}}

When an object from the &lt;code&gt;MyObject&lt;/code&gt; class is created for the first time, the JVM searches the file system for the definition of the class, that is the Java byte code. The file has the extension of &lt;code&gt;*.class&lt;/code&gt;.  The '''CLASSPATH''' environment variable contains locations where Java classes are stored.  The JVM is looking for the &lt;code&gt;MyObject.class&lt;/code&gt; file. Depending on which package the class belongs to, the package name will be translated to a directory path.

When the &lt;code&gt;MyObject.class&lt;/code&gt; file is found, the JVM's class loader loads the class in memory, and creates a [[Java Programming/API/java.lang.Class|java.lang.Class]] object. The JVM stores the code in memory, allocates memory for the {{java:static}} variables, and executes any static initialize block.  Memory is not allocated for the object member variables at this point, memory will be allocated for them when an instance of the class, an object, is created.

There is no limit on how many objects from the same class can be created.  Code and {{java:static}} variables are stored only once, no matter how many objects are created. Memory is allocated for the object member variables when the object is created.  Thus, the size of an object is determined not by its code's size but by the memory it needs for its member variables to be stored.

== Creating object by cloning an object ==

Cloning is not automatically available to classes. There is some help though, as all Java objects inherit the &lt;code&gt;protected Object clone()&lt;/code&gt; method. This base method would allocate the memory and do the bit by bit copying of the object's states.  

You may ask why we need this clone method. Can't we create a constructor, pass in the same object and do the copying variable by variable? An example would be (note that accessing the private &lt;code&gt;memberVar&lt;/code&gt; variable of &lt;code&gt;obj&lt;/code&gt; is legal as this is in the same class):
{{XCode|1=&lt;span id="code-listing-14"&gt;'''Code listing 4.14: MyObject.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="5"&gt;
public class MyObject {
   private int memberVar;
...
   MyObject(MyObject obj) {
      this.memberVar = obj.memberVar;
    ...
   }
...
}
&lt;/syntaxhighlight&gt;}}

This method works but object creation with the {{java:new}} keyword is time-consuming. The &lt;code&gt;clone()&lt;/code&gt; method copies the whole object's memory in one operation and this is much faster than using the new keyword and copying each variable so if you need to create lots of objects with the same type, performance will be better if you create one object and clone new ones from it. See below a factory method that will return a new object using cloning.

{{XExample|1='''Code section 4.31: Object cloning.'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="12"&gt;
HashTable cacheTemplate = new HashTable();
...
/** Clone Customer object for performance reason */
public Customer createCustomerObject() {
   // See if a template object exists in our cache
   Customer template = cacheTemplate.get("Customer");
   if (template == null) {
      // Create template
      template = new Customer();
      cacheTemplate.put("Customer", template);
   }
   return template.clone();
}
&lt;/syntaxhighlight&gt;}}
Now, let's see how to make the Customer object cloneable.
# First the &lt;code&gt;Customer&lt;/code&gt; class needs to implement the &lt;code&gt;Cloneable&lt;/code&gt; Interface.
# Override and make the &lt;code&gt;clone()&lt;/code&gt; method {{java:public}}, as that is {{java:protected}} in the Object class.
# Call the &lt;code&gt;super.clone()&lt;/code&gt;method at the beginning of your &lt;code&gt;clone&lt;/code&gt; method.
# Override the &lt;code&gt;clone()&lt;/code&gt; method in all the subclasses of &lt;code&gt;Customer&lt;/code&gt;.

{{XCode|1=&lt;span id="code-listing-15"&gt;'''Code listing 4.15: Customer.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public class Customer implements Cloneable {
 ...
    public Object clone() throws CloneNotSupportedException {
       Object obj = super.clone();

       return obj;
    }
}
&lt;/syntaxhighlight&gt;}}
In the [[#code-listing-15|code listing 4.15]] we used cloning for speed up object creation. Another use of cloning could be to take a snapshot of an object that can change in time. Let's say we want to store Customer objects in a collection, but we want to disassociate them from the 'live' objects.  So before adding the object, we clone them, so if the original object changes from that point forward, the added object won't.  Also let's say that the Customer object has a reference to an Activity object that contains the customer activities.  Now we are facing a problem, it is not enough to clone the Customer object, we also need to clone the referenced objects.  The solution:
# Make the Activity class also cloneable
# Make sure that if the Activity class has other 'changeable' object references, those have to be cloned as well, as seen below
# Change the Customer class &lt;code&gt;clone()&lt;/code&gt; method as follows:
{{XCode|1=&lt;span id="code-listing-16"&gt;'''Code listing 4.16: Customer.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="8-10"&gt;
public class Customer implements Cloneable {
  Activity activity;
  ...
    public Customer clone() throws CloneNotSupportedException {
      Customer clonedCustomer = (Customer) super.clone();

      // Clone the object referenced objects
      if (activity != null) {
         clonedCustomer.setActivity((Activity) activity.clone());
      }
      return clonedCustomer;
   }
}
&lt;/syntaxhighlight&gt;}}
Note that only mutable objects need to be cloned. References to unchangeable objects such as a String can be used in the cloned object without worry.

== Re-creating an object received from a remote source ==
When an object is sent through a network, the object needs to be '''re-created''' at the receiving host.

; Object Serialization : The term ''Object Serialization'' refers to the act of converting the object to a byte stream. The byte stream can be stored on the file system or can be sent through a network.  
:At a later time the object can be re-created from that stream of bytes. The only requirement is that the same class has to be available both times, when the object is serialized and also when the object is re-created. If that happens on different servers, then the same class must be available on both servers.  Same class means that exactly the same version of the class must be available, otherwise the object won't be able to be re-created. This is a maintenance problem for those applications where java serialization is used to make objects persistent or to sent the object through the network.
:When a class is modified, there could be a problem re-creating those objects that were serialized using an earlier version of the class.

Java has built-in support for serialization, using the &lt;code&gt;Serializable&lt;/code&gt; interface; however, a class must first implement the &lt;code&gt;Serializable&lt;/code&gt; interface.

By default, a class will have all of its fields serialized when converted into a data stream (with {{Java:transient}} fields being skipped).  If additional handling is required beyond the default of writing all fields, you need to provide an implementation for the following three methods:

:&lt;code&gt;private void writeObject(java.io.ObjectOutputStream out) throws IOException;&lt;/code&gt;

:&lt;code&gt;private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException;&lt;/code&gt;

:&lt;code&gt;private void readObjectNoData() throws ObjectStreamException;&lt;/code&gt;

If the object needs to write or provide a replacement object during serialization, it needs to implement the following two methods, with any access specifier:
:&lt;code&gt;Object writeReplace() throws ObjectStreamException;&lt;/code&gt;

:&lt;code&gt;Object readResolve() throws ObjectStreamException;&lt;/code&gt;

Normally, a minor change to the class can cause the serialization to fail.  You can still allow the class to be loaded by defining the serialization version id:
{{XExample|1='''Code section 4.32: Serialization version id.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
private static final long serialVersionUID = 42L;
&lt;/syntaxhighlight&gt;}}

== Destroying objects ==
Unlike in many other object-oriented programming languages, Java performs automatic garbage collection &amp;mdash; any unreferenced objects are automatically erased from memory &amp;mdash; and prohibits the user from manually destroying objects.

=== finalize() ===
When an object is garbage-collected, the programmer may want to manually perform cleanup, such as closing any open input/output streams.  To accomplish this, the &lt;code&gt;finalize()&lt;/code&gt; method is used.  Note that &lt;code&gt;finalize()&lt;/code&gt; should never be manually called, except to call a super class' finalize method from a derived class' finalize method.  Also, we can not rely on when the &lt;code&gt;finalize()&lt;/code&gt; method will be called.  If the java application exits before the object is garbage-collected, the &lt;code&gt;finalize()&lt;/code&gt; method may never be called.
{{XExample|1='''Code section 4.33: Finalization.'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1"&gt;
protected void finalize() throws Throwable {
  try {
    doCleanup();        // Perform some cleanup.  If it fails for some reason, it is ignored.
  } finally {
    super.finalize(); // Call finalize on the parent object
  }
}
&lt;/syntaxhighlight&gt;}}

The garbage-collector thread runs in a lower priority than the other threads. If the application creates objects faster than the garbage-collector can claim back memory, the program can run out of memory.

The finalize method is required only if there are resources beyond the direct control of the Java Virtual Machine that needs to be cleaned up.  In particular, there is no need to explicitly close an OutputStream, since the OutputStream will close itself when it gets finalized.  Instead, the finalize method is used to release either native or remote resources controlled by the class.

== Class loading ==
One of the main concerns of a developer writing hot re-deployable applications is to understand how class loading works. Within the internals of the class loading mechanism lies the answer to questions like:

* What happens if I pack a newer version of an utility library with my application, while an older version of the same library lingers somewhere in the server's lib directory?
* How can I use two different versions of the same utility library, simultaneously, within the same instance of the application server?
* What version of an utility class I am currently using?
* Why do I need to mess with all this class loading stuff anyway?

&lt;noinclude&gt;{{Status|75%}}
{{Todo|Add some exercises like the ones in [[Java Programming/Variables#Kinds of variables|Variables]]}}
{{Programming/Navigation}}&lt;/noinclude&gt;</text>
      <sha1>fwaw12cnnfw8sdemnzmwxjp3udwoibs</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Scope</title>
    <ns>0</ns>
    <id>72516</id>
    <revision>
      <id>3382212</id>
      <parentid>3295251</parentid>
      <timestamp>2018-03-09T21:43:03Z</timestamp>
      <contributor>
        <ip>73.43.121.76</ip>
      </contributor>
      <comment>/* For a class */Fixed typo</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7619">&lt;noinclude&gt;{{Displaytitle|title=Scope}}
{{Programming/Navigation}}
{{Java Programming/ClassesAndObjectsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

==Scope==
The scope of a class, a variable or a method is its visibility and its accessibility. The visibility or accessibility means that you can use the item from a given place.

=== Scope of method parameters ===
A method parameter is visible inside of the entire method but not visible outside the method.

{{XCode|1=&lt;span id="code-listing-14"&gt;'''Code listing 3.14: Scope.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="4-6"&gt;
public class Scope {

    public void method1(int i) {
        i = i++;
        method2();
        int j = i * 2;
    }

    public void method2() {
        int k = 20;
    }

    public static void main(String[] args) {
        method1(10);
    }
}
&lt;/syntaxhighlight&gt;}}

In [[#code-listing-14|code listing 3.14]], &lt;code&gt;i&lt;/code&gt; is visible within the entire &lt;code&gt;method1&lt;/code&gt; method but not in the &lt;code&gt;method2&lt;/code&gt; and the &lt;code&gt;main&lt;/code&gt; methods.

=== Scope of local variables ===
A local variable is visible after its declaration until the end of the block in which the local variable has been created.

{{XExample|1='''Code section 3.50: Local variables.'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="6-12"&gt;
{
...
     // myNumber is NOT visible
  {
     // myNumber is NOT visible
     int myNumber;
     // myNumber is visible
    {
      ...
       // myNumber is visible
    }
       // myNumber is visible
  }
     // myNumber is NOT visible
...
}
&lt;/syntaxhighlight&gt;}}

== Access modifiers ==
You surely would have noticed by now, the words {{java:public}}, {{java:protected}} and {{java:private}} at the beginning of class's method declarations used in this book. These keywords are called the '''access modifiers''' in the Java language syntax, and they define the scope of a given item.

=== For a class ===
* If a class has '''public''' visibility, the class can be referenced by anywhere in the program.
* If a class has '''protected''' visibility, the class can be referenced only in the package where the class is defined.
* If a class has '''private''' visibility, (it can happen only if the class is defined nested in an other class) the class can be accessed only in the outer class.

=== For a variable ===
* If a variable is defined in a '''public''' class and it has '''public''' visibility, the variable can be referenced anywhere in the application through the class it is defined in.
* If a variable has '''protected''' visibility, the variable can be referenced only in the sub-classes and in the same package through the class it is defined in.
* If a variable has '''package''' visibility, the variable can be referenced only in the same package through the class it is defined in.
* If a variable has '''private''' visibility, the variable can be accessed only in the class it is defined in.

=== For a method ===
* If a method is defined in a '''public''' class and it has '''public''' visibility, the method can be called anywhere in the application through the class it is defined in.
* If a method has '''protected''' visibility, the method can be called only in the sub-classes and in the same package through the class it is defined in.
* If a method has '''package''' visibility, the method can be called only in the same package through the class it is defined in.
* If a method has '''private''' visibility, the method can be called only in the class it is defined in.

=== For an interface ===
The interface methods and interfaces are always {{java:public}}. You do not need to specify the access modifier. It will default to {{java:public}}. For clarity it is considered a good practice to put the {{java:public}} keyword.

The same way all member variables defined in the Interface by default will become {{java:static}} {{java:final}} once inherited in a class.

=== Summary ===
{| class="wikitable" style="width: 100%;"
|-
!
! Class
! Nested class
! Method, or Member variable
! Interface
! Interface method signature
|-
!{{java:public}}
| visible from anywhere
| same as its class
| same as its class
| '''visible from anywhere'''
| '''visible from anywhere'''
|-
!{{java:protected}}
| style="background-color: #eee;" | N/A
| its class and its subclass
| its class and its subclass, and from its package
| style="background-color: #eee;" | N/A
| style="background-color: #eee;" | N/A
|-
! package
| '''only from its package'''
| '''only from its package'''
| '''only from its package'''
| style="background-color: #eee;" | N/A
| style="background-color: #eee;" | N/A
|-
!{{java:private}}
| style="background-color: #eee;" | N/A
| only from its class
| only from its class
| style="background-color: #eee;" | N/A
| style="background-color: #eee;" | N/A
|}

''The cases in bold are the default.''

== Utility ==
A general guideline for visibilities is to only make a member as visible as it needs to be. Don't make a member public if it only needs to be private.

Doing so, you can rewrite a class and change all the private members without making compilation errors, even you don't know all the classes that will use your class as long as you do not change the signature of the public members.

== Field encapsulation ==
Generally, it is best to make data private or protected.  Access to the data is controlled by ''setter'' and ''getter'' methods.  This lets the programmer control access to data, allowing him/her to check for and handle invalid data.

{{XExample|1=&lt;span id="code-section-51"&gt;'''Code section 3.51: Encapsulation.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
private String name;

/**
 * This is a getter method because it accesses data from the object.
 */
public String getName() {
  return name;
}

/**
 * This is a setter method because it changes data in the object.
 */
public boolean setName(String newName) {
  if (newName == null) {
    return false;
  } else {
    name = newName;
    return true;
  }
}
&lt;/syntaxhighlight&gt;}}

In the [[#code-section-51|code section 3.51]], the &lt;code&gt;setName()&lt;/code&gt; method will only change the value of &lt;code&gt;name&lt;/code&gt; if the new name is not null.  Because &lt;code&gt;setName()&lt;/code&gt; is conditionally changing name, it is wise to return a boolean to let the program know if the change was successful.

{{Java/Hidden begin|title=Test your knowledge}}
'''Question 3.15''': Consider the following class.

{{XCode|1=&lt;span id="question-15"&gt;'''Question 3.15: Question15.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public class Question15 {

    public static final int QKQKQKQK_MULTIPLIER = 2;

    public int ijijijijijijijijijAwfulName = 20;

    private int unununununununununCrummyName = 10;

    private void mememememememeUglyName(int i) {
        i = i++;
        tltltltltltltltltlBadName();
        int j = i * QKQKQKQK_MULTIPLIER;
    }

    public void tltltltltltltltltlBadName() {
        int k = ijijijijijijijijijAwfulName;
    }

    public static void main(String[] args) {
        mememememememeUglyName(unununununununununCrummyName);
    }
}
&lt;/syntaxhighlight&gt;}}

List the fields and methods of this class that can be renamed without changing or even knowing the client classes.
{{Java/Hidden begin|title=Answer}}

# &lt;code&gt;unununununununununCrummyName&lt;/code&gt;
# &lt;code&gt;mememememememeUglyName()&lt;/code&gt;

Every field or method that is public can be directly called by a client class so this class would return a compile error if the field or the method has a new name.

{{Hidden end}}
{{Hidden end}}

&lt;noinclude&gt;{{Status|100%}}
{{Programming/Navigation}}&lt;/noinclude&gt;</text>
      <sha1>pecd69hy1gj5k3ina7et9owntrb3w4f</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Nested Classes</title>
    <ns>0</ns>
    <id>69775</id>
    <revision>
      <id>3295233</id>
      <parentid>3094222</parentid>
      <timestamp>2017-09-17T14:42:40Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7002">&lt;noinclude&gt;{{Displaytitle|title=Nested Classes}}
{{Programming/Navigation}}
{{Java Programming/ClassesAndObjectsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

In Java you can define a class inside an other class. A class can be nested inside another class or inside a method. A class that is not nested is called a ''top-level'' class and a class defining a nested class is an ''outer'' class.

== Inner classes ==
=== Nesting a class inside a class ===
When a class is declared inside another class, the nested class' access modifier can be {{java:public}}, {{java:private}}, {{java:protected}} or &lt;code&gt;package(default)&lt;/code&gt;.
{{XCode|1=&lt;span id="code-listing-10"&gt;'''Code listing 4.10: OuterClass.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="4-8"&gt;
public class OuterClass {
   private String outerInstanceVar;

   public class InnerClass {
      public void printVars() {
         System.out.println("Print Outer Class Instance Var.:" + outerInstanceVar);
      }
   }
}
&lt;/syntaxhighlight&gt;}}
The inner class has access to the enclosing class instance's variables and methods, even private ones, as seen above. This makes it very different from the nested class in C++, which are equivalent to the "static" inner classes, see below.

An inner object has a reference to the outer object. In other words, all inner objects are tied to the outer object. The inner object can only be created through a reference to the 'outer' object. See below.
{{XExample|1='''Code section 4.20: Outer class call.'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3-4"&gt;
public void testInner() {
    ...
    OuterClass outer = new OuterClass();
    OuterClass.InnerClass inner = outer.new InnerClass();  
    ...
}
&lt;/syntaxhighlight&gt;}}
Note that inner objects, because they are tied to the outer object, cannot contain static variables or methods.

When in a non-static method of the outer class, you can directly use &lt;code&gt;new InnerClass()&lt;/code&gt;, since the class instance is implied to be &lt;code&gt;this&lt;/code&gt;.

You can directly access the reference to the outer object from within an inner class with the syntax &lt;code&gt;OuterClass.this&lt;/code&gt;; although this is usually unnecessary because you already have access to its fields and methods.

Inner classes compile to separate ".class" bytecode files, with the name of the enclosing class, followed by a "$", followed by the name of the inner class. So for example, the above inner class would be compiled to a file named "OuterClass$InnerClass.class".

=== Static nested classes ===
A nested class can be declared ''static''. These classes are not bound to an instance of the outer defining class. A static nested class has no enclosing instance, and therefore cannot access instance variables and methods of the outer class. You do not specify an instance when creating a static inner class. This is equivalent to the inner classes in C++.

=== Nesting a class inside a method ===  
These inner classes, also called ''local classes'', cannot have access modifiers, like local variables, since the class is 'private' to the method. The inner class can be only {{java:abstract}} or {{java:final}}.
{{XCode|1=&lt;span id="code-listing-11"&gt;'''Code listing 4.11: OuterClass.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3-5"&gt;
public class OuterClass {
   public void method() {
      class InnerClass {
 
      }
   }
}
&lt;/syntaxhighlight&gt;}}
In addition to instance variables of the enclosing class, local classes can also access local variables of the enclosing method, but only ones that are declared &lt;code&gt;final&lt;/code&gt;. This is because the local class instance might outlive the invocation of the method, and so needs its own copy of the variable. To avoid problems with having two different copies of a mutable variable with the same name in the same scope, it is required to be &lt;code&gt;final&lt;/code&gt;, so it cannot be changed.

== Anonymous Classes ==
In Java, a class definition and its instantiation can be combined into a single step. By doing that the class does not require a name. Those classes are called anonymous classes. An anonymous class can be defined and instantiated in contexts where a reference can be used, and it is a nested class to an existing class. Anonymous class is a special case of a class local to a method; hence they also can access final local variables of the enclosing method.

Anonymous classes are most useful to create an instance of an interface or adapter class without needing a brand new class.
{{XCode|1=&lt;span id="code-listing-12"&gt;'''Code listing 4.12: ActionListener.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public interface ActionListener {
    public void actionPerformed();
}
&lt;/syntaxhighlight&gt;}}

{{XExample|1='''Code section 4.21: Anonymous class.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
ActionListener listener = new ActionListener() {
        public void actionPerformed() {
            // Implementation of the action event
            ...
            return;
        }
    };
&lt;/syntaxhighlight&gt;}}
In the above example the class that implements the &lt;code&gt;ActionListener&lt;/code&gt; is '''anonymous'''. The class is defined where it is instantiated.

The above code is harder to read than if the class is explicitly defined, so why use it? If many implementations are needed for an interface, those classes are used only in one particular place, and it would be hard to come up with names for them, using an '''anonymous''' inner class makes sense.

The following example uses an anonymous inner class to implement an action listener.
{{XCode|1=&lt;span id="code-listing-13"&gt;'''Code listing 4.13: MyApp.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
import java.awt.Button;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

class MyApp {
   Button aButton = new Button();

   MyApp() {
       aButton.addActionListener(new ActionListener() {
               public void actionPerformed(ActionEvent e) {
                   System.out.println("Hello There");
               }
           }
       );
   }
}
&lt;/syntaxhighlight&gt;}}
The following example does the same thing, but it names the class that implements the action listener.
{{XCode|1=&lt;span id="code-listing-14"&gt;'''Code listing 4.14: MyApp.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
import java.awt.Button;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

class MyApp {
   Button aButton = new Button();

   // Nested class to implement the action listener
   class MyActionListener implements ActionListener {
       public void actionPerformed(ActionEvent e) {
           System.out.println("Hello There");
       }
   }
   MyApp() {
       aButton.addActionListener(new MyActionListener());
   }
}
&lt;/syntaxhighlight&gt;}}
Using '''anonymous''' classes is especially preferable when you intend to use many different classes that each implement the same interface.

&lt;noinclude&gt;{{Programming/Navigation}}
{{Status|75%}}&lt;/noinclude&gt;</text>
      <sha1>62r84zlirrc9gs492ed9saco684tvma</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Generics</title>
    <ns>0</ns>
    <id>87847</id>
    <revision>
      <id>3295203</id>
      <parentid>2757048</parentid>
      <timestamp>2017-09-17T14:41:42Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="19644">&lt;noinclude&gt;{{Displaytitle|title=Generics}}
{{Programming/Navigation}}
__NOTOC__{{Java Programming/ClassesAndObjectsTopic/Nav}}
&lt;/noinclude&gt;
Java is a strongly typed language, so a field in a class may be typed like this:
{{XCode|1=&lt;span id="code-listing-34"&gt;'''Code listing 4.34: Repository.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3"&gt;
public class Repository {

   public Integer item;

   public Integer getItem() {
      return item;
   }

   public void setItem(Integer newItem) {
      item = newItem;
   }
}
&lt;/syntaxhighlight&gt;}}
This ensures that, only &lt;code&gt;Integer&lt;/code&gt; objects can be put in the field and a &lt;code&gt;ClassCastException&lt;/code&gt; can't occur at runtime, only compile-time error can occur. Unfortunately, it can be used only with &lt;code&gt;Integer&lt;/code&gt; objects. If you want to use the same class in another context with &lt;code&gt;String&lt;/code&gt;s, you have to generalize the type like this:
{{XCode|1=&lt;span id="code-listing-35"&gt;'''Code listing 4.35: Repository.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3, 5, 13-15"&gt;
public class Repository {

   public Object item;

   public Object getItem() {
      return item;
   }

   public void setItem(Integer newItem) {
      item = newItem;
   }

   public void setItem(String newItem) {
      item = newItem;
   }
}
&lt;/syntaxhighlight&gt;}}
But you will have &lt;code&gt;ClassCastException&lt;/code&gt; at runtime again and you can't easily use your field. The solution is to use [[w:Generic programming|Generics]].
== Generic class ==
A generic class does not hard code the type of a field, a return value or a parameter. The class only indicates that a generic type should be the same, for a given object instance. The generic type is not specified in the class definition. It is specified during object instantiation. This allows the generic type to be different from an instance to another. So we should write our class this way:
{{XCode|1=&lt;span id="code-listing-36"&gt;'''Code listing 4.36: Repository.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1, 3, 5, 9"&gt;
public class Repository&lt;T&gt; {

   public T item;

   public T getItem() {
      return item;
   }

   public void setItem(T newItem) {
      item = newItem;
   }
}
&lt;/syntaxhighlight&gt;}}

Here, the generic type is defined after the name of the class. Any new identifier can be chosen. Here, we have chosen ''T'', which is the most common choice. The actual type is defined at the object instantiation:

{{XExample|1=&lt;span id="code-section-35"&gt;'''Code section 4.35: Instantiation.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1, 5"&gt;
Repository&lt;Integer&gt; arithmeticRepository = new Repository&lt;Integer&gt;();
arithmeticRepository.setItem(new Integer(1));
Integer number = arithmeticRepository.getItem();

Repository&lt;String&gt; textualRepository = new Repository&lt;String&gt;();
textualRepository.setItem("Hello!");
String message = textualRepository.getItem();
&lt;/syntaxhighlight&gt;}}

Although each object instance has its own type, each object instance is still strongly typed:

{{XWarning|1=&lt;span id="code-section-36" style="color: red;"&gt;'''Code section 4.36: Compile error.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2"&gt;
Repository&lt;Integer&gt; arithmeticRepository = new Repository&lt;Integer&gt;();
arithmeticRepository.setItem("Hello!");
&lt;/syntaxhighlight&gt;}}

A class can define as many generic types as you like. Choose a different identifier for each generic type and separate them by a comma:

{{XCode|1=&lt;span id="code-listing-37"&gt;'''Code listing 4.37: Repository.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1, 5"&gt;
public class Repository&lt;T, U&gt; {

   public T item;

   public U anotherItem;

   public T getItem() {
      return item;
   }

   public void setItem(T newItem) {
      item = newItem;
   }

   public U getAnotherItem() {
      return anotherItem;
   }

   public void setAnotherItem(U newItem) {
      anotherItem = newItem;
   }
}
&lt;/syntaxhighlight&gt;}}
When a type that is defined with generic (for example, &lt;code&gt;Collection&lt;T&gt;&lt;/code&gt;) is not used with generics (for example, &lt;code&gt;Collection&lt;/code&gt;) is called a ''raw type''.

== Generic method ==
A generic type can be defined for just a method:
{{XExample|1=&lt;span id="code-section-37"&gt;'''Code section 4.37: Generic method.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1"&gt;
public &lt;D&gt; D assign(Collection&lt;D&gt; generic, D obj) {
  generic.add(obj);
  return obj;
}
&lt;/syntaxhighlight&gt;}}
Here a new identifier (''D'') has been chosen at the beginning of the method declaration. The type is ''specific to a method call'' and different types can be used for the same object instance:
{{XExample|1=&lt;span id="code-section-38"&gt;'''Code section 4.38: Generic method call.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
Collection&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;();
Integer number = assign(numbers, new Integer(1));
Collection&lt;String&gt; texts = new ArrayList&lt;String&gt;();
String text = assign(texts, "Store it.");
&lt;/syntaxhighlight&gt;}}
The actual type will be defined by the type of the method parameter. Hence, the generic type can't be defined only for the return value as it wouldn't be resolved. See the [[#Class&lt;T&gt;|Class&lt;T&gt;]] section for a solution.
{{Java/Hidden begin|title=Test your knowledge}}
'''Question 4.8''': Consider the following class.
{{XCode|1=&lt;span id="question-8"&gt;'''Question 4.8: Question8.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public class Question8&lt;T&gt; {
  public T item;
 
  public T getItem() {
    return item;
  }
 
  public void setItem(T newItem) {
    item = newItem;
  }

  public static void main(String[] args) {
    Question8&lt;String&gt; aQuestion = new Question8&lt;String&gt;();
    aQuestion.setItem("Open your mind.");
    aQuestion.display(aQuestion.getItem());
  }

  public void display(String parameter) {
    System.out.println("Here is the text: " + parameter);
  }

  public void display(Integer parameter) {
    System.out.println("Here is the number: " + parameter);
  }

  public void display(Object parameter) {
    System.out.println("Here is the object: " + parameter);
  }
}
&lt;/syntaxhighlight&gt;}}
What will be displayed on the console?
{{Java/Hidden begin|title=Answer}}
{{XConsole|1='''Console for Answer 4.8'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
Here is the text: Open your mind.
&lt;/pre&gt;}}
&lt;code&gt;aQuestion.getItem()&lt;/code&gt; is typed as a string.
{{Hidden end}}
{{Hidden end}}

== Wildcard Types ==
As we have seen above, generics give the impression that a new container type is created with each different type parameter. We have also seen that in addition to the normal type checking, the type parameter has to match as well when we assign generics variables.
In some cases this is too restrictive.  What if we would like to relax this additional checking? What if we would like to define a collection variable that can hold any generic collection, regardless of the parameter type it holds?
The wildcard type is represented by the character '''&lt;?&gt;''', and pronounced '''Unknown''', or '''Any-Type'''. Any-Type can be expressed also by &lt;code&gt;&lt;? extends Object&gt;&lt;/code&gt;. Any-Type includes Interfaces, not only Classes.
So now we can define a collection whose element type matches anything. See below:

{{XExample|1=&lt;span id="code-section-39"&gt;'''Code section 4.39: Wildcard type.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
Collection&lt;?&gt; collUnknown;
&lt;/syntaxhighlight&gt;}}

=== Upper bounded wildcards ===
You can specify a restriction on the types of classes that may be used. For example, &lt;code&gt;&lt;? extends ClassName&gt;&lt;/code&gt; only allows objects of class &lt;code&gt;ClassName&lt;/code&gt; or a subclass.
For example, to create a collection that may only contain "Serializable" objects, specify:

{{XExample|1=&lt;span id="code-section-40"&gt;'''Code section 4.40: Collection of serializable subobjects.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
Collection&lt;String&gt; textColl = new ArrayList&lt;String&gt;();

Collection&lt;? extends Serializable&gt; serColl = textColl;
&lt;/syntaxhighlight&gt;}}

The above code is valid because the {{java:String}} class is serializable. Use of a class that is not serializable would cause a compilation error. The added items can be retrieved as &lt;code&gt;Serializable&lt;/code&gt; object. You can call methods of the &lt;code&gt;Serializable&lt;/code&gt; interface or cast it to &lt;code&gt;String&lt;/code&gt;. The following collection can only contain objects that extend the class &lt;code&gt;Animal&lt;/code&gt;.

{{XCode|1=&lt;span id="code-listing-38"&gt;'''Code listing 4.38: Dog.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
class Dog extends Animal {
}
&lt;/syntaxhighlight&gt;}}

{{XExample|1=&lt;span id="code-section-41"&gt;'''Code section 4.41: Example of subclass.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
// Create "Animal Collection" variable
Collection&lt;? extends Animal&gt; animalColl = new ArrayList&lt;Dog&gt;();
&lt;/syntaxhighlight&gt;}}

=== Lower bounded wildcards ===
&lt;code&gt;&lt;? super ClassName&gt;&lt;/code&gt; specifies a restriction on the types of classes that may be used.
For example, to declare a Comparator that can compare Dogs, you use:

{{XExample|1=&lt;span id="code-section-42"&gt;'''Code section 4.42: Superclass.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
Comparator&lt;? super Dog&gt; myComparator;
&lt;/syntaxhighlight&gt;}}

Now suppose you define a comparator that can compare Animals:

{{XExample|1=&lt;span id="code-section-43"&gt;'''Code section 4.43: Comparator.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
class AnimalComparator implements Comparator&lt;Animal&gt; {
  int compare(Animal a, Animal b) {
   //...
  }
}
&lt;/syntaxhighlight&gt;}}
 
Since &lt;code&gt;Dogs&lt;/code&gt; are &lt;code&gt;Animals&lt;/code&gt;, you can use this comparator to compare Dogs also. Comparators for any superclass of Dog can also compare Dog; but comparators for any strict subclass cannot.
{{XExample|1=&lt;span id="code-section-44"&gt;'''Code section 4.44: Generic comparator.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
Comparator&lt;Animal&gt; myAnimalComparator = new AnimalComparator();

static int compareTwoDogs(Comparator&lt;? super Dog&gt; comp, Dog dog1, Dog dog2) {
  return comp.compare(dog1, dog2);
}
&lt;/syntaxhighlight&gt;}}

The above code is valid because the &lt;code&gt;Animal&lt;/code&gt; class is a supertype of the &lt;code&gt;Dog&lt;/code&gt; class. Use of a class that is not a supertype would cause a compilation error.

=== Unbounded wildcard ===
The advantage of the unbounded wildcard (i.e. &lt;code&gt;&lt;?&gt;&lt;/code&gt;) compared to a raw type (i.e. without generic) is to explicitly say that the parameterized type is unknown, not ''any type''. That way, all the operations that implies to know the type are forbidden to avoid unsafe operation. Consider the following code:

{{XExample|1=&lt;span id="code-section-45"&gt;'''Code section 4.45: Unsafe operation.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public void addAtBottom(Collection anyCollection) {
  anyCollection.add(new Integer(1));
}
&lt;/syntaxhighlight&gt;}}

This code will compile but this code may corrupt the collection if the collection only contains strings:

{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-46"&gt;'''Code section 4.46: Corruption of list.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3"&gt;
List&lt;String&gt; col = new ArrayList&lt;String&gt;();
addAtBottom(col);
col.get(0).endsWith(".");
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Console for Code section 4.46'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
Exception in thread "main" java.lang.ClassCastException: java.lang.Integer incompatible with java.lang.String
at Example.main(Example.java:17)
&lt;/pre&gt;}}
|}

This situation could have been avoided if the &lt;code&gt;addAtBottom(Collection)&lt;/code&gt; method was defined with an unbounded wildcard: &lt;code&gt;addAtBottom(Collection&lt;?&gt;)&lt;/code&gt;. With this signature, it is impossible to compile a code that is dependent of the parameterized type. Only independent methods of a collection (&lt;code&gt;clear()&lt;/code&gt;, &lt;code&gt;isEmpty()&lt;/code&gt;, &lt;code&gt;iterator()&lt;/code&gt;, &lt;code&gt;remove(Object o)&lt;/code&gt;, &lt;code&gt;size()&lt;/code&gt;, ...) can be called. For instance, &lt;code&gt;addAtBottom(Collection&lt;?&gt;)&lt;/code&gt; could contain the following code:

{{XExample|1=&lt;span id="code-section-47"&gt;'''Code section 4.47: Safe operation.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public void addAtBottom(Collection&lt;?&gt; anyCollection) {
   Iterator&lt;?&gt; iterator = anyCollection.iterator();
   while (iterator.hasNext()) {
      System.out.print(iterator.next());
   }
}
&lt;/syntaxhighlight&gt;}}

== Class&lt;T&gt; ==
Since Java 1.5, the class &lt;code&gt;java.lang.Class&lt;/code&gt; is generic. It is an interesting example of using generics for something other than a container class.
For example, the type of String.class is &lt;code&gt;Class&lt;String&gt;&lt;/code&gt;, and the type of Serializable.class is &lt;code&gt;Class&lt;Serializable&gt;&lt;/code&gt;. This can be used to improve the type safety of your reflection code.
In particular, since the &lt;code&gt;newInstance()&lt;/code&gt; method in Class now returns T, you can get more precise types when creating objects reflectively.
Now we can use the &lt;code&gt;newInstance()&lt;/code&gt; method to return a new object with exact type, without casting. An example with generics:

{{XExample|1=&lt;span id="code-section-48"&gt;'''Code section 4.48: Automatic cast.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
Customer cust = Utility.createAnyObject(Customer.class);  // No casting
...
public static &lt;T&gt; T createAnyObject(Class&lt;T&gt; cls) {
    T ret = null;
    try {
        ret = cls.newInstance();
    } catch (Exception e) {
        // Exception Handling
    }
    return ret;
}
&lt;/syntaxhighlight&gt;}}

The same code without generics:

{{XExample|1=&lt;span id="code-section-49"&gt;'''Code section 4.49: Former version.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
Customer cust = (Customer) Utility.createAnyObject(Customer.class);  // Casting is needed
...
public static Object createAnyObject(Class cls) {
    Object ret = null;
    try {
        ret = cls.newInstance();
    } catch (Exception e) {
        // Exception Handling
    }
    return ret;
}
&lt;/syntaxhighlight&gt;}}

== Motivation ==
Java was long criticized for the need to explicitly type-cast an element when it was taken out of a "container/collection" class. There was no way to enforce that a "collection" class contains only one type of object (e.g., to forbid ''at compile time'' that an &lt;code&gt;Integer&lt;/code&gt; object is added to a &lt;code&gt;Collection&lt;/code&gt; that should only contain &lt;code&gt;String&lt;/code&gt;s). This is possible since Java 1.5.
In the first couple of years of Java evolution, Java did not have a real competitor. This has changed by the appearance of Microsoft C#. With Generics Java is better suited to compete against C#.
Similar constructs to Java Generics exist in other languages, see [[w:Generic programming|Generic programming]] for more information.
Generics were added to the Java language syntax in version 1.5. This means that code using Generics will not compile with Java 1.4 and less.
Use of generics is optional. For backwards compatibility with pre-Generics code, it is okay to use generic classes without the generics type specification (&lt;code&gt;&lt;T&gt;&lt;/code&gt;). In such a case, when you retrieve an object reference from a generic object, you will have to manually cast it from type Object to the correct type.

== Note for C++ programmers ==
Java Generics are similar to C++ Templates in that both were added for the same reason. The syntax of Java Generic and C++ Template are also similar. There are some differences however. The C++ template can be seen as a kind of macro, in that a new copy of the code is generated for each generic type referenced. All extra code for templates is generated at compiler time.
In contrast, Java Generics are built into the language.  The same code is used for each generic type. For example:

{{XExample|1=&lt;span id="code-section-50"&gt;'''Code section 4.50: Java generics.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
Collection&lt;String&gt;  collString  = new ArrayList&lt;String&gt;();
Collection&lt;Integer&gt; collInteger = new ArrayList&lt;Integer&gt;();
&lt;/syntaxhighlight&gt;}}

Both these objects appear as the same type at runtime (both &lt;code&gt;ArrayList&lt;/code&gt;'s). The generic type information is erased during compilation (type erasure). For example:

{{XExample|1=&lt;span id="code-section-51"&gt;'''Code section 4.51: Type erasure.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public &lt;T&gt; void method(T argument) {
  T variable;
  …
}
&lt;/syntaxhighlight&gt;}}

is transformed by erasure into:

{{XExample|1=&lt;span id="code-section-52"&gt;'''Code section 4.52: Transformation.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public void method(Object argument) {
  Object variable;
  …
}
&lt;/syntaxhighlight&gt;}}

{{Java/Hidden begin|title=Test your knowledge}}
'''Question 4.9''': Consider the following class.

{{XCode|1=&lt;span id="question-9"&gt;'''Question 4.9: Question9.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
import java.util.ArrayList;
import java.util.Collection;

public class Question9 {
  public static void main(String[] args) {
    Collection&lt;String&gt; collection1 = new ArrayList&lt;String&gt;();
    Collection&lt;? extends Object&gt; collection2 = new ArrayList&lt;String&gt;();
    Collection&lt;? extends String&gt; collection3 = new ArrayList&lt;String&gt;();
    Collection&lt;? extends String&gt; collection4 = new ArrayList&lt;Object&gt;();
    Collection&lt;? super Object&gt; collection5 = new ArrayList&lt;String&gt;();
    Collection&lt;? super Object&gt; collection6 = new ArrayList&lt;Object&gt;();
    Collection&lt;?&gt; collection7 = new ArrayList&lt;String&gt;();
    Collection&lt;? extends Object&gt; collection8 = new ArrayList&lt;?&gt;();
    Collection&lt;? extends Object&gt; collection9 = new ArrayList&lt;Object&gt;();
    Collection&lt;? extends Integer&gt; collection10 = new ArrayList&lt;String&gt;();
    Collection&lt;String&gt; collection11 = new ArrayList&lt;? extends String&gt;();
    Collection collection12 = new ArrayList&lt;String&gt;();
  }
}
&lt;/syntaxhighlight&gt;}}

Which lines will generate a compile error?
{{Java/Hidden begin|title=Answer}}

{{XCode|1=&lt;span id="answer-9"&gt;'''Answer 4.9: Answer9.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="9, 10, 13, 15, 16"&gt;
import java.util.ArrayList;
import java.util.Collection;

public class Answer9 {
  public static void main(String[] args) {
    Collection&lt;String&gt; collection1 = new ArrayList&lt;String&gt;();
    Collection&lt;? extends Object&gt; collection2 = new ArrayList&lt;String&gt;();
    Collection&lt;? extends String&gt; collection3 = new ArrayList&lt;String&gt;();
    Collection&lt;? extends String&gt; collection4 = new ArrayList&lt;Object&gt;();
    Collection&lt;? super Object&gt; collection5 = new ArrayList&lt;String&gt;();
    Collection&lt;? super Object&gt; collection6 = new ArrayList&lt;Object&gt;();
    Collection&lt;?&gt; collection7 = new ArrayList&lt;String&gt;();
    Collection&lt;? extends Object&gt; collection8 = new ArrayList&lt;?&gt;();
    Collection&lt;? extends Object&gt; collection9 = new ArrayList&lt;Object&gt;();
    Collection&lt;? extends Integer&gt; collection10 = new ArrayList&lt;String&gt;();
    Collection&lt;String&gt; collection11 = new ArrayList&lt;? extends String&gt;();
    Collection collection12 = new ArrayList&lt;String&gt;();
  }
}
&lt;/syntaxhighlight&gt;}}

* Line 9: &lt;code&gt;Object&lt;/code&gt; does not extend &lt;code&gt;String&lt;/code&gt;.
* Line 10: &lt;code&gt;String&lt;/code&gt; is not a superclass of &lt;code&gt;Object&lt;/code&gt;.
* Line 13: &lt;code&gt;ArrayList&lt;?&gt;&lt;/code&gt; can't be instantiated.
* Line 15: &lt;code&gt;Integer&lt;/code&gt; does not extend &lt;code&gt;String&lt;/code&gt;.
* Line 16: &lt;code&gt;ArrayList&lt;? extends String&gt;&lt;/code&gt; can't be instantiated.
{{Hidden end}}
{{Hidden end}}
&lt;noinclude&gt;
{{Programming/Navigation}}
{{Status|100%}}

[[fr:Programmation Java/Types génériques]]
&lt;/noinclude&gt;</text>
      <sha1>twhprm5mk1mgf1wmdzcy4m7og9z896l</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Aggregate</title>
    <ns>0</ns>
    <id>58122</id>
    <revision>
      <id>3295163</id>
      <parentid>3263340</parentid>
      <timestamp>2017-09-17T14:39:56Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2500">&lt;noinclude&gt;{{Displaytitle|title=Aggregate}}
{{Programming/Navigation}}
{{Java Programming/CollectionsTopic/Nav}}
{{Java Programming/Topics/Nav}}
__NOTOC__&lt;/noinclude&gt;
In the previous chapters, we have discovered the [[Java Programming/Arrays|array]]. An array stores a group of primitive types. To group objects, or to reference a group of objects, we can use Java aggregate classes. There are two main interfaces, those are &lt;code&gt;java.util.Collection&lt;/code&gt; and &lt;code&gt;java.util.Map&lt;/code&gt; . Implementations for those interfaces are not interchangeable.

== Collection ==
The implementations of &lt;code&gt;java.util.Collection&lt;/code&gt; interface are used for grouping simple java objects.

; Example: We can group together all patients in a Hospital to a "patient" collection.

== Map ==
The implementations of &lt;code&gt;java.util.Map&lt;/code&gt; interface are used to represent mapping between "key" and "value" objects. A Map represents a group of "key" objects, where each "key" object is mapped to a "value" object.

; Example: For each patient, there is one and only one main nurse assigned to. That association can be represented by a "patient-nurse" Map.

== Choice ==
A collection is better when you have to access all the items at once. A map is better when you have to randomly access an item regularly.

Before selecting a particular collection implementation, ask the following question:
&lt;div style="text-align: center"&gt;
''Can my collection contain the same elements, i.e. are duplicates allowed?''

''Can my collection contain the {{java:null}} element?''

''Should the collection maintain the order of the elements? Is the order important in any way?''

''How do you want to access an element? By index, key or just with an iterator?''

''Does the collection need to be synchronized?''

''From a performance perspective, which one needs to be faster, updates or reads?''

''From a usage perspective, which operation will be more frequent, updates or reads?''

&lt;/div&gt;

Once you know your needs, you can select an existing implementation. But first decide if you need a &lt;code&gt;Collection&lt;/code&gt;, or a &lt;code&gt;Map&lt;/code&gt;.

Note that the above associations are explicit. The objects them-self do not have any knowledge/information about that they are part in an association. But creating explicit associations between simple java objects is the main idea about using the aggregate/collection classes.

&lt;noinclude&gt;
{{Programming/Navigation}}
{{Status|100%}}&lt;/noinclude&gt;

[[nl:Programmeren in Java/Collections]]</text>
      <sha1>ahsmbxuq13dh7jwoy82e7n2j88xwbct</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Collection</title>
    <ns>0</ns>
    <id>70955</id>
    <revision>
      <id>3518943</id>
      <parentid>3295188</parentid>
      <timestamp>2019-02-23T14:18:12Z</timestamp>
      <contributor>
        <username>Fadirra</username>
        <id>527643</id>
      </contributor>
      <comment>/* Generics */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="28901">&lt;noinclude&gt;{{Displaytitle|title=Collection}}
{{Programming/Navigation}}
{{Java Programming/CollectionsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;
The most basic collection interface is called &lt;code&gt;Collection&lt;/code&gt;. This interface gives the user the generic usage of a collection. All collections need to have the same basic operations. Those are:
* Adding element(s) to the collection
* Removing element(s) from the collection
* Obtaining the number of elements in the collection
* Listing the contents of the collection, (Iterating through the collection)

{| style="width: 100%;"
|valign="top"|{{XCode|1=&lt;span id="code-listing-1"&gt;'''Code listing 5.1: CollectionProgram.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="7, 8, 11, 13, 14"&gt;
import java.util.Collection;   // Interface
import java.util.ArrayList;    // Implementation

public class CollectionProgram {

  public static void main(String[] args) {
    Collection myCollection = new ArrayList();
    myCollection.add("1");
    myCollection.add("2");
    myCollection.add("3");
    System.out.println("The collection contains " + myCollection.size() + " item(s).");

    myCollection.clear();
    if (myCollection.isEmpty()) {
      System.out.println("The collection is empty.");
    } else {
      System.out.println("The collection is not empty.");
    }
  }
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XCode|1='''Console for Code listing 5.1'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
The collection contains 3 item(s).
The collection is empty.
&lt;/pre&gt;}}
|}

When you put an object in a collection, this object is not actually ''in'' the collection. Only its object reference is added to the collection. This means that if an object is changed after it was put in an collection, the object in the collection also changes. The [[#code-listing-2|code listing 5.2]] computes the seven next days from tomorrow and stores each date in a list to read it afterwards. See what happens:
{| style="width: 100%;"
|valign="top"|{{XCode|1=&lt;span id="code-listing-2"&gt;'''Code listing 5.2: SevenNextDays.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="15, 21"&gt;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.GregorianCalendar;

public class SevenNextDays {

  public static void main(String[] args) {
   
    // The calendar is set at the current date: today
    Calendar calendar = new GregorianCalendar();

    Collection collectionOfDays = new ArrayList();
    Date currentDate = new Date();
    for (int i = 0; i &lt; 7; ++i) {
      // The calendar is now set to the next day
      calendar.add(Calendar.DATE, 1);
      currentDate.setTime(calendar.getTimeInMillis());

      collectionOfDays.add(currentDate);
    }

    for (Object oneDay : collectionOfDays) {
      System.out.println("The next day is: " + oneDay);
    }
  }
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XCode|1='''Console for Code listing 5.2'''
&lt;div style="background-color:#000; color:#fff;"&gt;
&lt;code style="background-color:#000; color:#fff;"&gt;&amp;nbsp;The next day is: {{#time: D M j G:i:s T Y|+ 7 days}}&lt;/code&gt;&lt;br/&gt;
&lt;code style="background-color:#000; color:#fff;"&gt;&amp;nbsp;The next day is: {{#time: D M j G:i:s T Y|+ 7 days}}&lt;/code&gt;&lt;br/&gt;
&lt;code style="background-color:#000; color:#fff;"&gt;&amp;nbsp;The next day is: {{#time: D M j G:i:s T Y|+ 7 days}}&lt;/code&gt;&lt;br/&gt;
&lt;code style="background-color:#000; color:#fff;"&gt;&amp;nbsp;The next day is: {{#time: D M j G:i:s T Y|+ 7 days}}&lt;/code&gt;&lt;br/&gt;
&lt;code style="background-color:#000; color:#fff;"&gt;&amp;nbsp;The next day is: {{#time: D M j G:i:s T Y|+ 7 days}}&lt;/code&gt;&lt;br/&gt;
&lt;code style="background-color:#000; color:#fff;"&gt;&amp;nbsp;The next day is: {{#time: D M j G:i:s T Y|+ 7 days}}&lt;/code&gt;&lt;br/&gt;
&lt;code style="background-color:#000; color:#fff;"&gt;&amp;nbsp;The next day is: {{#time: D M j G:i:s T Y|+ 7 days}}&lt;/code&gt;
&lt;/div&gt;}}
|}

All collection items were meant to be updated to a different date but they all have been updated to the last one. This means that each update has updated all the collection items. The &lt;code&gt;currentDate&lt;/code&gt; has been used to fill all the collection items. The collection didn't keep trace of the added values (one of the seven dates) but the added object references (&lt;code&gt;currentDate&lt;/code&gt;). So the collection contains the same object seven times! To avoid this issue, we should have coded it this way:
{| style="width: 100%;"
|valign="top"|{{XCode|1=&lt;span id="code-listing-3"&gt;'''Code listing 5.3: ActualSevenNextDays.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="16"&gt;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.GregorianCalendar;

public class ActualSevenNextDays {

  public static void main(String[] args) {
   
    // The calendar is set at the current date: today
    Calendar calendar = new GregorianCalendar();

    Collection collectionOfDays = new ArrayList();
    for (int i = 0; i &lt; 7; ++i) {
      Date currentDate = new Date();
      // The calendar is now set to the next day
      calendar.add(Calendar.DATE, 1);
      currentDate.setTime(calendar.getTimeInMillis());

      collectionOfDays.add(currentDate);
    }

    for (Object oneDay : collectionOfDays) {
      System.out.println("The next day is: " + oneDay);
    }
  }
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XCode|1='''Console for Code listing 5.3'''
&lt;div style="background-color:#000; color:#fff;"&gt;
&lt;code style="background-color:#000; color:#fff;"&gt;&amp;nbsp;The next day is: {{#time: D M j G:i:s T Y|+ 1 days}}&lt;/code&gt;&lt;br/&gt;
&lt;code style="background-color:#000; color:#fff;"&gt;&amp;nbsp;The next day is: {{#time: D M j G:i:s T Y|+ 2 days}}&lt;/code&gt;&lt;br/&gt;
&lt;code style="background-color:#000; color:#fff;"&gt;&amp;nbsp;The next day is: {{#time: D M j G:i:s T Y|+ 3 days}}&lt;/code&gt;&lt;br/&gt;
&lt;code style="background-color:#000; color:#fff;"&gt;&amp;nbsp;The next day is: {{#time: D M j G:i:s T Y|+ 4 days}}&lt;/code&gt;&lt;br/&gt;
&lt;code style="background-color:#000; color:#fff;"&gt;&amp;nbsp;The next day is: {{#time: D M j G:i:s T Y|+ 5 days}}&lt;/code&gt;&lt;br/&gt;
&lt;code style="background-color:#000; color:#fff;"&gt;&amp;nbsp;The next day is: {{#time: D M j G:i:s T Y|+ 6 days}}&lt;/code&gt;&lt;br/&gt;
&lt;code style="background-color:#000; color:#fff;"&gt;&amp;nbsp;The next day is: {{#time: D M j G:i:s T Y|+ 7 days}}&lt;/code&gt;
&lt;/div&gt;}}
|}

Now each time we add an item to the collection, it is a different instance. All the items evolve separately. To add an object in a collection and avoid this item being changed each time the source object is changed, you have to copy or clone the object before you add it to the collection.

== Generics ==
Objects put into a collection are upcasted to the {{java:Object}} class. This means that you need to cast the object reference back when you get an element out of the collection. It also means that '''you need to know''' the type of the object when you take it out. If a collection contains different types of objects, we will have difficulty finding out the type of the objects obtained from a collection at run time. For example. let's use this collection with two objects in it:

{{XExample|1=&lt;span id="code-section-1"&gt;'''Code section 5.1: Collection feeding.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2, 3"&gt;
Collection ageList = new ArrayList();
ageList.add(new Integer(46));
ageList.add("50");
&lt;/syntaxhighlight&gt;}}

{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-2"&gt;'''Code section 5.2: Collection reading.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3"&gt;
Integer sum = new Integer(0);
for (Object age : ageList) {
    sum = sum + ((Integer) age);
}

if (!ageList.isEmpty()) {
    System.out.println("The average age is " + sum / ageList.size());
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XCode|1='''Console for Code section 5.2'''
&lt;pre style="background-color:#000; color:#fff;"&gt;
ClassCastException.
&lt;/pre&gt;}}
|}

This error could have been found earlier, at compile time, by using generic types. The [[Java Programming/Generics|Generics]] have been added since JDK version 1.5. It is an enhancement to the type system of the Java language.  All collection implementations since 1.5 now have a ''parameterized type &lt;E&gt;''.  The ''E'' refers to an ''Element'' type.  When a collection is created, the actual ''Element type'' will replace the E.  In the collection, the objects are now upcasted to ''E'' class.

{{XExample|1=&lt;span id="code-section-3"&gt;'''Code section 5.3: Collection with generics.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3"&gt;
Collection&lt;Integer&gt; ageList = new ArrayList&lt;Integer&gt;();
ageList.add(new Integer(46));     // Integer can be added
ageList.add("50");                // Compilation error, ageList can have only Integers inside
&lt;/syntaxhighlight&gt;}}

&lt;code&gt; ageList &lt;/code&gt; is a collection that can contain only Integer objects as elements. No casting is required when we take out an element.

{{XExample|1=&lt;span id="code-section-4"&gt;'''Code section 5.4: Item reading.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
Integer age = ageList.get(0);
&lt;/syntaxhighlight&gt;}}

Generics are not mandatory but are is often used with the collection classes.

== Collection classes ==
There is no direct implementation for the &lt;code&gt;java.util.Collection&lt;/code&gt; interface.  The Collection interface has five sub interfaces.
{{Java/Illustration
|number=1
|caption=The five sub interfaces of the &lt;code&gt;java.util.Collection&lt;/code&gt; interface.
|image=[[File:Java collection interfaces.svg|400px|center]]
}}

=== Set ===
A set collection contains unique elements, so duplicates are not allowed. It is similar to a mathematical Set. When adding a new item to a set, the set calls the method &lt;code&gt;int hashCode()&lt;/code&gt; of the item and compares its result to the hash code of all the already inserted items. If the hash code is not found, the item is added. If the hash code is found, the set calls the &lt;code&gt;boolean equals(Object obj);&lt;/code&gt; method for all the set items with the same hashcode as the new item. If all equal-calls return false, the new item is inserted in the set. If an equal-call returns true, the new item is not inserted in the set.
{{Java/Illustration
|number=2
|caption=Set class diagram.
|image=[[File:Java collection set implementations.jpg|650px|center]]
}}

; &lt;span style="color: grey;"&gt;java.util.&lt;/span&gt;HashSet&lt;span style="color: grey;"&gt;&lt;E&gt;&lt;/span&gt; : This is the basic implementation of the &lt;code&gt;Set&lt;/code&gt; interface. Not synchronized. Allows the {{java:null}} elements
; &lt;span style="color: grey;"&gt;java.util.&lt;/span&gt;TreeSet&lt;span style="color: grey;"&gt;&lt;E&gt;&lt;/span&gt;: Elements are sorted, not synchronized. {{java:null}} not allowed
; &lt;span style="color: grey;"&gt;java.util.&lt;/span&gt;CopyOnWriteArraySet&lt;span style="color: grey;"&gt;&lt;E&gt;&lt;/span&gt; : Thread safe, a fresh copy is created during modification operation. Add, update, delete are expensive.
; &lt;span style="color: grey;"&gt;java.util.&lt;/span&gt;EnumSet&lt;span style="color: grey;"&gt;&lt;E extends Enum&lt;E&gt;&gt;&lt;/span&gt; : All of the elements in an enum set must come from a single enum type that is specified, explicitly or implicitly, when the set is created. Enum sets are represented internally as bit vectors.
; &lt;span style="color: grey;"&gt;java.util.&lt;/span&gt;LinkedHashSet&lt;span style="color: grey;"&gt;&lt;E&gt;&lt;/span&gt; : Same as HashSet, plus defines the iteration ordering, which is the order in which elements were inserted into the set.

====Detecting duplicate objects in Sets====

&lt;code&gt;Set&lt;/code&gt; cannot have duplicates in it. You may wonder how duplicates are detected when we are adding an object to the &lt;code&gt;Set&lt;/code&gt;. We have to see if that object exists in the Set or not. It is not enough to check the object references, the objects' values have to be checked as well.

To do that, fortunately, each java object has the [[Java Programming/API/java.lang.Object#equals() Method|&lt;code&gt;boolean equals(Object obj)&lt;/code&gt;]], method available inherited from {{java:Object}}. You need to override it. That method will be called by the Set implementation to compare the two objects to see if they are equal or not.

There is a problem, though. What if I put two different type of objects to the Set. I put an Apple and an Orange. They can not be compared.  Calling the [[Java Programming/API/java.lang.Object#equals() Method|&lt;code&gt;equals()&lt;/code&gt;]] method would cause a &lt;code&gt;ClassCastException&lt;/code&gt;. There are two solutions to this:

* '''Solution one''' : Override the [[Java Programming/API/java.lang.Object#hashCode() Method|&lt;code&gt;int hashCode()&lt;/code&gt;]] method and return the same values for the same type of objects and return different values for different type of objects.  The [[Java Programming/API/java.lang.Object#equals() Method|&lt;code&gt;equals()&lt;/code&gt;]] method is used to compare objects only with the same value of hashCode. So before an object is added, the Set implementation needs to:
** find all the objects in the Set that have the same hashCode as the candidate object hashCode
** and for those, call the [[Java Programming/API/java.lang.Object#equals() Method|&lt;code&gt;equals()&lt;/code&gt;]] methods passing in the candidate object
** if any of them returns true, the object is not added to the Set.

* '''Solution two''' : Create a super class for the Apple and Orange, let's call it Fruit class. Put Fruits in the Set. You need to do the following:
** Do not override the &lt;code&gt;equals()&lt;/code&gt; and &lt;code&gt;hashCode()&lt;/code&gt; methods in the Apple and Orange classes
** Create &lt;code&gt;appleEquals()&lt;/code&gt; method in the Apple class, and create &lt;code&gt;orangeEquals()&lt;/code&gt; method in the Orange class
** Override the &lt;code&gt;hashCode()&lt;/code&gt; method in the Fruit class and return the same value, so the &lt;code&gt;equals()&lt;/code&gt; is called by the Set implementation
** Override the &lt;code&gt;equals()&lt;/code&gt; method in the Fruit class for something like this.

{{XExample|1=&lt;span id="code-section-5"&gt;'''Code section 5.5: &lt;code&gt;equals&lt;/code&gt; method implementation.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public boolean equals(Object obj) {
    boolean ret = false;
    if (this instanceof Apple &amp;&amp;
          obj instanceof Apple) {
        ret = this.appleEquals(obj);
    } else if (this instanceof Orange &amp;&amp;
              obj  instanceof Orange) {
        ret = this.orangeEquals(obj);  
    } else {
        // Can not compare Orange to Apple
       ret = false;
    }
    return ret;
}
&lt;/syntaxhighlight&gt;}}
'''Note:'''
* Only the objects that have the same hashCode will be compared.
* You are responsible to override the &lt;code&gt;equals()&lt;/code&gt; and &lt;code&gt;hashCode()&lt;/code&gt; methods. The default implementations in Object won't work.
* Only override the [[Java Programming/API/java.lang.Object#hashCode() Method|&lt;code&gt;hashCode()&lt;/code&gt;]] method if you want to eliminate value duplicates.
* Do not override the [[Java Programming/API/java.lang.Object#hashCode() Method|&lt;code&gt;hashCode()&lt;/code&gt;]] method if you know that the values of your objects are different, or if you only want to prevent adding the exactly same object.
* Beware that the [[Java Programming/API/java.lang.Object#hashCode() Method|&lt;code&gt;hashCode()&lt;/code&gt;]] may be used in other collection implementations, like in a Hashtable to find an object fast. Overriding the default &lt;code&gt;hashCode()&lt;/code&gt; method may affect performance there.
* The default hashCodes are unique for each object created, so if you decide not to override the &lt;code&gt;hashCode()&lt;/code&gt; method, there is no point overriding the &lt;code&gt;equals()&lt;/code&gt; method, as it won't be called.

==== SortedSet ====

The &lt;code&gt;SortedSet&lt;/code&gt; interface is the same as the Set interface plus the elements in the SortedSet are sorted. It extends the Set Interface. All elements in the SortedSet must implement the Comparable Interface, furthermore all elements must be mutually comparable.

Note that the ordering maintained by a sorted set must be consistent with equals if the sorted set is to correctly implement the Set interface. This is so because the Set interface is defined in terms of the equals operation, but a sorted set performs all element comparisons using its compare method, so two elements that are deemed equal by this method are, from the standpoint of the sorted set, equal.

The SortedSet interface has additional methods due to the sorted nature of the 'Set'.  Those are:
{| class="wikitable"
|-
| &lt;code&gt;E first();&lt;/code&gt;
| returns the first element
|-
| &lt;code&gt;E last();&lt;/code&gt;
| returns the last element
|-
| &lt;code&gt;SortedSet headSet(E toElement);&lt;/code&gt;
| returns from the first, to the exclusive toElement
|-
| &lt;code&gt;SortedSet tailSet(E fromElement);&lt;/code&gt;
| returns from the inclusive fromElement to the end
|-
| &lt;code&gt;SortedSet subSet(E fromElement, E toElement);&lt;/code&gt;
| returns elements range from fromElement, inclusive, to toElement, exclusive. (If fromElement and toElement are equal, the returned sorted set is empty.)
|}

=== List ===
In a list collection, the elements are put in a certain order, and can be accessed by an index.  Duplicates are allowed, the same element can be added twice to a list. It has the following implementations:
{{Java/Illustration
|number=3
|caption=List class diagram.
|image=[[File:Java collection list implementations.jpg|650px|center]]
}}

; &lt;span style="color: grey;"&gt;java.util.&lt;/span&gt;Vector&lt;span style="color: grey;"&gt;&lt;E&gt;&lt;/span&gt; : Synchronized, use in multiple thread access, otherwise use [[Java Programming/ArrayList|ArrayList]].
; &lt;span style="color: grey;"&gt;java.util.&lt;/span&gt;Stack&lt;span style="color: grey;"&gt;&lt;E&gt;&lt;/span&gt; : It extends class Vector with five operations that allow a vector to be treated as a stack. It represents a last-in-first-out (LIFO) stack of objects.
; &lt;span style="color: grey;"&gt;java.util.&lt;/span&gt;ArrayList&lt;span style="color: grey;"&gt;&lt;E&gt;&lt;/span&gt; : The basic implementation of the &lt;code&gt;List&lt;/code&gt; interface is the &lt;code&gt;ArrayList&lt;/code&gt;. The ArrayList is not synchronized, not thread safe. &lt;code&gt;Vector&lt;/code&gt; is synchronized, and thread safe. &lt;code&gt;Vector&lt;/code&gt; is slower, because of the extra overhead to make it thread safe.  When only one thread is accessing the list, use the ArrayList. Whenever you insert or remove an element from the list, there are extra overhead to reindex the list. When you have a large list, and you have lots of insert and remove, consider using the &lt;code&gt;LinkedList&lt;/code&gt;.
; &lt;span style="color: grey;"&gt;java.util.&lt;/span&gt;LinkedList&lt;span style="color: grey;"&gt;&lt;E&gt;&lt;/span&gt; : Non-synchronized, update operation is faster than other lists, easy to use for stacks, queues, double-ended queues. The name &lt;code&gt;LinkedList&lt;/code&gt; implies a special data structure where the elements/nodes are connected by pointers.
   
  Head               Node 1                   Node 2                     Node n
   ______
  | Size |          _________________        _______________            _____________
  |______|         |      | point   |       |      | point  |          |      |      |  
  | First|--------&gt;| Data | to next |------&gt;| Data | to next|-- ... --&gt;| Data | null |
  | elem |         |______|_________|       |______|________|          |______|______|
  |______|                                                                 ^
  | Last |                                                                 |
  | elem |-----------------------------------------------------------------
  |______|

Each node is related to an item of the linked list. To remove an element from the linked list the pointers need to be rearranged. After removing Node 2:

  Head               Node 1                   Node 2                     Node n
   ______                                 _____________________
  | Size |          _________________    |   _______________   |       ______________
  |_- 1__|         |      | point   |    |  |      | point  |  |       |      |      |  
  | First|--------&gt;| Data | to next |----   | Data | to next|   -...--&gt;| Data | null |
  | elem |         |______|_________|       |______|________|          |______|______|
  |______|                                                                 ^
  | Last |                                                                 |
  | elem |-----------------------------------------------------------------
  |______|

; &lt;span style="color: grey;"&gt;javax.management.&lt;/span&gt;AtributeList&lt;span style="color: grey;"&gt;&lt;E&gt;&lt;/span&gt; : Represents a list of values for attributes of an MBean. The methods used for the insertion of Attribute objects in the AttributeList overrides the corresponding methods in the superclass ArrayList. This is needed in order to insure that the objects contained in the AttributeList are only Attribute objects.
; &lt;span style="color: grey;"&gt;javax.management.relation.&lt;/span&gt;RoleList&lt;span style="color: grey;"&gt;&lt;E&gt;&lt;/span&gt; : A RoleList represents a list of roles (Role objects). It is used as parameter when creating a relation, and when trying to set several roles in a relation (via 'setRoles()' method). It is returned as part of a RoleResult, to provide roles successfully retrieved.
; &lt;span style="color: grey;"&gt;javax.management.relation.&lt;/span&gt;RoleUnresolvedList&lt;span style="color: grey;"&gt;&lt;E&gt;&lt;/span&gt; : A RoleUnresolvedList represents a list of RoleUnresolved objects, representing roles not retrieved from a relation due to a problem encountered when trying to access (read or write to roles).

== Queue ==
The Queue interface provides additional insertion, extraction, and inspection operations. There are FIFO (first in, first out) and LIFO (last in, first out) queues. This interface adds the following operations to the Collection interface:
{| class="wikitable"
|-
| &lt;code&gt;E element()&lt;/code&gt;
| Retrieves, but does not remove, the head of this queue. This method differs from the peek method only in that it throws an exception if this queue is empty
|-
| &lt;code&gt;boolean offer(E o)&lt;/code&gt;
| Inserts the specified element into this queue, if possible.
|-
| &lt;code&gt;E peek()&lt;/code&gt;
| Retrieves, but does not remove, the head of this queue, returning null if this queue is empty
|-
| &lt;code&gt;E poll()&lt;/code&gt;
| Retrieves and removes the head of this queue, or null if this queue is empty
|-
| &lt;code&gt;E remove()&lt;/code&gt;
| Retrieves and removes the head of this queue. This method differs from the poll method in that it throws an exception if this queue is empty.
|}
{{Java/Illustration
|number=4
|caption=Queue class diagram.
|image=[[File:Java collection queue implementations.jpg|650px|center]]
}}

; &lt;span style="color: grey;"&gt;java.util.&lt;/span&gt;BlockingQueue&lt;span style="color: grey;"&gt;&lt;E&gt;&lt;/span&gt; : waits for the queue to become non-empty when retrieving an element, and waits for space to become available in the queue when storing an element. Best used for producer-consumer queues.
; &lt;span style="color: grey;"&gt;java.util.&lt;/span&gt;PriorityQueue&lt;span style="color: grey;"&gt;&lt;E&gt;&lt;/span&gt; : orders elements according to an order/priority  specified at construction time, null element is not allowed.
; &lt;span style="color: grey;"&gt;java.util.concurrent.&lt;/span&gt;ArrayBlockingQueue&lt;span style="color: grey;"&gt;&lt;E&gt;&lt;/span&gt; : orders elements FIFO; synchronized, thread safe.
; &lt;span style="color: grey;"&gt;java.util.concurrent.&lt;/span&gt;SynchronousQueue&lt;span style="color: grey;"&gt;&lt;E&gt;&lt;/span&gt; : each put must wait for a take, and vice versa, does not have any internal capacity, not even a capacity of one, an element is only present when you try to take it; you cannot add an element (using any method) unless another thread is trying to remove it.

== Complete UML class diagram ==
{{Java/Illustration
|number=5
|caption=UML class diagram of the &lt;code&gt;Collection&lt;/code&gt; interfaces and their implementations.
|image=[[File:Java collection implementation.jpg|700px|center]]
}}

== Synchronization ==
Synchronization is important when you are running several threads. Beware, synchronization does not mean that your collection is thread-safe. A thread-safe collection is also called a ''concurrent collection''. Most of the popular collection classes have implementations for both single thread and multiple thread environments. The non-synchronized implementations are always faster. You can use the non-synchronized implementations in multiple thread environments, when you make sure that only one thread updates the collection at any given time.

A new Java JDK package was introduced at Java 1.5, that is &lt;code&gt;java.util.concurrent&lt;/code&gt;.  This package supplies a few Collection implementations designed for use in multi-threaded environments.

The following table lists all the synchronized collection classes:
{| class="wikitable" style="margin: auto;"
|-
|
! synchronized
! non-synchronized
|-
| rowspan=4 | List
| java.util.Vector
| java.util.ArrayList
|-
| java.util.Stack
|
|-
|
| java.util.LinkedList
|-
| java.util.concurrent.CopyOnWriteArrayList
|
|-
| rowspan=4 | Set
|
| java.util.TreeSet
|-
|
| java.util.HashSet
|-
|
| java.util.LinkHashSet
|-
| java.util.concurrent.CopyOnWriteArraySet
|
|}

== Custom collection ==
The Java JDK collection implementations are quite powerful and good, so it is unlikely that you will need to write your own. The usage of the different collections are the same but the implementations are different. If the existing collection implementations do not meet your needs, you can write your version of the implementation. Your version of the implementation just needs to implement the same &lt;code&gt;java.util.Collection&lt;/code&gt; interface, then you can switch to using your implementation and the code that is using the collection does not need to be changed.

Use the Collection interface if you need to keep related (usually the same type of) objects together in a collection where you can:
* Search for a particular element
* List the elements
* Maintain and/or change the order of the elements by using the collection basic operations (Add, Remove, Update,..)
* Access the elements by an index number

The advantages of using the &lt;code&gt;Collection&lt;/code&gt; interface are:
* Gives a generic usage, as we talked about above, it is easy to switch implementation
* It makes it easy to convert one type of collection to another.

The &lt;code&gt;Collection&lt;/code&gt; interface defines the following basic operations:
{| class="wikitable"
|-
| &lt;code&gt;boolean add(E o);&lt;/code&gt;
| Using Element type E
|-
| &lt;code&gt;boolean addAll(Collection c);&lt;/code&gt;
|
|-
| &lt;code&gt;boolean remove({{java:Object}} o);&lt;/code&gt;
|
|-
| &lt;code&gt;boolean removeAll(Collection c);&lt;/code&gt;
|
|-
| &lt;code&gt;boolean retainAll(Collection c);&lt;/code&gt;
| Return {{java:true}} if the collection has changed due to the operation.
|}
Note that in &lt;code&gt;addAll()&lt;/code&gt; we can add any type of collection.  This is the beauty of using the Collection interface. You can have a &lt;code&gt;LinkedList&lt;/code&gt; and just call the &lt;code&gt;addAll(list)&lt;/code&gt; method, passing in a list.  You can pass in a &lt;code&gt;Vector&lt;/code&gt;, an &lt;code&gt;ArrayList&lt;/code&gt;, a &lt;code&gt;HashSet&lt;/code&gt;, a &lt;code&gt;TreeSet&lt;/code&gt;, a &lt;code&gt;YourImpOfCollection&lt;/code&gt;, ...
All those different types of collection will be '''magically''' converted to a &lt;code&gt;LinkedList&lt;/code&gt;.

Let's have a closer look at this ''magic''.  The conversion is easy because the &lt;code&gt;Collection&lt;/code&gt; interface defines  a standard way of looping through the elements.  The following code is a possible implementation of &lt;code&gt;addAll()&lt;/code&gt; method of the &lt;code&gt;LinkedList&lt;/code&gt;.

{{XExample|1=&lt;span id="code-section-6"&gt;'''Code section 5.6: Collection transfer.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
import java.util.Collection
import java.util.Iterator
...
public boolean addAll(Collection coll) {
   int sizeBefore = this.size();
   Iterator iter = coll.iterator();
   while(iter.hasNext()) {
      this.add(iter.next());
   }
   if (sizeBefore &gt; this.size()) {
      return true;
   } else {
      return false;
   }
}
&lt;/syntaxhighlight&gt;}}
The above code just iterates through the passed in collection and adds the elements to the linked list. You do not have to do that, since that is already defined. What you might need to code for is to loop through a &lt;code&gt;Customer&lt;/code&gt; collection:

{{XExample|1=&lt;span id="code-section-7"&gt;'''Code section 5.7: Iteration on a collection.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
import java.util.Collection
import java.util.Iterator
import java.yourcompany.Customer
...
public String printCustomerNames(Collection customerColl) {
   StringBuffer buf = new StringBuffer();

   Iterator iter = customerColl.iterator();
   while(iter.hasNext()) {
      Customer cust = (Customer) iter.next();
      buf.append(cust.getName());
      buf.append( "\n" );
   }
  return buf.toString();
}
&lt;/syntaxhighlight&gt;}}
Notice two things:
* The above code will work for all type of collections.
* We have to know the type of objects inside the collection, because we call a method on it.

&lt;noinclude&gt;
{{Todo|Add some exercises like the ones in [[Java Programming/Variables#Kinds of variables|Variables]]}}
{{Programming/Navigation}}
{{Status|75%}}&lt;/noinclude&gt;</text>
      <sha1>gr0mkmvidc5xoqwt5qchqtvtclr4nbc</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/ArrayList</title>
    <ns>0</ns>
    <id>284723</id>
    <revision>
      <id>3418021</id>
      <parentid>3295176</parentid>
      <timestamp>2018-05-02T20:37:47Z</timestamp>
      <contributor>
        <ip>204.102.49.90</ip>
      </contributor>
      <comment>/* Size of ArrayList */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7464">&lt;noinclude&gt;{{Displaytitle|title=ArrayList}}
{{Programming/Navigation}}
{{Java Programming/CollectionsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;
The ArrayList class extends AbstractList and implements the List interface. ArrayList supports dynamic arrays that can grow as needed.

Standard Java arrays are of a fixed length. After arrays are created, they cannot grow or shrink, which means that you must know in advance how many elements an array will hold.

Array lists are created with an initial size. When this size is exceeded, the collection is automatically enlarged. When objects are removed, the array may be shrunk.
==Initializing ==

The ArrayList class supports three constructors. The first constructor builds an empty array list.:

&lt;source lang="java"&gt;ArrayList( )&lt;/source&gt;
The following constructor builds an array list that is initialized with the elements of the collection c.

&lt;source lang="java"&gt;ArrayList(Collection c)&lt;/source&gt;
The following constructor builds an array list that has the specified initial capacity. The capacity is the size of the underlying array that is used to store the elements.

The capacity grows automatically as elements are added to an array list.
&lt;source lang="java"&gt; ArrayList(int capacity)&lt;/source&gt;
==Methods==
ArrayList defines following methods:
=== Adding Element in ArrayList===
* Inserts the specified element at the specified position index in this list. Throws IndexOutOfBoundsException if the specified index is out of range (index &lt; 0 || index &gt;= size()).
&lt;source lang="java"&gt;void add(int index, Object element)&lt;/source&gt;
*Appends the specified element to the end of this list.
&lt;source lang="java"&gt;boolean add(Object o) &lt;/source&gt;
*Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator. Throws NullPointerException if the specified collection is null.
&lt;source lang="java"&gt;boolean addAll(Collection c)
&lt;/source&gt;
*Inserts all of the elements in the specified collection into this list, starting at the specified position. Throws NullPointerException if the specified collection is null.
&lt;source lang="java"&gt;boolean addAll(int index, Collection c) 
&lt;/source&gt;

===Size of ArrayList===
*Returns the number of elements in this list.
&lt;source lang="java"&gt;int size()   &lt;/source&gt;

'' Adding Element and Size of ArrayList
&lt;source lang="java"&gt; 
import java.util.*;

public class ArrayListDemo{
	public static void main(String[] args) {
		// create an array list
		ArrayList &lt;String&gt; al= new ArrayList &lt;String&gt;();
		System.out.println("Initial ArrayList : "+al);
		
		 // add elements to the array list
		al.add("A");
		al.add("B");
		
		//find size of ArrayList
		System.out.println("Size of al :"+al.size());
		// display the array list
		System.out.println("Contents of al :"+al);
		al.add(1,"C");
		System.out.println("Contents of al :"+al);
		System.out.println("Size of al :"+al.size());
	}
}&lt;/source&gt;

'' Output for Adding Element and Size of  ArrayList
{{XCode|1=&lt;pre style="background-color:#000; color:#fff;"&gt;
Initial ArrayList : []
Size of al :2
Contents of al :[A, B]
Contents of al :[A, C, B]
Size of al :3
&lt;/pre&gt;}}

===Get and Set ArrayList Element===
*Returns the element at the specified position in this list. Throws IndexOutOfBoundsException if the specified index is is out of range (index &lt; 0 or index &gt;= size()).
&lt;source lang="java"&gt;Object get(int index) &lt;/source&gt;
*Replaces the element at the specified position in this list with the specified element. Throws IndexOutOfBoundsException if the specified index is is out of range (index &lt; 0 or index &gt;= size()).
&lt;source lang="java"&gt;Object set(int index, Object element)  &lt;/source&gt;
=== Find Index of ArrayList Element===
*Returns the index in this list of the first occurrence of the specified element, or -1 if the List does not contain this element.
&lt;source lang="java"&gt;int indexOf(Object o)   &lt;/source&gt;
*Returns the index in this list of the last occurrence of the specified element, or -1 if the list does not contain this element.
&lt;source lang="java"&gt;int lastIndexOf(Object o)  &lt;/source&gt;
=== Find Element Contain in ArrayList===
*Returns true if this list contains the specified element. More formally, returns true if and only if this list contains at least one element e such that (o==null ? e==null : o.equals(e)). 
&lt;source lang="java"&gt;boolean contains(Object o)   &lt;/source&gt;
'' Different Method in ArrayList
&lt;source lang="java"&gt; 
public class ArrayListDemo {
	public static void main(String[] args) {
		// create an array list
		ArrayList al = new ArrayList();

		// add elements to the array list
		al.add("A");
		al.add("B");
		al.add("C");
		al.add("A");
		al.add("D");
		al.add("A");
		al.add("E");
		System.out.println("Contents of al : " + al);

		// find index of element in ArrayList
		System.out.println("Index of D : " + al.indexOf("D"));
		System.out.println("Index of A : " + al.indexOf("A"));

		// find index of element in ArrayList
		System.out.println("Index of A : " + al.lastIndexOf("A"));

		// get element at given Index
		System.out.println("Element at Second Index : " + al.get(2));
		System.out.println("Element at Sixth Index : " + al.get(6));
		
		//set element at given Index
		al.set(3,"B"); // replacing third index element by "B"
		System.out.println("Contents of al : " + al);
		
		//check ArrayList contains given element
		System.out.println("ArrayList contain D : "+al.contains("D"));
		System.out.println("ArrayList contain F : "+al.contains("F"));
	}
}
&lt;/source&gt;

'' Output for Different Method in ArrayList
{{XCode|1=&lt;pre style="background-color:#000; color:#fff;"&gt;
Contents of al : [A, B, C, A, D, A, E]
Index of D : 4
Index of A : 0
Index of A : 5
Element at Second Index : C
Element at Sixth Index : E
Contents of al : [A, B, C, B, D, A, E]
ArrayList contain D : true
ArrayList contain F : false
&lt;/pre&gt;}}

{{Java/Hidden begin|title=Test your knowledge}}
'''Question''': Consider the following code:
{{java|code=
    public class ArrayListDemo {
		public static void main(String[] args) {
	
		ArrayList al = new ArrayList();

		al.add("A");
		al.add("B");
		al.add("C");
		al.add("E");
		al.add("F");
	
		al.remove(2);
		al.remove("F");
		
		al.set(1, "G");
		al.add("H");
		al.set(3, "I");
		System.out.println("Size of al : " + al.size());
		System.out.println("Contents of al : " + al);

	}
  }
}}

In the example above, what is output?
{{Java/Hidden begin|title=Answer}}
{{XCode|1=&lt;pre style="background-color:#000; color:#fff;"&gt;
Size of al : 4
Contents of al : [A, G, E, I]
&lt;/pre&gt;}}
{{Hidden end}}
{{Hidden end}}

'''Some more ArrayList methods:

{| class="wikitable"
|-
!Method!!Description
|-
|&lt;code&gt;Object clone()&lt;/code&gt;
|Returns a shallow copy of this ArrayList.
|-
|&lt;code&gt;Object[] toArray()&lt;/code&gt;
|Returns an array containing all of the elements in this list in the correct order. Throws NullPointerException if the specified array is null.
|-
|&lt;code&gt;void trimToSize()&lt;/code&gt;
|Trims the capacity of this ArrayList instance to be the list's current size.
|-
|&lt;code&gt;void ensureCapacity(int minCapacity)&lt;/code&gt;
|Increases the capacity of this ArrayList instance, if necessary, to ensure that it can hold at least the number of elements specified by the minimum capacity argument.
|-
|&lt;code&gt;protected void removeRange(int fromIndex, int toIndex)&lt;/code&gt;
|Removes from this List all of the elements whose index is between fromIndex, inclusive and toIndex, exclusive.
|}
&lt;noinclude&gt;{{Programming/Navigation}}</text>
      <sha1>tbjyt0fq8x2pnd6xpxecsz0sxwxrrsf</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Map</title>
    <ns>0</ns>
    <id>292168</id>
    <revision>
      <id>3295230</id>
      <parentid>2757052</parentid>
      <timestamp>2017-09-17T14:42:34Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="6894">&lt;noinclude&gt;{{Displaytitle|title=Map}}
{{Programming/Navigation}}
{{Java Programming/CollectionsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

Aside from the &lt;code&gt;java.util.Collection&lt;/code&gt; interface, the Java JDK has the &lt;code&gt;java.util.Map&lt;/code&gt; interface as well.  It is sometimes also called an ''Associated Array'' or a ''Dictionary''.  A map defines key value mappings.  Implementations of the Map interface do not contain collections of objects.  Instead they contain collections of key-&gt;value mappings.  It can be thought of as an array where the index doesn't need to be an integer.

{{XExample|1=&lt;span id="code-section-7"&gt;'''Code section 5.17: Use of a map.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
import java.util.Map;
import java.util.Hashtable;
...
Map map = new Hashtable();
...
map.put(key, value);
&lt;/syntaxhighlight&gt;}}

Use the Map interface if you need to keep related objects together in a Map where you can:
* Access an element by a key object
* Map one object to other

{{Java/Illustration
|number=5.6
|caption=Map Interfaces.
|image=[[File:Java map interfaces.svg|130px|center]]
}}

; &lt;span style="color: grey;"&gt;java.util.&lt;/span&gt;Map&lt;span style="color: grey;"&gt;&lt;K,V&gt;&lt;/span&gt; : maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value. The Map interface provides three collection views, which allow a map's contents to be viewed as a set of keys, collection of values, or set of key-value mappings. The key is usually a non-mutable object. The value object however can be a mutable object.
; &lt;span style="color: grey;"&gt;java.util.&lt;/span&gt;SortedMap&lt;span style="color: grey;"&gt;&lt;K,V&gt;&lt;/span&gt; : same as the Map interface, plus the keys in the Map are sorted.

In the above example, the same operations are made with two different map implementations:
{| style="width: 100%;"
|valign="top"|{{XCode|1=&lt;span id="code-listing-4"&gt;'''Code listing 5.4: MapImplementations.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="17, 19"&gt;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.TreeMap;

/**
 * Compare the map implementations.
 *
 * @author xxx
 */
public class MapImplementations {

  /**
   * Compare the map implementations.
   * @param args The execution parameters.
   */
  public static void main(String[] args) {
    processMap(new LinkedHashMap&lt;String, Integer&gt;());

    processMap(new TreeMap&lt;String, Integer&gt;());
  }

  /**
   * Use a map:
   * 1. Fill the map with key-&gt; value.
   * 2. Print all the keys.
   *
   * @param map The used map.
   */
  public static void processMap(Map&lt;String, Integer&gt; map) {
    System.out.println("Process the map");
    map.put("3", new Integer(3));
    map.put("2", new Integer(2));
    map.put("1", new Integer(1));

    for (String key : map.keySet()) {
      System.out.println(key);
    }
  }
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Console for Code listing 5.4'''
&lt;pre style="background-color:black; color:white;"&gt;
Process the map
3
2
1
Process the map
1
2
3
&lt;/pre&gt;}}
|}
We see that only the &lt;code&gt;TreeMap&lt;/code&gt; has sorted the keys. Beware of the generics. The Map interface is tricky. The methods &lt;code&gt;get()&lt;/code&gt; and &lt;code&gt;remove()&lt;/code&gt; are not generic. This means that you must be careful of the type of the key:
{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-8"&gt;'''Code section 5.18: Tricky generics.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="7"&gt;
Map&lt;Integer, String&gt; map = new TreeMap&lt;Integer, String&gt;();

map.put(new Integer(1), "Watch");
map.put(new Integer(2), "out");
map.put(new Integer(3), "!");

map.remove("2");

for (String value : map.values()) {
  System.out.println(value);
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Console for Code section 5.18'''
&lt;pre style="background-color:black; color:white;"&gt;
Watch
out
!
&lt;/pre&gt;}}
|}

The &lt;code&gt;remove()&lt;/code&gt; call has done nothing because &lt;code&gt;"2"&lt;/code&gt; is a &lt;code&gt;String&lt;/code&gt;, not an &lt;code&gt;Integer&lt;/code&gt; so no key and value has been found and removed.

=== Map Classes ===
The Map interface has the following implementations:

{{Java/Illustration
|number=5.7
|caption=Map class diagram.
|image=[[File:Java map implementation.svg|700px|center]]
}}

; &lt;span style="color: grey;"&gt;java.util.&lt;/span&gt;TreeMap&lt;span style="color: grey;"&gt;&lt;E&gt;&lt;/span&gt;: guarantees that the map will be in ascending key order, sorted according to the natural order for the key's class, not-synchronized.
; &lt;span style="color: grey;"&gt;java.util.&lt;/span&gt;Hashtable&lt;span style="color: grey;"&gt;&lt;E&gt;&lt;/span&gt; : Synchronized, null can not be used as key
; &lt;span style="color: grey;"&gt;java.util.&lt;/span&gt;HashMap&lt;span style="color: grey;"&gt;&lt;E&gt;&lt;/span&gt; : is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls
; &lt;span style="color: grey;"&gt;java.util.concurrent.&lt;/span&gt;ConcurrentHashMap : same as Hashtable, plus retrieval operations (including get) generally do not block, so may overlap with update operations (including put and remove).
; &lt;span style="color: grey;"&gt;java.util.&lt;/span&gt;WeakHashMap&lt;span style="color: grey;"&gt;&lt;E&gt;&lt;/span&gt; : entry in a WeakHashMap will automatically be removed when its key is no longer in ordinary use. Non-synchronized.
; &lt;span style="color: grey;"&gt;java.util.&lt;/span&gt;LinkedHashMap&lt;span style="color: grey;"&gt;&lt;E&gt;&lt;/span&gt; : This linked list defines the iteration ordering, which is normally the order in which keys were first inserted into the map (first insertion-order). Note that insertion order is not affected if a key is re-inserted into the map.
; &lt;span style="color: grey;"&gt;java.util.&lt;/span&gt;IdentityHashMap : This class implements the Map interface with a hash table, using reference-equality in place of object-equality when comparing keys (and values). In other words, in an IdentityHashMap, two keys k1 and k2 are considered equal if and only &lt;code&gt;if (k1==k2)&lt;/code&gt;. (In normal Map implementations (like HashMap) two keys k1 and k2 are considered equal if and only &lt;code&gt;if (k1==null ? k2==null : k1.equals(k2))&lt;/code&gt;.) Not-synchronized.
; &lt;span style="color: grey;"&gt;java.util.&lt;/span&gt;EnumMap : All of the keys in an enum map must come from a single enum type that is specified, explicitly or implicitly, when the map is created. Enum maps are represented internally as arrays. This representation is extremely compact and efficient. Not-synchronized.

== Thread safe maps ==
The following table lists all the synchronized map classes:
{| class="wikitable" style="margin: auto;"
|-
! synchronized
! non-synchronized
|-
|
| java.util.TreeMap
|-
| java.util.Hashtable
java.util.concurrent.ConcurrentHashMap
| java.util.HashMap
|-
|
| java.util.LinkedHashMap
|-
|
| java.util.IdentityHashMap
|-
|
| java.util.EnumMap
|}

&lt;noinclude&gt;
{{Todo|Add some exercises like the ones in [[Java Programming/Variables#Kinds of variables|Variables]]}}
{{Programming/Navigation}}
{{Status|75%}}&lt;/noinclude&gt;</text>
      <sha1>izdpevl8zlrbeozojczh3shx9doci0r</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Comparing Objects</title>
    <ns>0</ns>
    <id>111101</id>
    <revision>
      <id>3295190</id>
      <parentid>3030698</parentid>
      <timestamp>2017-09-17T14:41:19Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7804">&lt;noinclude&gt;{{Displaytitle|title=Comparing Objects}}
{{Programming/Navigation}}
{{Java Programming/CollectionsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;
In Java, we can distinguish two kinds of equality. 
* Object reference equality: when two object references point to the same object.
* Object value equality: when two separate objects happen to have the same values/state.
If two objects are equal in reference, they are equal in value too.

== Comparing for reference equality ==
The &lt;code&gt;==&lt;/code&gt; operator can be used to check if two object references point to the same object.
{{XExample|1='''Code section 5.19: Reference equality.'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1"&gt;
if (objRef1 == objRef2) {
    // The two object references point to the same object
}
&lt;/syntaxhighlight&gt;}}

== Comparing for value equality ==
To be able to compare two Java objects of the same class the &lt;code&gt;{{java:boolean}} equals({{java:Object}} obj)&lt;/code&gt; method must be overriden and implemented by the class.

The implementor decides which values must be equal to consider two objects to be equal. For example in the [[#code-listing-5|below class]], the &lt;code&gt;name&lt;/code&gt; and the &lt;code&gt;address&lt;/code&gt; must be equal but not the &lt;code&gt;description&lt;/code&gt;.

{{XCode|1=&lt;span id="code-listing-5"&gt;'''Code listing 5.5: Customer.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="6-20"&gt;
public class Customer {
    private String name;
    private String address;
    private String description;
    // ...
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        } else if (obj == null) {
            return false;
        } else if (obj instanceof Customer) {
            Customer cust = (Customer) obj;
            if ((cust.getName() == null &amp;&amp; name == null) ||
                (cust.getName().equals(name) &amp;&amp; ((cust.getAddress() == null &amp;&amp; address == null)
                || cust.getAddress().equals(address))) {
                return true;
            }
        }
        return false;
    }

}
&lt;/syntaxhighlight&gt;}}
After the &lt;code&gt;equals()&lt;/code&gt; method is overriden, two objects from the same class can be compared like this:

{{XExample|1='''Code section 5.20: Method usage.'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="4"&gt;
Customer cust1 = new Customer();
Customer cust2 = new Customer();
//...
if (cust1.equals(cust2)) {
    // Two Customers are equal, by name and address
}
&lt;/syntaxhighlight&gt;}}

Note that equal objects '''must''' have equal hash codes. Therefore, when overriding the &lt;code&gt;equals&lt;/code&gt; method, you must also override the &lt;code&gt;hashCode&lt;/code&gt; method. Failure to do so violates the general contract for the &lt;code&gt;hashCode&lt;/code&gt; method, and any classes that use the hash code, such as &lt;code&gt;HashMap&lt;/code&gt; will not function properly.

== Sorting/Ordering ==
In Java, there are several existing methods that already sort objects from any class like &lt;code&gt;Collections.sort(List&lt;T&gt; list)&lt;/code&gt;. However, Java needs to know the comparison rules between two objects. So when you define a new class and want the objects of your class to be sortable, you have to implement the &lt;code&gt;Comparable&lt;/code&gt; and redefine the &lt;code&gt;compareTo(Object obj)&lt;/code&gt; method. 

; {{java:int}} compareTo(T o) : Compares two objects and return an integer:
* A negative integer means that the current object is before the parameter object in the natural ordering.
* Zero means that the current object and the parameter object are equal.
* A positive integer means that the current object is after the parameter object in the natural ordering.

Let's say that the name is more important than the address and the description is ignored.

{{XCode|1=&lt;span id="code-listing-6"&gt;'''Code listing 5.6: SortableCustomer.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="6-12"&gt;
public class SortableCustomer implements Comparable&lt;SortableCustomer&gt; {
    private String name;
    private String address;
    private String description;
    // ...
    public int compareTo(SortableCustomer anotherCustomer) {
        if (name.compareTo(anotherCustomer.getName()) == 0) {
            return address.compareTo(anotherCustomer.getAddress();
        } else {
            return name.compareTo(anotherCustomer.getName();
        }
    }

}
&lt;/syntaxhighlight&gt;}}

Objects that implement this interface can be used as keys in a sorted map or elements in a sorted set, without the need to specify a comparator.

The natural ordering for a class C is said to be consistent with equals if and only if &lt;code&gt;e1.compareTo((Object) e2) == 0&lt;/code&gt; has the same boolean value as &lt;code&gt;e1.equals((Object) e2)&lt;/code&gt; for every e1 and e2 of class C. Note that null is not an instance of any class, and &lt;code&gt;e.compareTo(null)&lt;/code&gt; should throw a NullPointerException even though &lt;code&gt;e.equals(null)&lt;/code&gt; returns false.

It is strongly recommended (though not required) that natural orderings be consistent with equals. This is because sorted sets (and sorted maps) without explicit comparators behave "strangely" when they are used with elements (or keys) whose natural ordering is inconsistent with equals. In particular, such a sorted set (or sorted map) violates the general contract for set (or map), which is defined in terms of the equals method.

== Change Sorting/Ordering ==
Sometimes we may want to change the ordering of a collection of objects from the same class. We may want to order descending or ascending order. We may want to sort by &lt;code&gt;name&lt;/code&gt; or by &lt;code&gt;address&lt;/code&gt;.

We need to create a class for each way of ordering. It has to implement the &lt;code&gt;Comparator&lt;/code&gt; interface.

Since Java 5.0, the &lt;code&gt;Comparator&lt;/code&gt; interface is generic; that means when you implement it, you can specify what type of objects your comparator can compare.

{{XCode|1=&lt;span id="code-listing-7"&gt;'''Code listing 5.7: CustomerComparator.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2-4"&gt;
public class CustomerComparator implements Comparator&lt;Customer&gt; {
    public int compare(Customer cust1, Customer cust2) {
        return cust1.getName().compareTo(cust2.getName());
    }
}
&lt;/syntaxhighlight&gt;}}
The above class then can be associated with a SortedSet or other collections that support sorting.

{{XExample|1='''Code section 5.21: Comparator usage.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
Collection&lt;Customer&gt; orderedCustomers = new TreeSet&lt;Customer&gt;(new CustomerComparator());
&lt;/syntaxhighlight&gt;}}
Using the Iterator the &lt;code&gt;orderedCustomers&lt;/code&gt; collection can be iterated in order of sorted by &lt;code&gt;name&lt;/code&gt;.

A List can be sorted by the &lt;code&gt;Collections&lt;/code&gt;' &lt;code&gt;sort&lt;/code&gt; method.

{{XExample|1='''Code section 5.22: Customized comparison.'''
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
java.util.Collections.sort(custList, new CustomerComparator());
&lt;/syntaxhighlight&gt;}}
Sorts the specified list according to the order induced by the specified comparator. All elements in the list must be mutually comparable using the specified comparator.

An array of objects can also be sorted with the help of a &lt;code&gt;Comparator&lt;/code&gt;.

{{XExample|1='''Code section 5.23: Array sorting.'''
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3"&gt;
SortableCustomer[] customerArray;
//...
java.util.Arrays.sort(customerArray, new CustomerComparator());
&lt;/syntaxhighlight&gt;}}

Sorts the specified array of &lt;code&gt;Customer&lt;/code&gt; objects (customerArray) according to the order induced by the specified comparator. All elements in the array must be mutually comparable by the specified comparator.

&lt;noinclude&gt;
{{Todo|Add some exercises like the ones in [[Java Programming/Variables#Kinds of variables|Variables]]}}
{{Programming/Navigation}}
{{Status|75%}}&lt;/noinclude&gt;</text>
      <sha1>duwd6l4i2mrhxvyh6ooras3r5ytjafi</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Exceptions</title>
    <ns>0</ns>
    <id>58123</id>
    <revision>
      <id>3449627</id>
      <parentid>3295200</parentid>
      <timestamp>2018-08-11T15:01:11Z</timestamp>
      <contributor>
        <ip>2602:306:3BF4:7560:976:C1B6:F3B0:33F6</ip>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3176">&lt;noinclude&gt;{{Displaytitle|title=Exceptions}}
{{Programming/Navigation}}
{{Java Programming/ExceptionsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

The ideal time to catch an error is at compile time, before you even try to run the program. However, not all errors can be detected at compile time. The rest of the problems must be handled at run time through some formality that allows the originator of the error to pass appropriate information to a recipient who will know how to handle the difficulty properly.

Improved error recovery is one of the most powerful ways that you can increase the robustness of your code. Error recovery is a fundamental concern for every program you write, but it's especially important in Java, where one of the primary goals is to create program components for others to use. ''To create a robust system, each component must be robust''. By providing a consistent error-reporting model using exceptions, Java allows components to reliably communicate problems to client code.

==Flow of code execution==
In Java, there are two main flows of code executions.
* Normal main sequential code execution, the program doing what it meant to accomplish.
* Exception handling code execution, the main program flow was interrupted by an error or some other condition that prevent the continuation of the normal main sequential code execution. 

; Exception : Exceptions are Java's way of error handling.  Whenever an unexpected condition occurs, an exception can be thrown with an exception object as a parameter. It means that the normal program control flow stops and the search for a {{java:catch}} block begins. If that is not found at the current method level the search continues at the caller method level, until a matching {{java:catch}} block is found. If none is found the exception will be handled by the JVM, and usually the java program terminates. 

:When a {{java:catch}} "matching" block is found, that block will be executed, the exception object is passed to the block as a parameter. Then normal program execution continues after the {{java:catch}} block. ''See Java [[Java Programming/Keywords/try|exception handling syntax]].''

; Exception Object : This is the object that is "thrown" as a parameter from the error, and passed to the {{java:catch}} block. Exception object encapsulates the information about the error's location and its nature.  All Exception objects must be inherited from the &lt;code&gt;java.lang.Throwable&lt;/code&gt;. See the [[#figure-1|UML diagram]] below.
{{Java/Illustration
|number=&lt;span id="figure-1"&gt;6.1&lt;/span&gt;
|caption=Java exception classes
|image=[[Image:Java exception classes.svg|center]]
}}

; Matching rule : A thrown exception object can be caught by the {{java:catch}} keyword and specifying the exception object's class or its super-class.

; Naming convention : It is good practice to add Exception to all exception classes. The name of the exception should be meaningful, and should represent the problem. For example, &lt;code&gt;CustomerNotFoundException&lt;/code&gt; may indicate that a customer was not found.

&lt;noinclude&gt;{{Programming/Navigation}}
{{Status|100%}}

[[nl:Programmeren in Java/Exceptions]]
&lt;/noinclude&gt;</text>
      <sha1>ccv3jlsxsx3b7i8a40gcod8b9sac3f3</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Throwing and Catching Exceptions</title>
    <ns>0</ns>
    <id>56651</id>
    <revision>
      <id>3449936</id>
      <parentid>3295257</parentid>
      <timestamp>2018-08-12T16:07:25Z</timestamp>
      <contributor>
        <ip>109.78.2.33</ip>
      </contributor>
      <comment>/* Exception object */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="16051">&lt;noinclude&gt;{{Displaytitle|title=Throwing and Catching Exceptions}}
{{Programming/Navigation}}
{{Java Programming/ExceptionsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

Language compilers are adept at pointing out most of the erroneous code in a program, however there are some errors that only become apparent when the program is executed. Consider the [[#code-listing-1|code listing 6.1]]; here, the program defines a method '''divide''' that does a simple division operation taking two integers as parameter arguments and returning the result of their division. It can safely be assumed that when the '''divide(4, 2)''' statement is called, it would return the number '''2'''. However, consider the next statement, where the program relies upon the provided command line arguments to generate a division operation. What if the user provides the number zero ('''0''') as the second argument? We all know that division  by zero is impossible, but the compiler couldn't possibly have anticipated the user providing zero as an argument.
&lt;br clear="all"/&gt;

{| style="width: 100%;"
|valign="top"|{{XCode|1=&lt;span id="code-listing-1"&gt;'''Code listing 6.1: SimpleDivisionOperation.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="12"&gt;
public class SimpleDivisionOperation {
  public static void main(String[] args) {
    System.out.println(divide(4, 2));
    if (args.length &gt; 1) {
      int arg0 = Integer.parseInt(args[0]);
      int arg1 = Integer.parseInt(args[1]);
      System.out.println(divide(arg0, arg1));
    }
  }

  public static int divide(int a, int b) {
    return a / b;
  }
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code listing 6.1'''
&lt;pre style="background-color:black; color:white;"&gt;
$ java SimpleDivisionOperation 1 0
2
Exception in thread "main" java.lang.ArithmeticException: / by zero
     at SimpleDivisionOperation.divide(SimpleDivisionOperation.java:12)
     at SimpleDivisionOperation.main(SimpleDivisionOperation.java:7)
&lt;/pre&gt;}}
|}

Such ''exceptional code'' that results in erroneous interpretations at program runtime usually results in errors that are called ''exceptions'' in Java. When the Java interpreter encounters an exceptional code, it halts execution and displays information about the error that occurs. This information is known as a ''stack trace''. The [[Java Programming/Stack trace|stack trace]] in the above example tells us more about the error, such as the thread &amp;mdash; &lt;code&gt;"main"&lt;/code&gt; &amp;mdash; where the exception occurred, the type of exception &amp;mdash; &lt;code&gt;java.lang.ArithmeticException&lt;/code&gt;, a comprehensible display message &amp;mdash; &lt;code&gt;/ by zero&lt;/code&gt;, and the exact methods and the line numbers where the exception may have occurred.

==Exception object==
The preceding exception could have been created explicitly by the developer as it is the case in the following code:

{| style="width: 100%;"
|valign="top"|{{XCode|1=&lt;span id="code-listing-2"&gt;'''Code listing 6.2: SimpleDivisionOperation.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="14"&gt;
public class SimpleDivisionOperation {
  public static void main(String[] args) {
    System.out.println(divide(4, 2));
    if (args.length &gt; 1) {
      // Convert a string to an integer
      int arg0 = Integer.parseInt(args[0]);
      int arg1 = Integer.parseInt(args[1]);
      System.out.println(divide(arg0, arg1));
    }
  }

  public static int divide(int a, int b) {
    if (b == 0) {
      throw new ArithmeticException("You can\'t divide by zero!");       
    } else {
      return a / b;
    }
  }
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code listing 6.2'''
&lt;pre style="background-color:black; color:white;"&gt;
$ java SimpleDivisionOperation 1 0
2
Exception in thread "main" java.lang.ArithmeticException: You can't divide by zero!
at SimpleDivisionOperation.divide(SimpleDivisionOperation.java:14)
at SimpleDivisionOperation.main(SimpleDivisionOperation.java:8)
&lt;/pre&gt;}}
|}

Note that when &lt;code&gt;b&lt;/code&gt; equals zero, there is no return value. Instead of a &lt;code&gt;java.lang.ArithmeticException&lt;/code&gt; generated by the Java interpreter itself, it is an exception created by the coder. The result is the same. It shows you that an exception is an object. Its main particularity is that it can be thrown. An exception object must inherit from &lt;code&gt;java.lang.Exception&lt;/code&gt;. Standard exceptions have two constructors:
# The default constructor; and,
# A constructor taking a string argument so that you can place pertinent information in the exception.

{{XExample|1=&lt;span id="code-section-1"&gt;'''Code section 6.1: Instance of an exception object with the default constructor.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
new Exception();
&lt;/syntaxhighlight&gt;}}

{{XExample|1=&lt;span id="code-section-2"&gt;'''Code section 6.2: Instance of an &lt;code&gt;Exception&lt;/code&gt; object by passing string in constructor.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
new Exception("Something unexpected happened");
&lt;/syntaxhighlight&gt;}}
This string can later be extracted using various methods, as you can see in the [[#code-listing-2|code listing 6.2]].

You can throw any type of '''Throwable''' object using the keyword {{Java:throw}}. It interrupts the method. Anything after the '''throw''' statement would not be executed, unless the ''thrown'' exception is [[#Exception handlers|handled]]. The exception object is not ''returned'' from the method, it is ''thrown'' from the method. That means that the exception object is not the return value of the method and the calling method can be interrupted too and so on and so on...

Typically, you'll throw a different class of exception for each different type of error. The information about the error is represented both inside the exception object and implicitly in the name of the exception class, so someone in the bigger context can figure out what to do with your exception. Often, the only information is the type of exception, and nothing meaningful is stored within the exception object.

=== Oracle standard exception classes ===
The box 6.1 below talks about the various exception classes within the &lt;code&gt;java.lang&lt;/code&gt; package.
{| style="border:solid 1px #2a7fff; background-color:#fdfdfd;"
|-
| style="padding:8px;" |
'''Box 6.1: The Java exception classes'''

; Throwable : The Throwable class is the superclass of all errors and exceptions in the Java language. Only objects that are instances of this class (or one of its subclasses) are thrown by the Java Virtual Machine or can be thrown by the Java throw statement.
: A throwable contains a snapshot of the execution stack of its thread at the time it was created. It can also contain a message string that gives more information about the error. Finally, it can contain a cause: another throwable that caused this throwable to get thrown. The cause facility was added in release 1.4. It is also known as the chained exception facility, as the cause can, itself, have a cause, and so on, leading to a "chain" of exceptions, each caused by another.
; Error : An Error indicates serious problems that a reasonable application should not try to handle. Most such errors are abnormal conditions.
; Exception : The class Exception and its subclasses are a form of Throwable that indicates conditions that a reasonable application might want to handle. Also this is the class that a programmer may want to extend when adding business logic exceptions.
; RuntimeException : RuntimeException is the superclass of those exceptions that can be thrown during the normal operation of the Java Virtual Machine. A method is not required to declare in its throws clause any subclasses of RuntimeException that might be thrown during the execution of the method but not caught.
| style="padding:8px;" | &lt;span style="color:#2a7fff;"&gt;'''Figure 6.2:''' The exception classes and their inheritance model in the JCL.&lt;/span&gt;&lt;br/&gt;
[[Image:Java exception classes.svg|center]]
|}

== &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; statement ==
By default, when an exception is thrown, the current method is interrupted, the calling method is interrupted too and so on till the &lt;code&gt;main&lt;/code&gt; method. A thrown exception can also be caught using a
&lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; statement. Below is how a &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; statement works:

{{XExample|1=&lt;span id="code-section-3"&gt;'''Code section 6.3: Division into a &lt;code&gt;try&lt;/code&gt; block.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1-3, 5-6, 10"&gt;
int a = 4;
int b = 2;
int result = 0;
try {
  int c = a / b;
  result = c;
} catch(ArithmeticException ex) {
  result = 0;
}
return result;
&lt;/syntaxhighlight&gt;}}

The executed code lines have been highlighted. When no exception is thrown, the method flow executes the &lt;code&gt;try&lt;/code&gt; statement and not the &lt;code&gt;catch&lt;/code&gt; statement.

{{XExample|1=&lt;span id="code-section-4"&gt;'''Code section 6.4: Catching 'division by zero' errors.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1-3, 5, 8, 10"&gt;
int a = 4;
int b = 0;
int result = 0;
try {
  int c = a / b;
  result = c;
} catch(ArithmeticException ex) {
  result = 0;
}
return result;
&lt;/syntaxhighlight&gt;}}

As there is a thrown exception at line 5, the line 6 is not executed, but the exception is caught by the &lt;code&gt;catch&lt;/code&gt; statement so the &lt;code&gt;catch&lt;/code&gt; block is executed. The following code is also executed. Note that the &lt;code&gt;catch&lt;/code&gt; statement takes an exception as parameter. There is a third case: when the exception is not from the same class as the parameter:

{{XExample|1=&lt;span id="code-section-5"&gt;'''Code section 6.5: Uncaught exception.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1-3, 5"&gt;
int a = 4;
int b = 0;
int result = 0;
try {
  int c = a / b;
  result = c;
} catch(NullPointerException ex) {
  result = 0;
}
return result;
&lt;/syntaxhighlight&gt;}}

It is as if there is no &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; statement. The exception is thrown to the calling method.

== &lt;code&gt;catch&lt;/code&gt; blocks ==
A &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; statement can contain several &lt;code&gt;catch&lt;/code&gt; blocks, to handle different exceptions in different ways. Each &lt;code&gt;catch&lt;/code&gt; block must take a parameter of a different throwable class. A thrown object may match several &lt;code&gt;catch&lt;/code&gt; block but only the first &lt;code&gt;catch&lt;/code&gt; block that matches the object will be executed. A catch-block will catch a thrown exception if and only if:
* the thrown exception object is the same as the exception object specified by the catch-block.
* the thrown exception object is the subtype of the exception object specified by the catch-block.
This means that the &lt;code&gt;catch&lt;/code&gt; block order is important. As a consequence, you can't put a &lt;code&gt;catch&lt;/code&gt; block that catches all the exception (which take a &lt;code&gt;java.lang.Exception&lt;/code&gt; as parameter) before a &lt;code&gt;catch&lt;/code&gt; block that catches a more specific exception as the second block could never be executed.

{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-6"&gt;'''Code section 6.6: Exception handling with catch blocks.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="7, 14-16"&gt;
try {
  // Suppose the code here throws any exceptions,
  // then each is handled in a separate catch block.

  int[] tooSmallArray = new int[2];
  int outOfBoundsIndex = 10000;
  tooSmallArray[outOfBoundsIndex] = 1;

  System.out.println("No exception thrown.");
} catch(NullPointerException ex) {
  System.out.println("Exception handling code for the NullPointerException.");
} catch(NumberFormatException ex) {
  System.out.println("Exception handling code for the NumberFormatException.");
} catch(ArithmeticException | IndexOutOfBoundsException ex) {
  System.out.println("Exception handling code for ArithmeticException"
    + " or IndexOutOfBoundsException.");
} catch(Exception ex) {
  System.out.println("Exception handling code for any other Exception.");
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code section 6.6'''
&lt;pre style="background-color:black; color:white;"&gt;
Exception handling code for ArithmeticException or IndexOutOfBoundsException.
&lt;/pre&gt;}}
|}
At line 14, we use a '''multi-catch''' clause. It is available since the JDK 7. This is a combination of several '''catch''' clauses and let's you handle exceptions in a single handler while also maintaining their types. So, instead of being boxed into a parent Exception super-class, they retain their individual types.

You can also use the &lt;code&gt;java.lang.Throwable&lt;/code&gt; class here, since '''Throwable''' is the parent class for the ''application-specific'' '''Exception''' classes. However, this is discouraged in Java programming circles. This is because '''Throwable''' happens to also be the parent class for the ''non-application specific'' '''Error''' classes which are not meant to be handled explicitly as they are catered for by the JVM itself.

== &lt;code&gt;finally&lt;/code&gt; block ==

A {{Java:finally}} block can be added after the &lt;code&gt;catch&lt;/code&gt; blocks. A &lt;code&gt;finally&lt;/code&gt; block is always executed, even when no exception is thrown, an exception is thrown and caught, or an exception is thrown and not caught. It's a place to put code that should always be executed after an unsafe operation like a file close or a database disconnection. You can define a &lt;code&gt;try&lt;/code&gt; block without &lt;code&gt;catch&lt;/code&gt; block, however, in this case, it must be followed by a &lt;code&gt;finally&lt;/code&gt; block.

== Example of handling exceptions==
Let's examine the following code:
{{XWarning|1=&lt;span id="code-section-7" style="color: red;"&gt;'''Code section 6.7: Handling exceptions.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="10, 11"&gt;
public void methodA() throws SomeException {
    // Method body
}

public void methodB() throws CustomException, AnotherException {
    // Method body
}

public void methodC() {
    methodB();
    methodA();
}
&lt;/syntaxhighlight&gt;}}

In the [[#code-section-7|code section 6.7]], &lt;code&gt;methodC&lt;/code&gt; is invalid.  Because &lt;code&gt;methodA&lt;/code&gt; and &lt;code&gt;methodB&lt;/code&gt; pass (or throw) exceptions, &lt;code&gt;methodC&lt;/code&gt; must be prepared to handle them.  This can be handled in two ways: a {{java:try}}-{{java:catch}} block, which will handle the exception within the method and a {{java:throws}} clause which would in turn throw the exception to the caller to handle.  The above example will cause a compilation error, as Java is very strict about exception handling. So the programmer is forced to handle any possible error condition at some point.

A method can do two things with an exception: ask the calling method to handle it by the {{java:throws}} declaration or handle the exception inside the method by the {{java:try}}-{{java:catch}} block.

To work correctly, the original code can be modified in multiple ways.  For example, the following:
{{XExample|1=&lt;span id="code-section-8"&gt;'''Code section 6.8: Catching and throwing exceptions.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1, 2, 4-6"&gt;
public void methodC() throws CustomException, SomeException {
  try {
    methodB();
  } catch(AnotherException e) {
    // Handle caught exceptions.
  }
  methodA();
}
&lt;/syntaxhighlight&gt;}}
 
The &lt;code&gt;AnotherException&lt;/code&gt; from &lt;code&gt;methodB&lt;/code&gt; will be handled locally, while &lt;code&gt;CustomException&lt;/code&gt; and &lt;code&gt;SomeException&lt;/code&gt; will be thrown to the caller to handle it. Most of the developers are embarrassed when they have to choose between the two options. This type of decision should not be taken at development time. If you are a development team, it should be discussed between all the developers in order to have a common exception handling policy.

==Keyword references==
* {{Java:try}}
* {{Java:catch}}
* {{Java:finally}}
* {{Java:throws}}
* {{Java:throw}}

&lt;noinclude&gt;
{{Todo|Add some exercises like the ones in [[Java Programming/Variables#Kinds of variables|Variables]]}}
{{Programming/Navigation}}
{{Status|75%}}&lt;/noinclude&gt;</text>
      <sha1>qw04xmonybu15pjjusqdwfgf18e6rk6</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Checked Exceptions</title>
    <ns>0</ns>
    <id>90087</id>
    <revision>
      <id>3444171</id>
      <parentid>3444163</parentid>
      <timestamp>2018-07-19T11:04:16Z</timestamp>
      <contributor>
        <username>Leaderboard</username>
        <id>1176064</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="4499">&lt;noinclude&gt;{{Displaytitle|title=Checked Exceptions}}
{{Programming/Navigation}}
{{Java Programming/ExceptionsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

A checked exception is a type of exception that must be either caught or declared in the method in which it is thrown. For example, the &lt;code&gt;java.io.IOException&lt;/code&gt; is a checked exception. To understand what is a checked exception, consider the following code:
{{XWarning|1=&lt;span id="code-section-9" style="color: red;"&gt;'''Code section 6.9: Unhandled exception.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="3"&gt;
public void ioOperation(boolean isResourceAvailable) {
  if (!isResourceAvailable) {
    throw new IOException();
  }
}
&lt;/syntaxhighlight&gt;}}

This code won't compile because it can throw a checked exception. The compilation error can be resolved in either of two ways: By catching the exception and handling it, or by declaring that the exception can be thrown using the {{java:throws}} keyword.

{| style="width: 100%;"
|valign="top"|{{XExample|1=&lt;span id="code-section-10"&gt;'''Code section 6.10: Catching an exception.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2, 6-8"&gt;
public void ioOperation(boolean isResourceAvailable) {
  try {
    if (!isResourceAvailable) {
      throw new IOException();
    }
  } catch(IOException e) {
    // Handle caught exceptions.
  }
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XExample|1=&lt;span id="code-section-11"&gt;'''Code section 6.11: Declaring an exception.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1"&gt;
public void ioOperation(boolean isResourceAvailable) throws IOException {
  if (!isResourceAvailable) {
    throw new IOException();
  }
}
&lt;/syntaxhighlight&gt;}}
|}

In the Java class hierarchy, an exception is a checked exception if it inherits from &lt;code&gt;java.lang.Throwable&lt;/code&gt;, but not from &lt;code&gt;java.lang.RuntimeException&lt;/code&gt; or &lt;code&gt;java.lang.Error&lt;/code&gt;. All the application or business logic exceptions should be checked exceptions.

It is possible that a method declares that it can throw an exception, but actually it does not. Still, the caller has to deal with it. The checked exception declaration has a domino effect. Any methods that will use the previous method will also have to handle the checked exception, and so on.

So the compiler for the Java programming language checks, at compile time, that a program contains handlers for all application exceptions, by analyzing each method body. If, by executing the method body, an exception can be thrown to the caller, that exception must be declared. How does the compiler know whether a method body can throw an exception? That is easy. Inside the method body, there are calls to other methods; the compiler looks at each of their method signature, what exceptions they declared to throw.

== Why Force Exception Handling? ==
This may look boring to the developer but it forces them to think about all the checked exceptions and increase the code quality. This compile-time checking for the presence of exception handlers is designed to make the application developer life easier. To debug whether a particular thrown exception has a matching catch would be a long process. In conventional languages like C, and C++, a separate error handling debugging were needed. In Java we can be sure that when an application exception is thrown, that exception somewhere in the program is handled. In C, and C++, that has to be tested. In Java that does not need to be tested, so the freed up time can be used for more meaningful testing, testing the business features.

== What Exceptions can be Declared when Overriding a Method? ==

The checked exception classes specified after the {{java:throws}} keyword are part of the contract between the implementer and user. An overriding method can declare the same exceptions, subclasses or no exceptions.

== What Exceptions can be Declared when Implementing an Interface?  ==

JAVA 1.8 onwards: When interfaces are involved, the implementation declaration may skip a throws-clause but if one wish to have then should be compatible with the interface declarations. In other words, the implementation should throw the declared exception or it's sub-type or no exception.

Prior to Java 1.8: The implementer must declare same exception or its subclass.  

&lt;noinclude&gt;
{{Todo|Add some exercises like the ones in [[Java Programming/Variables#Kinds of variables|Variables]]}}
{{Programming/Navigation}}
{{Status|75%}}&lt;/noinclude&gt;</text>
      <sha1>cfw7qkbq4313oxgdd2vzdjbj19nqf9m</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Unchecked Exceptions</title>
    <ns>0</ns>
    <id>90086</id>
    <revision>
      <id>3295259</id>
      <parentid>3080920</parentid>
      <timestamp>2017-09-17T14:43:30Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="2357">&lt;noinclude&gt;{{Displaytitle|title=Unchecked Exceptions}}
{{Programming/Navigation}}
{{Java Programming/ExceptionsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

Unchecked, uncaught or runtime exceptions are exceptions that can be thrown without being caught or declared:

{{XExample|1=&lt;span id="code-section-12"&gt;'''Code section 6.12: Throwing an exception without declaring it or catching it.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2"&gt;
public void futureMethod() {
  throw new RuntimeException("This method is not yet implemented");
}
&lt;/syntaxhighlight&gt;}}

...however, you can still declare and catch such exceptions. Runtime exceptions are not business exceptions. They are usually related to hard-coded issues like data errors, arithmetic overflow, divide by zero etc. In other words, errors that can't be worked around nor anticipated. The most famous (and feared) runtime exception is the &lt;code&gt;NullPointerException&lt;/code&gt;.

A runtime exception must be or inherit from the &lt;code&gt;RuntimeException&lt;/code&gt; class or the &lt;code&gt;Error&lt;/code&gt; class.

Sometime it is desirable to catch all exceptions for logging purposes, then throw them back in. For example, in servlet programming when an application server calls the server &lt;code&gt;getLastModified()&lt;/code&gt;, we want to monitor that no exceptions happened during the serving of the request. The application has its own logging separate from the server logging so the runtime exceptions would just go through without being detected by the application. The following code checks all exceptions, logs them and throws them back again.

{{XExample|1=&lt;span id="code-section-13"&gt;'''Code section 6.13: Logging an exception.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="6-9"&gt;
public long getLastModified(HttpServletRequest req) {
  try {
    ...
    return getTimeStamp();
    ...
  } catch(RuntimeException e) {
    log.error("Error during handling post request", e);

    throw e;
  }
}
&lt;/syntaxhighlight&gt;}}

In the above code, all business logic exception are handled in the &lt;code&gt;getTimeStamp()&lt;/code&gt; method. Runtime exceptions are caught for logging purposes, and then thrown back to the server to be handled.

&lt;noinclude&gt;
{{Todo|Add some exercises like the ones in [[Java Programming/Variables#Kinds of variables|Variables]]}}
{{Programming/Navigation}}
{{Status|75%}}&lt;/noinclude&gt;</text>
      <sha1>9fl07h21mie6m67oaeek5i1crzw8z8v</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Preventing NullPointerException</title>
    <ns>0</ns>
    <id>53415</id>
    <revision>
      <id>3513842</id>
      <parentid>3513810</parentid>
      <timestamp>2019-02-01T18:16:31Z</timestamp>
      <contributor>
        <username>JackPotte</username>
        <id>99248</id>
      </contributor>
      <minor/>
      <comment>[[WB:REVERT|Reverted]] edits by [[Special:Contributions/2607:FB90:6AE0:4A2E:83:92C6:1F49:D249|2607:FB90:6AE0:4A2E:83:92C6:1F49:D249]] ([[User talk:2607:FB90:6AE0:4A2E:83:92C6:1F49:D249|talk]]) to last version by 2607:FB90:8446:7219:7C88:61DE:D9AB:E983</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="7995">&lt;noinclude&gt;{{Displaytitle|title=Preventing NullPointerException}}
{{Programming/Navigation}}
{{Java Programming/ExceptionsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

&lt;code&gt;NullPointerException&lt;/code&gt; is a &lt;code&gt;RuntimeException&lt;/code&gt;. In Java, a special {{java:null}} value can be assigned to an object reference.
&lt;code&gt;NullPointerException&lt;/code&gt; is thrown when an application attempts to use an object reference that has the {{java:null}} value.
These include:
* Calling an instance method on the object referred by a null reference.
* Accessing or modifying an instance field of the object referred by a null reference.
* If the reference type is an array type, taking the length of a null reference.
* If the reference type is an array type, accessing or modifying the slots of a null reference.
* If the reference type is a subtype of &lt;code&gt;Throwable&lt;/code&gt;, throwing a null reference.
Applications should throw instances of this class to indicate other illegal uses of the null object.
{{XExample|1=&lt;span id="code-section-13"&gt;'''Code section 6.13: Null pointer.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2"&gt;
Object obj = null;
obj.toString();  // This statement will throw a NullPointerException
&lt;/syntaxhighlight&gt;}}
The above code shows one of the pitfalls of Java and the most common source of bugs. No object is created and the compiler does not detect it. &lt;code&gt;NullPointerException&lt;/code&gt; is one of the most common exceptions thrown in Java.

== Why do we need &lt;code&gt;null&lt;/code&gt;? ==

The reason we need it is because many times we need to create an object reference before the object itself is created. Object references cannot exist without a value, so we assign the [[Java_Programming/Literals#null|&lt;code&gt;null&lt;/code&gt;]] value to it.
{{XExample|1=&lt;span id="code-section-14"&gt;'''Code section 6.14: Non-instantiated declared object.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2"&gt;
public Person getPerson(boolean isWoman) {
  Person person = null;
  if (isWoman) {
    person = createWoman();
  } else {
    person = createMan();
  }
  return person;
}
&lt;/syntaxhighlight&gt;}}
In [[#code-section-14|code section 6.14]] we want to create the &lt;code&gt;Person&lt;/code&gt; inside the if-else, but we also want to return the object reference to the caller, so we need to create the object reference outside of the if-else, because of the [[Java Programming/Scope|scoping rule]] in Java. Incorrect error-handling and poor contract design can be a pitfall with any programming language. This is also true for Java.

Now we will describe how to prevent &lt;code&gt;NullPointerException&lt;/code&gt;. We do not describe general techniques for how you should program Java, we just hope to make you more aware of null values, and to be more careful about generating them yourself.

This list is not complete &amp;mdash; there are no rules for preventing &lt;code&gt;NullPointerException&lt;/code&gt; entirely in Java, because the standard libraries have to be used, and they can cause &lt;code&gt;NullPointerException&lt;/code&gt;s.  Also, it is possible to observe an uninitialized final field in Java, so you can't even treat a final field as being completely trusted during the object's creation.

A good approach is to learn how to deal with &lt;code&gt;NullPointerException&lt;/code&gt;s first, and become competent with that.  These suggestions will help you to cause less &lt;code&gt;NullPointerException&lt;/code&gt;s, but they don't replace the need to know about &lt;code&gt;NullPointerException&lt;/code&gt;s.

== Comparing string variable with a string literal ==

When you compare a variable with a string literal, most of people would do that this way:

{{XExample|1=&lt;span id="code-section-15"&gt;'''Code section 6.15: Bad comparison.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1"&gt;
if (state.equals("OK")) {
  ...
}
&lt;/syntaxhighlight&gt;}}

Always put the string literal first:
{{XExample|1=&lt;span id="code-section-16"&gt;'''Code section 6.16: Better comparison.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1"&gt;
if ("OK".equals(state)) {
  ...
}
&lt;/syntaxhighlight&gt;}}

If the &lt;code&gt;state&lt;/code&gt; variable is null, you get a &lt;code&gt;NullPointerException&lt;/code&gt; in the first example, but not in the second one.

== Minimize the use of the keyword 'null' in assignment statements ==

This means not doing things like:

{{XExample|1=&lt;span id="code-section-17"&gt;'''Code section 6.17: Declaring an exception.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1"&gt;
String s = null;
while (something) {
    if (something2) {
        s = "yep";
    }
}

if (s != null) {
    something3(s);
}
&lt;/syntaxhighlight&gt;}}

You can replace this with:

{{XExample|1=&lt;span id="code-section-18"&gt;'''Code section 6.18: Declaring an exception.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1"&gt;
boolean done = false;

while (!done &amp;&amp; something) {
    if (something2) {
       done = true;
       something3("yep");
    }
}
&lt;/syntaxhighlight&gt;}}

You might also consider replacing null with "" in the first example, but default values bring about bugs caused by default values being left in place.  A &lt;code&gt;NullPointerException&lt;/code&gt; is actually better, as it allows the runtime to tell you about the bug, rather than just continue with a default value.

==Minimize the use of the new Type[int] syntax for creating arrays of objects==

An array created using &lt;code&gt;new Object[10]&lt;/code&gt; has 10 null pointers.  That's 10 more than we want, so use collections instead, or explicitly fill the array at initialization with:

{{XExample|1=&lt;span id="code-section-19"&gt;'''Code section 6.19: Declaring an exception.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1"&gt;
Object[] objects = {"blah", 5, new File("/usr/bin")};
&lt;/syntaxhighlight&gt;}}

or:

{{XExample|1=&lt;span id="code-section-20"&gt;'''Code section 6.20: Declaring an exception.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1"&gt;
Object[] objects;
objects = new Object[]{"blah", 5, new File("/usr/bin")};
&lt;/syntaxhighlight&gt;}}

==Check all references obtained from 'untrusted' methods==

Many methods that can return a reference null reference.  Make sure you check these.  For example:

{{XExample|1=&lt;span id="code-section-21"&gt;'''Code section 6.21: Declaring an exception.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="1"&gt;
File file = new File("/etc");
File[] files = file.listFiles();
if (files != null) {
    stuff
}
&lt;/syntaxhighlight&gt;}}

&lt;code&gt;File.listFiles()&lt;/code&gt; can return null if &lt;code&gt;/etc&lt;/code&gt; is not a directory.

You can decide to trust some methods not to return null, if you like, but that's an assumption you're making.  Some methods that don't specify that they might return null, actually do, instead of throwing an exception.

== For each loop trap ==

Beware if you loop on an array or a collection in a for each loop.

{{XExample|1=&lt;span id="code-section-22"&gt;'''Code section 6.22: Visit a collection.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2"&gt;
Collection&lt;Integer&gt; myNumbers = buildNumbers();
for (Integer myNumber : myNumbers) {
  System.out.println(myNumber);
}
&lt;/syntaxhighlight&gt;}}

If the object is null, it does not just do zero loops, it throws a null pointer exception. So don't forget this case. Add an &lt;code&gt;if&lt;/code&gt; statement or return empty collections:

{{XExample|1=&lt;span id="code-section-23"&gt;'''Code section 6.23: Visit a collection safety.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="2, 6"&gt;
Collection&lt;Integer&gt; myNumbers = buildNumbers();
if (myNumbers != null) {
  for (Integer myNumber : myNumbers) {
    System.out.println(myNumber);
  }
}
&lt;/syntaxhighlight&gt;}}

== External tools ==
There are tools like FindBugs that parse your code and warn you about potential bugs. Most of the time, these tools detect possible null pointers.

&lt;noinclude&gt;
{{Todo|Add some exercises like the ones in [[Java Programming/Variables#Kinds of variables|Variables]]}}
{{Programming/Navigation}}
{{Status|75%}}&lt;/noinclude&gt;</text>
      <sha1>skz1fyj8dyl0mlcg5rea2hhd3id82i1</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Stack trace</title>
    <ns>0</ns>
    <id>140688</id>
    <revision>
      <id>3533403</id>
      <parentid>3295252</parentid>
      <timestamp>2019-04-02T15:26:23Z</timestamp>
      <contributor>
        <ip>138.162.8.57</ip>
      </contributor>
      <comment>~ clarify meaning of stack trace</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="3499">&lt;noinclude&gt;{{Displaytitle|title=Stack trace}}
{{Programming/Navigation}}
{{Java Programming/ExceptionsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

A Stack Trace is a list of method calls from the point when the application was started to the current location of execution within the program.  A Stack Trace is produced automatically by the Java Virtual Machine when an exception is thrown to indicate the location and progression of the program up to the point of the exception.  The most recent method calls are at the top of the list.

{| style="width: 100%;"
|valign="top"|{{XCode|1=&lt;span id="code-listing-3"&gt;'''Code listing 6.3: StackTraceExample.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="15"&gt;
public class StackTraceExample {
  public static void main(String[] args) {
    method1();
  }

  public static void method1() {
    method11();
  }

  public static void method11() {
    method111();
  }

  public static void method111() {
    throw new NullPointerException("Fictitious NullPointerException");
  }
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code listing 6.3'''
&lt;pre style="background-color:black; color:white;"&gt;
Exception in thread "main" java.lang.NullPointerException: Fictitious NullPointerException
at StackTraceExample.method111(StackTraceExample.java:15)
at StackTraceExample.method11(StackTraceExample.java:11)
at StackTraceExample.method1(StackTraceExample.java:7)
at StackTraceExample.main(StackTraceExample.java:3)
&lt;/pre&gt;}}
|}

The stack trace can be printed to the standard error by calling the &lt;code&gt;public void printStackTrace()&lt;/code&gt; method of an exception.

From Java 1.4, the stack trace is encapsulated into an array of a java class called &lt;code&gt;java.lang.StackTraceElement&lt;/code&gt;.
The stack trace element array returned by &lt;code&gt;Throwable.getStackTrace()&lt;/code&gt; method. Each element represents a single stack frame. All stack frames except for the one at the top of the stack represent a method invocation. The frame at the top of the stack represents the execution point at which the stack trace was generated. Typically, this is the point at which the throwable corresponding to the stack trace was created.

A stack frame represents the following information:
{{XExample|1=&lt;span id="code-section-24"&gt;'''Code section 6.24: Stack frame.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1"&gt;
public StackTraceElement(String declaringClass,
                         String methodName,
                         String fileName,
                         int lineNumber);
&lt;/syntaxhighlight&gt;}}
Creates a stack trace element representing the specified execution point.

== Converting the stack trace into string ==
Many times for debugging purposes, we'd like to convert the stack trace to a {{java:String}} so we can log it to our log file.

The following code shows how to do that:

{{XExample|1=&lt;span id="code-section-25"&gt;'''Code section 6.25: Save the stack trace.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="8-10"&gt;
import java.io.StringWriter;
import java.io.PrintWriter;

...

  Exception e = new NullPointerException();

  StringWriter outError = new StringWriter();
  e.printStackTrace(new PrintWriter(outError));
  String errorString = outError.toString();

  // Do whatever you want with the errorString
&lt;/syntaxhighlight&gt;}}

&lt;noinclude&gt;
{{Todo|Add some exercises like the ones in [[Java Programming/Variables#Kinds of variables|Variables]]}}
{{Programming/Navigation}}
{{Status|75%}}&lt;/noinclude&gt;</text>
      <sha1>183vnihsy1lwm5nwr1ovdv5ermr8uib</sha1>
    </revision>
  </page>
  <page>
    <title>Java Programming/Nesting Exceptions</title>
    <ns>0</ns>
    <id>140123</id>
    <revision>
      <id>3295234</id>
      <parentid>3081180</parentid>
      <timestamp>2017-09-17T14:42:41Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>396820</id>
      </contributor>
      <minor/>
      <comment>Formatting, {{Programming/Navigation}} automation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text xml:space="preserve" bytes="5692">&lt;noinclude&gt;{{Displaytitle|title=Nesting Exceptions}}
{{Programming/Navigation}}
{{Java Programming/ExceptionsTopic/Nav}}
__NOTOC__&lt;/noinclude&gt;

When an exception is caught, the exception contains the [[Java Programming/Stack trace|stack-trace]], which describes the error and shows where the exception happened (i.e. where the problem is and where the application programmer should look to fix the problem). Sometimes it is desirable to catch an exception and throw another exception. If the new exception keeps a reference to the first exception, the first exception is called a ''nesting exception''.

{| style="width: 100%;"
|valign="top"|{{XCode|1=&lt;span id="code-listing-4"&gt;'''Code listing 6.4: NestingExceptionExample.java'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="9-12"&gt;
public class NestingExceptionExample {
 
  public static void main(String[] args) throws Exception {
    Object[] localArgs = (Object[]) args;
   
    try {
      Integer[] numbers = (Integer[]) localArgs;
    } catch (ClassCastException originalException) {
      Exception generalException = new Exception(
        "Horrible exception!",
        originalException);
      throw generalException;
    }
  }
}
&lt;/syntaxhighlight&gt;}}
|valign="top"|{{XConsole|1='''Output for Code listing 6.4'''
&lt;pre style="background-color:black; color:white;"&gt;
Exception in thread "main" java.lang.Exception: Horrible exception!
at NestingExceptionExample.main(NestingExceptionExample.java:9)
Caused by: java.lang.ClassCastException: [Ljava.lang.String; incompatible with [Ljava.lang.Integer;
at NestingExceptionExample.main(NestingExceptionExample.java:7)
&lt;/pre&gt;}}
|}

The above code is an example of a nesting exception. When the &lt;code&gt;Exception&lt;/code&gt; is thrown, by passing in the &lt;code&gt;ClassCastException&lt;/code&gt; object reference as a parameter, the &lt;code&gt;ClassCastException&lt;/code&gt; is nested in the newly created &lt;code&gt;Exception&lt;/code&gt;, its stack-trace is appended together. When the &lt;code&gt;Exception&lt;/code&gt; is caught, its stack-trace contains the original &lt;code&gt;ClassCastException&lt;/code&gt;'s stack-trace.

This is a kind of exception conversion, from one exception to another. For example, calling a remote object using RMI, the calling method has to deal with &lt;code&gt;RemoteException&lt;/code&gt; which is thrown if something is wrong during the communication. From the application point of view, &lt;code&gt;RemoteException&lt;/code&gt; has no meaning, it should be transparent to the application that a remote object was used or not. So the &lt;code&gt;RemoteException&lt;/code&gt; should be converted to an application exception.

This conversion can also hide where the error is originated. The stack-trace starts when the exception is thrown. So when we catch and throw a new exception, the stack-trace starts at when the new exception was thrown, losing the original stack-trace. This was true with the earlier version of Java (before 1.4). Since then, so called ''cause facility'' capabilities were built in the &lt;code&gt;Throwable&lt;/code&gt; class.

A throwable contains a snapshot of the execution stack of its thread at the time it was created. It can also contain a message string that gives more information about the error. Finally, it can contain a cause: another throwable that caused this throwable to get thrown. The cause facility is also known as the ''chained exception facility'', as the cause can, itself, have a cause, and so on, leading to a "chain" of exceptions, each caused by another.

A cause can be associated with a throwable in two ways: via a constructor that takes the cause as an argument, or via the &lt;code&gt;initCause(Throwable)&lt;/code&gt; method. New throwable classes that wish to allow causes to be associated with them should provide constructors that take a cause and delegate (perhaps indirectly) to one of the &lt;code&gt;Throwable&lt;/code&gt; constructors that takes a cause. For example:
{{XExample|1=&lt;span id="code-section-26"&gt;'''Code section 6.26: Chaining-aware constructor.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="4"&gt;
try {
    lowLevelOp();
} catch (LowLevelException le) {
    throw new HighLevelException(le);
}
&lt;/syntaxhighlight&gt;}}
Because the initCause method is public, it allows a cause to be associated with any throwable, even a "legacy throwable" whose implementation predates the addition of the exception chaining mechanism to Throwable. For example:
{{XExample|1=&lt;span id="code-section-27"&gt;'''Code section 6.27: Legacy constructor.'''&lt;/span&gt;
&lt;syntaxhighlight lang="Java5" line start="1" highlight="4"&gt;
try {
    lowLevelOp();
} catch (LowLevelException le) {
    throw (HighLevelException) new HighLevelException().initCause(le);
}
&lt;/syntaxhighlight&gt;}}

Further, as of release 1.4, many general purpose Throwable classes (for example &lt;code&gt;Exception&lt;/code&gt;, &lt;code&gt;RuntimeException&lt;/code&gt;, &lt;code&gt;Error&lt;/code&gt;) have been retrofitted with constructors that take a cause. This was not strictly necessary, due to the existence of the &lt;code&gt;initCause&lt;/code&gt; method, but it is more convenient and expressive to delegate to a constructor that takes a cause.

By convention, class &lt;code&gt;Throwable&lt;/code&gt; and its subclasses have two constructors, one that takes no arguments and one that takes a String argument that can be used to produce a detail message. Further, those subclasses that might likely have a cause associated with them should have two more constructors, one that takes a &lt;code&gt;Throwable&lt;/code&gt; (the cause), and one that takes a String (the detail message) and a &lt;code&gt;Throwable&lt;/code&gt; (the cause).

&lt;noinclude&gt;
{{Todo|Add some exercises like the ones in [[Java Programming/Variables#Kinds of variables|Variables]]}}
{{Programming/Navigation}}
{{Status|75%}}&lt;/noinclude&gt;</text>
      <sha1>0eo78t9z4ygwr3f3gmbbl6b1y4gj3xh</sha1>
    </revision>
  </page>
</mediawiki>
